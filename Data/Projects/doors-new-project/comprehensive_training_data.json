[
  {
    "file_name": "game_manager.verse",
    "questions": [
      "How can I create a main game controller that manages rooms, players, and game state in Verse?",
      "What is the Verse code for managing multiple rooms with event-driven communication?",
      "I need a script that handles player spawning, room progression, and game analytics in UEFN.",
      "How do I create a game manager that coordinates between different subsystems like persistence, camera, and audio?"
    ],
    "explanation": "This script serves as the central game controller for a horror game experience, managing all major game systems and coordinating between different components.\n\n**Core Components:**\n- game_audio_devices: A struct containing audio players for different game events (headache, death sounds, light flickers)\n- drawer_button_handler: A helper class for managing interactive drawer buttons with custom functions\n- game_manager: The main class that extends event_communicator_device, serving as the central hub\n\n**Key Features:**\n1. **Room Management**: Manages arrays of level rooms and side rooms, tracking current room index and handling room transitions\n2. **Player Management**: Sets up player data, handles spawning/respawning, and manages player state across the game\n3. **Event System**: Subscribes to both room events (room entered, puzzles solved, lights flicker) and player events (start/end run, elimination, entity survival)\n4. **Device Discovery**: Uses tag-based discovery to find and organize game objects (lights, locks, hiding points, etc.) across all rooms\n5. **Analytics Integration**: Tracks player progress, first-time experiences, and various game metrics\n6. **Persistence Integration**: Works with the persistence manager to save/load game progress\n7. **Audio Management**: Coordinates audio playback for different game events\n\n**How It Works:**\n- OnBegin() initializes all systems, sets up event subscriptions, and prepares the game state\n- Room setup uses volume tracing to automatically discover and assign devices to appropriate rooms\n- Event handlers process game events and coordinate responses across different systems\n- The manager maintains game state and ensures proper coordination between all subsystems",
    "code": "using { /Fortnite.com/Devices }\nusing { /Fortnite.com/Characters }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing {UtilityClasses}\n\ngame_audio_devices := struct<concrete>:\n    @editable\n    PlayerHeadache: audio_player_device = audio_player_device{}\n    @editable\n    PlayerDeath1: audio_player_device = audio_player_device{}\n    @editable\n    PlayerDeath2: audio_player_device = audio_player_device{}\n    @editable\n    LightsFlicker: audio_player_device = audio_player_device{}\n\nagent_function_type:= type{_(:agent):void}\ndrawer_button_handler := class:\n    DrawerButton: button_device\n    InteractFunction: agent_function_type\n    OnInteract(Agent: agent): void =\n        InteractFunction(Agent)\n        DrawerButton.Disable()\n\ngame_manager := class(event_communicator_device):\n    @editable\n    var AllRoomsData: []level_room_data = array{}\n    @editable\n    var AllSideRoomsData: []side_room_data = array{}\n    @editable\n    CameraManager: camera_manager = camera_manager{}\n    @editable\n    AccoladesManager: accolades_manager = accolades_manager{}\n    @editable\n    GameAudioDevices: game_audio_devices = game_audio_devices{}\n    \n    var CurrentRoomIndex : int = -1\n    var PlayerData: player_data = player_data{}\n    PersistenceManager: persistence_manager = persistence_manager{}\n\n    OnBegin<override>()<suspends> : void=\n        Setup()\n        SetupPlayer()\n        SetupRooms()\n        SetupSideRooms()\n        SubscribeToRoomEvent(NewRoomEvent, \"GM\")\n        SubscribeToPlayerEvent(NewPlayerEvent, \"GM\")\n        PersistenceManager.InitializeGameSaveData(PlayerReference)\n\n    NewRoomEvent(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        case (EventName):\n            event_names.NEW_ROOM_ENTERED =>\n                if(EventData := event_player_entered_room[Data]):\n                    RoomEntered(EventData)\n            event_names.PLAYER_SOLVED_PUZZLE =>\n                if(CurrentRoomData := AllRoomsData[CurrentRoomIndex]):\n                    CurrentRoomData.UnlockDoor()\n            _ => return\n\n    SetupRooms() : void=\n        for(RoomIndex -> RoomData: AllRoomsData):\n            RoomData.InitializeRoom(GlobalEventChannel, RoomIndex)",
    "external_calls": [
      "event_communicator_device",
      "level_room_data",
      "side_room_data",
      "player_data",
      "persistence_manager",
      "camera_manager",
      "accolades_manager"
    ]
  },
  {
    "file_name": "player_data.verse",
    "questions": [
      "How can I create a player data management system that tracks player state and handles events in Verse?",
      "What is the Verse code for managing player hiding mechanics and camera control?",
      "I need a script that handles player elimination, death messages, and audio feedback.",
      "How do I create a player data class that integrates with camera management and UI systems?"
    ],
    "explanation": "This script manages all player-related data and behaviors in the horror game, including state tracking, hiding mechanics, elimination sequences, and UI integration.\n\n**Core Components:**\n- player_data: Main class managing player state, health, hiding status, and current room progress\n- MakePlayerData: Constructor function for creating player data instances\n- Death message system with randomized messages\n- Audio management for player events\n\n**Key Features:**\n1. **State Management**: Tracks player state (ALIVE, DEATH_SCHEDULED, DEAD) and hiding status\n2. **Hiding System**: Manages player hiding mechanics with teleportation and button interaction\n3. **Elimination Sequences**: Handles player death with camera cutscenes and audio feedback\n4. **Event Integration**: Subscribes to player events and coordinates responses\n5. **UI Management**: Controls HUD messages, death screens, and jumpscare effects\n6. **Audio Coordination**: Manages various audio players for different player events\n7. **Room Progress Tracking**: Monitors maximum room reached for progression analytics\n\n**How It Works:**\n- SetupPlayer() initializes the player with all necessary references and event subscriptions\n- Event handlers process player actions like hiding, seeing entities, and being eliminated\n- The elimination system uses camera cutscenes to create dramatic death sequences\n- State tracking ensures proper game flow and prevents duplicate actions",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /Fortnite.com/Characters }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { Puzzles }\nusing { /UnrealEngine.com/Temporary/UI }\nusing { /Fortnite.com/UI }\nusing { /Verse.org/Assets }\nusing { /Fortnite.com/Game }\nusing { /Verse.org/Random }\n\nMakePlayerData<constructor>(NewPlayer: ?player, RoomIndex: int):= player_data:\n    CurrentPlayer := NewPlayer\n    ThisRunMaxRoomIndex := RoomIndex\n\nplayer_data := class:\n    var CurrentPlayer: ?player = false\n    var CurrentPlayerCharacter: ?fort_character = false\n    var GlobalEventChannel: global_event_channel = global_event_channel{}\n    var CameraManager: camera_manager = camera_manager{}\n    var HUDMessageDeath: hud_message_device = hud_message_device{}\n    var ThisRunMaxRoomIndex: int = -1\n    var IsHiding: logic = false\n    var CurrentState: player_state = player_state.ALIVE\n    var PlayerHeadache: audio_player_device = audio_player_device{}\n    var PlayerDeath1: audio_player_device = audio_player_device{}\n    var PlayerDeath2: audio_player_device = audio_player_device{}\n    var SkipDeathAudio: logic = false\n    var HUDMessageJumpscare: hud_message_device = hud_message_device{}\n    var TrackerJumpscare: tracker_device = tracker_device{}\n\n    AllDeathMessages: []string = array {\n        \"I GOT YOU!\",\n        \"BEWARE\",\n        \"DARE TO TRY AGAIN?\",\n        \"READY TO LEAVE?\",\n        \"HA HA HA\",\n        \"SO EASY\",\n        \"FRESH CATCH\",\n        \"THIS IS SO FUN\",\n        \"YOU WILL REGRET THIS!\"\n    }\n\n    CheckIsHiding<public>(): logic = \n        return IsHiding\n\n    CheckIsPlayerDead<public>()<transacts><decides>: void = \n        logic{CurrentState <> player_state.ALIVE}?\n\n    GetPlayer<public>(): ?player =\n        return CurrentPlayer\n\n    SetupPlayer(\n        NewGlobalEventChannel: global_event_channel,\n        NewCameraManager: camera_manager,\n        NewAudioDevices: game_audio_devices,\n        NewHUDDeath: hud_message_device,\n        NewHUDJumpscare: hud_message_device,\n        NewTrackerJumpscare: tracker_device\n    ): void =\n        set GlobalEventChannel = NewGlobalEventChannel\n        set CameraManager = NewCameraManager\n        set HUDMessageDeath = NewHUDDeath\n        set HUDMessageJumpscare = NewHUDJumpscare\n        set TrackerJumpscare = NewTrackerJumpscare\n\n        GlobalEventChannel.PlayerEventChannel.SubscribeChannel(NewPlayerEvent, \"player_data\")\n        if(ActualPlayer := CurrentPlayer?, ActualPlayerCharacter := ActualPlayer.GetFortCharacter[]):\n            set CurrentPlayerCharacter = option{ActualPlayerCharacter}\n            ActualPlayerCharacter.EliminatedEvent().Subscribe(PlayerEliminated)\n            CameraManager.SetupCameraManager(ActualPlayerCharacter)\n\n        set PlayerHeadache = NewAudioDevices.PlayerHeadache\n        set PlayerDeath1 = NewAudioDevices.PlayerDeath1\n        set PlayerDeath2 = NewAudioDevices.PlayerDeath2\n\n    NewPlayerEvent(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        if(ActualPlayer := CurrentPlayer?, ActualPlayer = player[Agent?]):\n            case (EventName):\n                event_names.PLAYER_START_RUN =>\n                    set ThisRunMaxRoomIndex = -1\n                event_names.PLAYER_SPAWNED => \n                    OnPlayerSpawned()\n                event_names.PLAYER_HIDE_TOGGLE =>\n                    if(EventData:= event_player_hide[Data]): \n                        ToggleHiding(EventData)\n                event_names.PLAYER_SEEING_EYES =>\n                    if(EventData:= event_player_sees_eyes[Data]):\n                        SeeingEyes(EventData)\n                event_names.PLAYER_JUMPSCARE =>\n                    spawn{FireJumpscare()}\n                event_names.PLAYER_ELIMINATED =>\n                    ResetPlayer()\n                _ => return\n\n    ToggleHiding(EventData: event_player_hide): void =\n        if(Player := CurrentPlayer?, PlayerFortCharacter := agent[Player].GetFortCharacter[]):\n            var TeleportTransform: transform = transform{}\n            if(IsHiding?):\n                set TeleportTransform = EventData.ExitTransform\n            else:\n                set TeleportTransform = EventData.HidingTransform\n                \n            if(PlayerFortCharacter.TeleportTo[TeleportTransform.Translation, TeleportTransform.Rotation]):\n                set IsHiding = logic{not IsHiding?}\n                if(PlayerAgent := agent[Player]):\n                    if(IsHiding?):\n                        EventData.HidingButton.SetInteractionText(StringToMessage(\"Exit\"))\n                        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_HIDE_SUCCESS, event_player_hide_success{ExitTransform := EventData.ExitTransform}, option{PlayerAgent})\n                    else:\n                        EventData.HidingButton.SetInteractionText(StringToMessage(\"Hide\"))\n                        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_UNHIDE_SUCCESS, event_data{}, option{PlayerAgent})\n\n    PlayerEliminateByEntity(EliminateSource: transform, EliminationText: ?string): void =\n        if(not CheckIsPlayerDead[]):\n            spawn{PlayerEliminateCutscene(EliminateSource, EliminationText)}\n\n    PlayerEliminateCutscene(EliminateSource: transform, EliminationText: ?string)<suspends>: void =\n        if(not CheckIsPlayerDead[]):\n            set CurrentState = player_state.DEATH_SCHEDULED\n            StopAllAudios()\n            if(EliminationString := EliminationText?):\n                HUDMessageDeath.SetText(StringToMessage(EliminationString))\n            else:\n                HUDMessageDeath.SetText(GetRandomDeathMessage())\n            HUDMessageDeath.Show()\n\n            CameraManager.MoveCameraFromPlayerToTarget(EliminateSource, 2.0)\n            Sleep(2.0)\n            CameraManager.MoveCameraBackToPlayer()\n            if(ActualPlayerCharacter := CurrentPlayerCharacter?):\n                set SkipDeathAudio = true\n                ActualPlayerCharacter.Damage(ActualPlayerCharacter.GetHealth())",
    "external_calls": [
      "player_state",
      "global_event_channel",
      "camera_manager",
      "game_audio_devices",
      "event_names",
      "event_data",
      "event_player_hide",
      "event_player_sees_eyes",
      "event_player_hide_success",
      "StringToMessage",
      "GetRandomDeathMessage",
      "StopAllAudios",
      "FireJumpscare"
    ]
  },
  {
    "file_name": "persistence_manager.verse",
    "questions": [
      "How can I create a save/load system for player progress in Verse?",
      "What is the Verse code for managing persistent game data across sessions?",
      "I need a script that handles player statistics, upgrades, and vault progress.",
      "How do I create a persistence system that tracks first-time experiences and room progress?"
    ],
    "explanation": "This script manages all persistent game data, allowing players to maintain progress across game sessions. It handles save/load operations for various game statistics and player achievements.\n\n**Core Components:**\n- game_persistent_data: Main persistable class containing all save data\n- vault_data_persistent: Manages lobby vault unlock states and prop placements\n- upgrade_data_persistent: Tracks player upgrade levels\n- persistence_manager: Main class handling save/load operations\n\n**Key Features:**\n1. **Progress Tracking**: Monitors room progression, first-time experiences, and completion status\n2. **Vault System**: Manages lobby vault states and prop placement persistence\n3. **Upgrade System**: Tracks player upgrade levels and coin collection\n4. **Analytics Integration**: Stores data for analytics events to prevent duplicate submissions\n5. **Version Control**: Includes versioning system for save data structure changes\n6. **Side Room Tracking**: Maintains record of discovered side rooms\n\n**How It Works:**\n- InitializeGameSaveData() sets up the save system for a player\n- Various Update functions modify specific aspects of save data\n- The system uses weak_map to associate save data with players\n- MakeGameSaveData constructor ensures data integrity during updates\n- All persistent data classes are marked with <persistable> for automatic serialization",
    "code": "using { /Fortnite.com/Devices }\nusing { /Fortnite.com/Characters }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\n\ngame_persistent_data := class<final><persistable>:\n    Version: int = 1\n    FirstTimeGameEntered: logic = false\n    ReceptionEntered: logic = false\n    MaxRoomIndexReached: int = -1\n    SideRoomChecked: [int]logic = map{}\n    FirstRunCompleted: logic = false\n    LobbyVaults: [vault_type]vault_data_persistent = map{}\n    CoinCollectedCount : int = 0\n    Upgrades: [upgrade_type]upgrade_data_persistent = map{}\n    FastestRunYetSeconds: int = 9999\n\nvault_data_persistent := class<final><persistable>:\n    VaultType: vault_type = vault_type.NONE\n    IsUnlocked: logic = false\n    IsButtonEnabled: logic = false\n    LobbyPropsPlaced: []logic = array{}\n\nupgrade_data_persistent := class<final><persistable>:\n    UpgradeType: upgrade_type = upgrade_type.NONE\n    CurrentLevel: int = 0\n\nvar GameSaveData:weak_map(player, game_persistent_data) = map{}\n\nMakeGameSaveData<constructor>(OldData: game_persistent_data)<transacts> := game_persistent_data:\n    Version := OldData.Version\n    FirstTimeGameEntered := OldData.FirstTimeGameEntered\n    ReceptionEntered := OldData.ReceptionEntered\n    MaxRoomIndexReached := OldData.MaxRoomIndexReached\n    SideRoomChecked := OldData.SideRoomChecked\n    LobbyVaults := OldData.LobbyVaults\n    CoinCollectedCount := OldData.CoinCollectedCount\n    Upgrades := OldData.Upgrades\n    \npersistence_log := class(log_channel){}\npersistence_manager := class():\n    Logger : log = log{Channel := persistence_log}\n    var Player: ?player = false\n\n    GetGameSaveData()<decides><transacts>: game_persistent_data =\n        var SaveData: game_persistent_data = game_persistent_data{}\n        if:\n            APlayer := Player?\n            PlayerSaveData := GameSaveData[APlayer]\n            set SaveData = PlayerSaveData\n        return SaveData\n\n    UpdateSaveFirstTimeGameEntered(): void = \n        Logger.Print(\"UpdateSaveFirstTimeGameEntered attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                FirstTimeGameEntered := true\n        \n            Logger.Print(\"UpdateSaveFirstTimeGameEntered success\")\n\n    UpdateSaveReceptionEntered(): void = \n        Logger.Print(\"UpdateSaveReceptionEntered attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                ReceptionEntered := true\n        \n            Logger.Print(\"UpdateSaveReceptionEntered success\")\n    \n    UpdateSaveMaxRoom(NewRoomIndex: int): void = \n        Logger.Print(\"UpdateSaveMaxRoom attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                MaxRoomIndexReached := NewRoomIndex\n        \n            Logger.Print(\"UpdateSaveMaxRoom success\")\n\n    UpdateSaveSideRoom(NewSideRoomIndex: int): void = \n        Logger.Print(\"UpdateSaveSideRoom attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            NewSideRoomKeyVal := map{NewSideRoomIndex => true}\n            NewSideRoomChecked := ConcatenateMaps(PlayerSaveData.SideRoomChecked, NewSideRoomKeyVal)\n\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                SideRoomChecked := NewSideRoomChecked\n        \n            Logger.Print(\"UpdateSaveSideRoom success\")\n\n    UpdateFirstRunCompleted(): void = \n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                FirstRunCompleted := true\n        \n            Logger.Print(\"UpdateFirstRunCompleted success\")\n\n    UpdateSaveUpgrades(NewUpgradeType: upgrade_type, NewUpgradeData: upgrade_data_persistent): void =\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n        then:\n            var SavedUpgrades : [upgrade_type]upgrade_data_persistent = PlayerSaveData.Upgrades\n            if:\n                set SavedUpgrades[NewUpgradeType] = NewUpgradeData\n                set GameSaveData[APlayer] = game_persistent_data:\n                    MakeGameSaveData<constructor>(PlayerSaveData)\n                    Upgrades := SavedUpgrades\n\n                Logger.Print(\"UpdateSaveUpgrades success\")\n\n    InitializeGameSaveData(NewPlayer: ?player): void =\n        set Player = NewPlayer\n        PrintGameSaveData()\n\n    PrintGameSaveData(): void =\n        if:\n            PlayerSaveData := GetGameSaveData[]\n        then:\n            Logger.Print(\"GAME SAVE DATA:\")\n            Logger.Print(\"Version: {PlayerSaveData.Version}\")",
    "external_calls": [
      "vault_type",
      "upgrade_type",
      "log_channel",
      "ConcatenateMaps"
    ]
  },
  {
    "file_name": "camera_manager.verse",
    "questions": [
      "How can I create a camera system for cutscenes and player elimination sequences in Verse?",
      "What is the Verse code for moving cameras between player and target positions?",
      "I need a script that handles camera transitions and cinematic sequences.",
      "How do I create a camera manager that controls player visibility and movement during cutscenes?"
    ],
    "explanation": "This script manages camera operations for cinematic sequences, particularly during player elimination scenes. It provides smooth camera transitions and player state management during cutscenes.\n\n**Core Components:**\n- camera_manager: Main class extending creative_device for camera control\n- Cutscene camera system with first-person gameplay camera\n- Player character state management during camera sequences\n\n**Key Features:**\n1. **Cutscene Control**: Manages transitions between player camera and cinematic camera\n2. **Player State Management**: Handles player visibility and movement restrictions during cutscenes\n3. **Smooth Transitions**: Provides timed camera movement between positions\n4. **Fallback Systems**: Includes safety mechanisms for camera movement failures\n5. **Stasis Control**: Manages player movement restrictions during camera sequences\n\n**How It Works:**\n- SetupCameraManager() initializes the system with player character reference\n- MoveCameraFromPlayerToTarget() creates dramatic camera movements for elimination sequences\n- The system uses cinematic_sequence_device to control camera activation\n- Player is put in stasis and hidden during camera sequences\n- MoveCameraBackToPlayer() restores normal gameplay camera and player control\n- Race conditions handle timeout scenarios to prevent camera lock-ups",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /Fortnite.com/Characters }\nusing { /Fortnite.com/Game }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\n\ncamera_manager := class(creative_device):\n    @editable \n    CutsceneCamera : gameplay_camera_first_person_device = gameplay_camera_first_person_device{}\n    @editable \n    CutsceneCameraHolder : creative_prop = creative_prop{}\n    @editable \n    StartSequence : cinematic_sequence_device = cinematic_sequence_device{}\n\n    var CurrentPlayerCharacter: ?fort_character = false\n\n    SetupCameraManager(NewPlayerCharacter: fort_character): void =\n        set CurrentPlayerCharacter = option{NewPlayerCharacter}\n\n    MoveCameraFromPlayerToTarget(TargetTransform: transform, MoveTime: float)<suspends>: logic =\n        var CameraMoveSuccessful: logic = false\n        if(PlayerCharacter := CurrentPlayerCharacter?):\n            # Stop player movement\n            PlayerCharacter.PutInStasis(stasis_args{ AllowTurning := false })\n            PlayerCharacter.Hide()\n            PlayerLocation := PlayerCharacter.GetTransform().Translation\n            PlayerRotation := PlayerCharacter.GetTransform().Rotation\n\n            if:\n                CutsceneCameraHolder.TeleportTo[\n                    PlayerLocation + (PlayerRotation.GetLocalForward() * -100.0),\n                    PlayerRotation\n                ]\n            then:\n                # Switch to cutscene camera\n                StartSequence.Play()\n                CameraTargetLocation := TargetTransform.Translation\n                CameraTargetRotation := TargetTransform.Rotation\n                Print(\"MoveCameraFromPlayerToTarget: {CameraTargetLocation}\")\n\n                # Move the cutscene camera to look at spawn transform\n                race:\n                    block:\n                        MoveResult := CutsceneCameraHolder.MoveTo(CameraTargetLocation, CameraTargetRotation, MoveTime)\n                        case (MoveResult):\n                            move_to_result.DestinationReached =>\n                                set CameraMoveSuccessful = true\n                            _ => # default\n                                Print(\"camera_manager: CutsceneCameraHolder move fail\")\n                                MoveCameraBackToPlayer()\n\n                    block:\n                        # fallback to early exit in case of MoveTo blocked situations\n                        Sleep(MoveTime + 2.0)\n                        Print(\"Fallback hit!\")\n                        MoveCameraBackToPlayer()\n        else:\n            Print(\"camera_manager: CurrentPlayerCharacter not found\")\n\n        return CameraMoveSuccessful\n\n    MoveCameraToTarget(TargetTransform: transform, MoveTime: float)<suspends>: logic =\n        var CameraMoveSuccessful: logic = false\n        if(PlayerCharacter := CurrentPlayerCharacter?):\n            PlayerCharacter.PutInStasis(stasis_args{ AllowTurning := false })\n            PlayerCharacter.Hide()\n            \n            StartSequence.Play()\n            CameraTargetLocation := TargetTransform.Translation\n            CameraTargetRotation := TargetTransform.Rotation\n            Print(\"MoveCameraToTarget: {CameraTargetLocation}\")\n\n            MoveResult := CutsceneCameraHolder.MoveTo(CameraTargetLocation, CameraTargetRotation, MoveTime)\n            case (MoveResult):\n                move_to_result.DestinationReached =>\n                    set CameraMoveSuccessful = true\n                _ => # default\n                    Print(\"camera_manager: CutsceneCameraHolder move fail\")\n                    MoveCameraBackToPlayer()\n        else:\n            Print(\"camera_manager: CurrentPlayerCharacter not found\")\n\n        return CameraMoveSuccessful\n\n    MoveCameraBackToPlayer()<suspends>: void =\n        if(PlayerCharacter := CurrentPlayerCharacter?):\n            Print(\"MoveCameraBackToPlayer started\")\n            PlayerLocation := PlayerCharacter.GetTransform().Translation\n            PlayerRotation := PlayerCharacter.GetTransform().Rotation\n\n            CutsceneCameraHolder.MoveTo(PlayerLocation, PlayerRotation, 1.0)\n            StartSequence.Stop()\n            PlayerCharacter.ReleaseFromStasis()\n            PlayerCharacter.Show()\n            Print(\"MoveCameraBackToPlayer end\")\n\n    ShakeCamera()<suspends>: void =\n        return",
    "external_calls": [
      "creative_device",
      "gameplay_camera_first_person_device",
      "cinematic_sequence_device",
      "fort_character",
      "stasis_args",
      "move_to_result"
    ]
  },
  {
    "file_name": "accolades_manager.verse",
    "questions": [
      "How can I create an achievement system that awards players for different accomplishments in Verse?",
      "What is the Verse code for managing accolades and rewards based on player progress?",
      "I need a script that handles different types of achievements like room progression and entity survival.",
      "How do I create an accolades system that integrates with item granting and analytics?"
    ],
    "explanation": "This script manages the achievement/accolades system, rewarding players for various accomplishments throughout the game. It provides a comprehensive reward system for player engagement.\n\n**Core Components:**\n- accolades_manager: Main class extending creative_device for achievement management\n- Multiple accolades_device instances for different achievement types\n- Item granter integration for physical rewards\n\n**Key Features:**\n1. **Room Progression Rewards**: Awards achievements for reaching specific room milestones (quarter, half, full run)\n2. **Entity Survival Rewards**: Recognizes players for surviving encounters with different entities\n3. **Interaction Rewards**: Rewards players for successful interactions like drawer searches\n4. **Milestone Tracking**: Provides different achievement levels based on progress\n5. **Item Integration**: Connects achievements with item granting systems\n6. **Analytics Integration**: Tracks achievement events for game analytics\n\n**How It Works:**\n- OnBegin() sets up event subscriptions for all achievement types\n- SpawnRoomEnterAccolade() handles room-based achievements with progressive rewards\n- Different achievement methods award specific accolades based on player actions\n- The system integrates with item granters to provide tangible rewards\n- Test methods provide debugging and verification capabilities",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\n\naccolades_manager := class(creative_device):\n    @editable\n    RoomEnter: accolades_device = accolades_device{}\n    @editable\n    DrawerSuccess: accolades_device = accolades_device{}\n    @editable\n    EscapeRush: accolades_device = accolades_device{}\n    @editable\n    EscapeFreeze: accolades_device = accolades_device{}\n    @editable\n    EscapeSeek: accolades_device = accolades_device{}\n    @editable\n    FullRunComplete: accolades_device = accolades_device{}\n    @editable\n    HalfRunComplete: accolades_device = accolades_device{}\n    @editable\n    QuarterRunComplete: accolades_device = accolades_device{}\n    @editable\n    ItemGranters: []item_granter_device = array{}\n\n    OnBegin<override>()<suspends>: void =\n        RoomEnter.TestAwardEvent.Subscribe(RoomEnterTest)\n        EscapeRush.TestAwardEvent.Subscribe(EscapeRushTest)\n        EscapeFreeze.TestAwardEvent.Subscribe(EscapeFreezeTest)\n        EscapeSeek.TestAwardEvent.Subscribe(EscapeSeekTest)\n        QuarterRunComplete.TestAwardEvent.Subscribe(QuarterRunCompleteTest)\n        HalfRunComplete.TestAwardEvent.Subscribe(HalfRunCompleteTest)\n        FullRunComplete.TestAwardEvent.Subscribe(FullRunCompleteTest)\n        DrawerSuccess.TestAwardEvent.Subscribe(DrawerSuccessTest)\n\n        for(ItemGranter: ItemGranters):\n            ItemGranter.ItemGrantedEvent.Subscribe(ItemGranted)\n\n    SpawnRoomEnterAccolade(PlayerAgent: agent, CurrentRoomIndex: int)<suspends>: void =\n        Sleep(2.0)\n        case (CurrentRoomIndex):\n            10 => \n                QuarterRunComplete.Award(PlayerAgent)\n            20 => \n                HalfRunComplete.Award(PlayerAgent)\n            _ => # default\n                RoomEnter.Award(PlayerAgent)\n\n    ItemGranted(Agent: agent): void =\n        DrawerSuccess.Award(Agent)\n\n    RoomEnterTest(Agent: agent): void =\n        Print(\"ACCOLADE: RoomEnter\")\n\n    EscapeRushTest(Agent: agent): void =\n        Print(\"ACCOLADE: EscapeRush\")\n        \n    EscapeFreezeTest(Agent: agent): void =\n        Print(\"ACCOLADE: EscapeFreeze\")\n        \n    EscapeSeekTest(Agent: agent): void =\n        Print(\"ACCOLADE: EscapeSeek\")\n\n    QuarterRunCompleteTest(Agent: agent): void =\n        Print(\"ACCOLADE: QuarterRunComplete\")\n\n    HalfRunCompleteTest(Agent: agent): void =\n        Print(\"ACCOLADE: HalfRunComplete\")\n\n    FullRunCompleteTest(Agent: agent): void =\n        Print(\"ACCOLADE: FullRunComplete\")\n\n    DrawerSuccessTest(Agent: agent): void =\n        Print(\"ACCOLADE: DrawerSuccess\")",
    "external_calls": [
      "creative_device",
      "accolades_device",
      "item_granter_device"
    ]
  },
  {
    "file_name": "random_spooks_manager.verse",
    "questions": [
      "How can I create a random scare system that triggers spooky events in Verse?",
      "What is the Verse code for managing probability-based jump scares and random events?",
      "I need a script that handles random spooky events with volume triggers and timers.",
      "How do I create a spook manager that can trigger events after delays or on volume entry?"
    ],
    "explanation": "This script manages random spooky events in the horror game, creating unpredictable scares to enhance the atmosphere. It provides flexible triggering mechanisms for various spook types.\n\n**Core Components:**\n- random_spooks_data: Configuration class for spook events with probability and timing settings\n- random_spooks_manager: Main class extending event_communicator for spook coordination\n- spook_type enum: Defines different trigger types (AFTER_SECONDS, ON_ENTER_VOLUME)\n\n**Key Features:**\n1. **Probability-Based Events**: Uses random number generation with configurable probability percentages\n2. **Multiple Trigger Types**: Supports both time-based and volume-based triggering\n3. **Jumpscare System**: Manages random jumpscare events with player-specific targeting\n4. **Flexible Configuration**: Allows different spook types with individual settings\n5. **Event Integration**: Connects with the global event system for coordinated responses\n6. **Volume Management**: Handles mutator zone enabling/disabling for trigger control\n\n**How It Works:**\n- SetupSpooks() initializes the system with configuration data and player reference\n- Different spook types use different triggering mechanisms (timers vs. volume entry)\n- Random number generation determines if events trigger based on configured probabilities\n- JumpscareSchedule() handles time-based random events with delays\n- Volume-based events trigger immediately when players enter designated areas\n- All events broadcast through the global event channel for system-wide coordination",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /Verse.org/Random }\n\nrandom_spooks_data := class:\n    @editable\n    JumpscareType: spook_type = spook_type.AFTER_SECONDS\n    @editable\n    JumpscareVolume: mutator_zone_device = mutator_zone_device{}\n    @editable\n    JumpscareProbability: int = 0\n    @editable\n    JumpscareAfterSeconds: float = 0.0\n    @editable\n    MovePropsType: spook_type = spook_type.AFTER_SECONDS\n    @editable\n    MovePropsVolume: mutator_zone_device = mutator_zone_device{}\n    @editable\n    MovePropsProbability: int = 0\n    @editable\n    MovePropsAfterSeconds: float = 0.0\n\nrandom_spooks_manager := class(event_communicator):\n    var SpooksData: random_spooks_data = random_spooks_data{}\n    var PlayerInRoom: ?player = false\n\n    SetupSpooks(NewGlobalEventChannel: global_event_channel, NewSpooksData: random_spooks_data, NewPlayer: player): void =\n        Setup(NewGlobalEventChannel)\n        set SpooksData = NewSpooksData\n        set PlayerInRoom = option{NewPlayer}\n\n        case (SpooksData.JumpscareType):\n            spook_type.AFTER_SECONDS =>\n                ToggleJumpscareVolume(false)\n                spawn{JumpscareSchedule()}\n            spook_type.ON_ENTER_VOLUME =>\n                ToggleJumpscareVolume(true)\n                SpooksData.JumpscareVolume.AgentEntersEvent.Subscribe(JumpscareVolumeEntered)\n\n    JumpscareSchedule()<suspends>: void =\n        Print(\"scheduling jumpscare maybe\")\n        RNG := GetRandomInt(1,100)\n        if(RNG <= SpooksData.JumpscareProbability):\n            Sleep(SpooksData.JumpscareAfterSeconds)\n            FireJumpscare()\n        \n    JumpscareVolumeEntered(Agent: agent): void =\n        if(Player := PlayerInRoom?, Agent = Player):\n            Print(\"volume jumpscare maybe\")\n            RNG := GetRandomInt(1,100)\n            if(RNG <= SpooksData.JumpscareProbability):\n                FireJumpscare()\n\n    ToggleJumpscareVolume(Active: logic): void =\n        if(Active?):\n            SpooksData.JumpscareVolume.Enable()\n        else:\n            SpooksData.JumpscareVolume.Disable()\n\n    FireJumpscare(): void =\n        Print(\"Firing jumpscare YES\")\n        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_JUMPSCARE, event_player_jumpscare{}, PlayerInRoom)",
    "external_calls": [
      "event_communicator",
      "spook_type",
      "global_event_channel",
      "event_names",
      "event_player_jumpscare",
      "GetRandomInt"
    ]
  }
] 