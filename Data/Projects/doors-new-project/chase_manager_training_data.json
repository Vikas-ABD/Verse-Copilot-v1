[
  {
    "file_name": "chase_manager.verse",
    "questions": [
      "How can I create a cinematic chase sequence system with dynamic camera work and entity pursuit mechanics in Verse?",
      "What is the Verse code for implementing a horror game chase manager with cutscenes, VFX, and room progression tracking?",
      "I need a script that handles chase sequences with spawn effects, camera transitions, and player elimination mechanics.",
      "How do I create a chase system with state management, room analytics, and synchronized visual effects?"
    ],
    "explanation": "This script provides a comprehensive chase sequence system for a horror game, implementing cinematic chase mechanics with dynamic camera work, visual effects, and room progression tracking. It's designed to create intense, scripted chase sequences with proper state management and analytics.\n\n**Core Components:**\n- chase_manager: Main chase controller extending event_communicator_device\n- CHASE_STATE enum with CHASE_STOPPED, CHASE_STARTED, CHASE_STOPPING states\n- room_enter_handler: Room progression tracking system\n- chase_room_death_analytics: Analytics system for room-specific death tracking\n- Cinematic camera system with multiple camera positions\n- VFX coordination system for spawn and background effects\n- Dynamic entity movement with speed calculations\n\n**Key Features:**\n1. **Cinematic Chase Sequences**: Multi-stage cutscenes with camera transitions and VFX coordination\n2. **Dynamic Entity Movement**: Speed-based pursuit mechanics with real-time player tracking\n3. **Room Progression System**: Analytics tracking for player progress through chase rooms\n4. **State Management**: Comprehensive chase state system with proper cleanup\n5. **Visual Effects Coordination**: Synchronized spawn VFX and background effects\n6. **Camera Management**: Multiple camera positions for intro, chase, and end sequences\n7. **Audio Integration**: Dynamic music management tied to chase states\n8. **Analytics System**: Room-specific death tracking and player survival metrics\n\n**Chase State System:**\n- **CHASE_STOPPED**: Inactive state, chase not running\n- **CHASE_STARTED**: Active chase in progress with entity pursuit\n- **CHASE_STOPPING**: Transition state during chase conclusion\n- **State Transitions**: Proper state management with cleanup between phases\n\n**Cinematic System:**\n- **PlayStartCutscene()**: Multi-stage intro sequence with camera work and VFX\n- **PlayEndCutscene()**: Victory sequence with door locking and music transition\n- **Camera Positions**: ChaseIntroCameraLocationProp, ChaseStartCameraLocationProp, ChaseEndCameraLocationProp\n- **VFX Coordination**: SpawnVFX for entity appearance, BGVFX for atmospheric effects\n- **Audio Management**: ChaseMusic for tension, ChaseEndMusic for resolution\n\n**Entity Movement System:**\n- **MoveSeek()**: Dynamic entity positioning with rotation and timing\n- **CalculateSeekSpeed()**: Distance-based speed calculation for realistic pursuit\n- **ChasePlayer()**: Continuous player tracking with proximity-based elimination\n- **StickExternalDevicesToNPC()**: Device positioning system for entity coordination\n\n**Room Analytics System:**\n- **chase_room_death_analytics**: Data structure for room-specific analytics\n- **room_enter_handler**: Event handler for room progression tracking\n- **SetupRoomsDeathsAnalytics()**: Initialization of room tracking system\n- **UpdateChaseRoom()**: Room progression state management\n- **ToggleChaseRoomDeathVolumes()**: Volume activation control for room tracking\n\n**Visual Effects Management:**\n- **SpawnVFX**: Entity spawn effects with positioning and timing\n- **BGVFX**: Background atmospheric effects\n- **VFX Synchronization**: Coordinated effects timing with entity movement\n- **ResetVFX()**: Proper cleanup of visual effects\n\n**Camera System:**\n- **ChaseCamera**: First-person chase camera for immersive experience\n- **CutsceneCameraHolder**: Cinematic camera positioning system\n- **Camera Transitions**: Smooth transitions between player and cinematic views\n- **Multiple Camera Positions**: Strategic positioning for different chase phases\n\n**Audio Management:**\n- **ChaseMusic**: Tension-building music during active chase\n- **ChaseEndMusic**: Resolution music for successful escape\n- **Dynamic Audio Control**: State-based audio activation and deactivation\n- **Audio Synchronization**: Coordinated audio with visual and gameplay events\n\n**Player Elimination System:**\n- **PlayerKill()**: Instant elimination with cinematic death sequence\n- **GetKillMessage()**: Randomized death messages for variety\n- **PlayerDeathCutsceneView**: Cinematic camera positioning for death sequences\n- **Death Analytics**: Player death tracking with analytics submission\n\n**Room Progression:**\n- **ChaseRoomsProgress**: Current room index tracking\n- **Room Enter Volumes**: Spatial triggers for room progression detection\n- **Progress Analytics**: Room-specific death analytics for difficulty balancing\n- **Dynamic Room Management**: Automatic room state updates based on player progress\n\n**External Device Management:**\n- **ExternalDevicesRoot**: Central device positioning system\n- **Device Synchronization**: Coordinated movement of all entity-related devices\n- **Initial Position Tracking**: Proper reset functionality for device positioning\n- **Update Rate Control**: Configurable update frequency for smooth movement\n\n**Speed Calculation System:**\n- **CalculateSeekSpeed()**: Distance-based speed calculation for realistic pursuit\n- **SeekSpeed**: Configurable base speed for entity movement\n- **Dynamic Speed Adjustment**: Real-time speed calculation based on player distance\n- **CalculateTime()**: Time calculation utility for movement coordination\n\n**Event Integration:**\n- **NewPlayerEvent()**: Global event system integration\n- **Player State Tracking**: Hide/unhide event handling\n- **Run State Management**: Start/end run event coordination\n- **Death Event Handling**: Player elimination event processing\n\n**Cleanup and Reset:**\n- **ResetChase()**: Comprehensive chase state reset\n- **ResetEverythingBack()**: Full system reset to initial positions\n- **ResetVFX()**: Visual effects cleanup\n- **Proper State Management**: Clean transitions between chase instances\n\n**Technical Implementation:**\n- **Asynchronous Processing**: Suspending functions for smooth cutscene execution\n- **Race Conditions**: Proper handling of simultaneous movement and timing\n- **Sync Blocks**: Coordinated execution of multiple simultaneous operations\n- **Transform Management**: Precise positioning and rotation control\n- **Distance Calculations**: DistanceXY for 2D distance, Distance for 3D proximity\n\n**Integration Points:**\n- **Player Data System**: Coordinates with player_data for elimination and camera management\n- **Camera Manager**: Integrates with camera_manager for cinematic sequences\n- **Global Events**: Uses global event system for coordinated game state management\n- **Analytics System**: Comprehensive tracking for gameplay metrics and balancing\n\n**Chase Sequence Flow:**\n1. **Initialization**: StartChase() receives player data and spawn configuration\n2. **Cutscene Setup**: PlayStartCutscene() orchestrates intro sequence with camera and VFX\n3. **Entity Spawn**: Coordinated VFX and entity positioning for dramatic appearance\n4. **Chase Initiation**: ChasePlayer() begins continuous player pursuit\n5. **Dynamic Pursuit**: Real-time speed calculation and entity movement toward player\n6. **Proximity Detection**: Continuous distance monitoring for elimination trigger\n7. **Conclusion**: Either PlayerKill() for elimination or PlayEndCutscene() for escape\n8. **Cleanup**: ResetChase() returns system to initial state for next sequence\n\n**Use Cases:**\n- **Scripted Horror Sequences**: Cinematic chase scenes with guaranteed tension\n- **Dynamic Difficulty**: Speed-based pursuit that adapts to player distance\n- **Room-Based Progression**: Tracking player progress through multi-room sequences\n- **Analytics Collection**: Detailed metrics for gameplay balancing and difficulty tuning\n- **Cinematic Storytelling**: Camera work and VFX for narrative impact\n\n**How It Works:**\n1. **Setup**: OnBegin() initializes all systems, event subscriptions, and analytics\n2. **Chase Trigger**: StartChase() receives player data and begins sequence\n3. **Cinematic Intro**: Multi-stage cutscene with camera transitions and VFX coordination\n4. **Entity Spawn**: Dramatic appearance with synchronized visual and audio effects\n5. **Active Chase**: Continuous player tracking with dynamic speed calculation\n6. **Proximity Monitoring**: Real-time distance checking for elimination trigger\n7. **Conclusion Handling**: Either elimination sequence or escape cutscene\n8. **System Reset**: Complete cleanup and state reset for repeatability\n9. **Analytics Submission**: Room-specific death tracking and survival metrics",
    "code": "\nusing { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /Fortnite.com/Characters }\nusing { /Fortnite.com/Game }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /Verse.org/Random }\n\nint_function_type:= type{_(:int):void}\nchase_room_death_analytics := class:\n    @editable\n    RoomEnterVolume: mutator_zone_device = mutator_zone_device{}\n    @editable\n    RoomDeathAnalyticsDevice : analytics_device = analytics_device{}\n\nroom_enter_handler := class:\n    RoomIndex: int = -1\n    RoomEnterVolume: mutator_zone_device = mutator_zone_device{}\n    UpdateChaseRoomFunction: int_function_type\n    OnEnter(Agent: agent): void =\n        Print(\"SEEK: RoomEnterVolume {RoomIndex}\")\n        RoomEnterVolume.Disable()\n        UpdateChaseRoomFunction(RoomIndex)\n\nCHASE_STATE := enum:\n    CHASE_STOPPED\n    CHASE_STARTED\n    CHASE_STOPPING\n\nChaseReferencesCategory<public><localizes>:message := \"Change Every Chase\"\n# A Verse-authored creative device that can be placed in a level\nchase_manager<public> := class(event_communicator_device):\n    @editable \n    ChaseCamera : gameplay_camera_first_person_device = gameplay_camera_first_person_device{}\n    @editable \n    CutsceneCameraHolder : creative_prop = creative_prop{}\n    @editable \n    StartSequence : cinematic_sequence_device = cinematic_sequence_device{}\n    @editable\n    ExternalDevicesRoot: creative_prop = creative_prop{}\n    @editable\n    SpawnVFX: vfx_spawner_device = vfx_spawner_device{}\n    @editable\n    BGVFX: vfx_spawner_device = vfx_spawner_device{}\n    # @editable \n    # ChaseStartVolume : mutator_zone_device = mutator_zone_device{}\n    @editable \n    SeekProp : creative_prop = creative_prop{}\n    @editable \n    ChaseMusic : audio_player_device = audio_player_device{}\n    @editable \n    ChaseEndMusic : audio_player_device = audio_player_device{}\n    @editable\n    PlayerDeathCutsceneView: creative_prop = creative_prop{}\n    @editable\n    PlayerDeathAnalyticsDevice: analytics_device = analytics_device{}\n\n    @editable\n    SeekSpeed : float = 6.0\n    @editable\n    ChaseIntroCameraLocationProp: creative_prop = creative_prop{}\n    @editable\n    ChaseStartCameraLocationProp: creative_prop = creative_prop{}\n    @editable\n    ChaseEndCameraLocationProp: creative_prop = creative_prop{}\n\n    # @editable\n    # DamageVolume : damage_volume_device = damage_volume_device{}\n    @editable\n    EndDoorLockDevice : lock_device = lock_device{}\n    @editable\n    ChaseEndVolume : mutator_zone_device = mutator_zone_device{}\n\n    @editable\n    ChaseRoomsDeathsAnalytics: []chase_room_death_analytics = array{}\n    var ChaseRoomsProgress: int = 0\n\n    SeekPropHalfHeight : float = 200.0\n    BGDistanceFromSeekProp : float = 300.0\n\n    var CurrentPlayer : ?player = false\n    var CurrentPlayerCharacter: ?fort_character = false\n    var CurrentPlayerData: player_data = player_data{}\n    var SeekSpawnTransformProp: creative_prop = creative_prop{}\n    var ChaseActive: logic = false\n    var ChaseState: CHASE_STATE = CHASE_STATE.CHASE_STOPPED\n    BlankAgent: ?agent = false\n\n    var SeekInitialTransform : transform = transform{}\n    # var CutsceneCameraHolderInitialTransform : transform = transform{}\n    var SpawnVFXInitialTransform : transform = transform{}\n    var BGVFXInitialTransform : transform = transform{}\n    ExternalDevicesUpdateRateSeconds: float = 0.1\n    var ExternalDevicesInitialPosition: transform = transform{}\n\n    AllKillMessages: []string = array {\n        # \"I CAUGHT YOU\",\n        # \"EYES AHEAD\",\n        # \"RUN\"\n        \"You have met Hunter.\\n\\nRun.\"\n    }\n\n    # Runs when the device is started in a running game\n    OnBegin<override>()<suspends>:void=\n        Setup()\n        SubscribeToPlayerEvent(NewPlayerEvent, \"chase_manager\")\n\n        set SeekInitialTransform = SeekProp.GetTransform()\n        # set CutsceneCameraHolderInitialTransform = CutsceneCameraHolder.GetTransform()\n        set SpawnVFXInitialTransform = SpawnVFX.GetTransform()\n        # set BGVFXInitialTransform = BGVFX.GetTransform()\n        set ExternalDevicesInitialPosition = ExternalDevicesRoot.GetTransform()\n\n        ChaseEndVolume.AgentEntersEvent.Subscribe(ChaseEndEntered)\n\n        UpdateChaseRoom(0)\n        ToggleChaseRoomDeathVolumes(true)\n        SetupRoomsDeathsAnalytics()\n\n        Print(\"OnBeginEvent\")\n\n    StartChase<public>(NewPlayer: ?player, NewPlayerData: player_data, NewSpawnTransformProp: creative_prop): void =\n        set CurrentPlayer = NewPlayer\n        set CurrentPlayerData = NewPlayerData\n        set SeekSpawnTransformProp = NewSpawnTransformProp\n        # set ChaseActive = true\n        set ChaseState = CHASE_STATE.CHASE_STARTED\n        if:\n            NewPlayerCharacter := CurrentPlayer?.GetFortCharacter[]\n            set CurrentPlayerCharacter = option{NewPlayerCharacter}\n        then:\n            spawn{PlayStartCutscene()}\n        else:\n            # set ChaseActive = false\n            set ChaseState = CHASE_STATE.CHASE_STOPPED\n\n    StickExternalDevicesToNPC()<suspends>: void =\n        loop:\n            # if(not ChaseActive?):\n            if(ChaseState <> CHASE_STATE.CHASE_STARTED):\n                break\n\n            ExternalDevicesRoot.MoveTo(SeekProp.GetTransform(), ExternalDevicesUpdateRateSeconds)\n            # Print(\"StickExternalDevicesToNPC: {SeekProp.GetTransform().Translation}\")\n            Sleep(ExternalDevicesUpdateRateSeconds)\n\n    MoveToSpawnTransform<public>(): logic =\n        SpawnTransform := SeekSpawnTransformProp.GetTransform()\n        if:\n            SeekProp.TeleportTo[SpawnTransform.Translation, SpawnTransform.Rotation]\n            # SpawnVFX.TeleportTo[SpawnTransform.Translation, SpawnTransform.Rotation]\n        then:\n            return true\n        else:\n            Print(\"SEEK: Move FAILED to spawn location: {SpawnTransform.Translation}\")\n            return false\n\n    PlayStartCutscene()<suspends>: void =\n        var CutsceneSuccessful : logic = false\n        ToggleChaseEndVolume(true)\n        if(Player := CurrentPlayer?, PlayerCharacter := CurrentPlayerCharacter?):\n            \n            MoveCameraSuccessful := CurrentPlayerData.CameraManager.MoveCameraFromPlayerToTarget(ChaseIntroCameraLocationProp.GetTransform(), 2.0)\n            if(MoveCameraSuccessful?):\n                # ChaseMusic.Enable()\n                ChaseMusic.Play()\n                \n                SpawnTransform := SeekSpawnTransformProp.GetTransform()\n                SpawnVFXLocation := SpawnTransform.Translation + (SpawnTransform.Rotation.GetLocalUp() * SeekPropHalfHeight) + (SpawnTransform.Rotation.GetLocalForward() * 300.0)\n\n                SpawnVFX.Disable()\n                BGVFX.Disable()\n                 \n                # if:\n                    # 4. Move the spawn VFX to spawn location\n                    SpawnVFX.MoveTo(SpawnVFXLocation, SpawnTransform.Rotation, 0.1)\n                # else:\n                    # Print(\"SEEK: spawn VFX teleport failed\")\n                # BGVFXLocation := SpawnVFXLocation + (SpawnTransform.Rotation.GetLocalForward() * -BGDistanceFromSeekProp)\n                # # if:\n                # BGVFX.MoveTo(BGVFXLocation, SpawnTransform.Rotation, 0.1)\n                # else:\n                #     Print(\"SEEK: bg VFX teleport failed\")\n                \n                if:\n                    SpawnVFX.TeleportTo[SpawnVFX.GetTransform().Translation, SpawnVFX.GetTransform().Rotation]\n                \n                # 5. Start the spawn VFX\n                SpawnVFX.Enable()\n                SpawnVFX.Restart()\n\n                Sleep(1.0)\n                # 6. Move Seek prop to spawn location (engulfed by the spawn VFX)\n                MoveSeekPropSuccessful := MoveToSpawnTransform()\n                if(MoveSeekPropSuccessful?):\n                    spawn{StickExternalDevicesToNPC()}\n                    Sleep(1.0)\n                    if:\n                        BGVFX.TeleportTo[BGVFX.GetTransform().Translation, BGVFX.GetTransform().Rotation]\n\n                    # Print(\"BGVFX: {BGVFX.GetTransform().Translation}\")\n\n                    BGVFX.Enable()\n                    BGVFX.Restart()\n\n                    # CameraTargetLocation := SpawnTransform.Translation + (SpawnTransform.Rotation.GetLocalForward() * 1000.0) + (SpawnTransform.Rotation.GetLocalUp() * SeekPropHalfHeight)\n                    # CameraTargetTransform := transform{ Translation := CameraTargetLocation, Rotation := SpawnTransform.Rotation }\n                    # CameraTargetRotation := CameraTargetTransform.Rotation.ApplyLocalRotationZ(DegreesToRadians(180.0))\n\n                    Print(\"SEEK: Everything in place, ready for sequence\")\n                    \n                    # 8. Move the Seek prop out of the spawn VFX for some distance, and the cutscene camera too to match.\n                    StartChaseDistance := 1000.0\n                    StartChaseTime := 2.0\n                    StartChaseVector := SpawnTransform.Rotation.GetLocalForward() * StartChaseDistance\n                    StartChaseSeekLocation := SpawnTransform.Translation + StartChaseVector\n                    # StartChaseCameraLocation := CameraTargetLocation + StartChaseVector\n                    StartChaseCameraTransform := ChaseStartCameraLocationProp.GetTransform()\n\n                    sync:\n                        MoveSeek(StartChaseSeekLocation, SpawnTransform.Rotation, StartChaseTime)\n                        # CutsceneCameraHolder.MoveTo(StartChaseCameraLocation, CutsceneCameraHolder.GetTransform().Rotation, StartChaseTime)\n                        # CutsceneCameraHolder.MoveTo(StartChaseCameraTransform.Translation, StartChaseCameraTransform.Rotation, StartChaseTime)\n                        CurrentPlayerData.CameraManager.MoveCameraToTarget(StartChaseCameraTransform, StartChaseTime)\n\n                    # 9. Move the camera back to player\n                    CurrentPlayerData.CameraManager.MoveCameraBackToPlayer()\n                    ChaseCamera.AddTo(Player)\n\n                    set CutsceneSuccessful = true\n                    ChasePlayer()\n            else:\n                Print(\"SEEK: MoveCameraSuccessful fail\")\n\n        if(not CutsceneSuccessful?):\n            Print(\"SEEK: PlayStartCutscene failed\")\n            CurrentPlayerData.CameraManager.MoveCameraBackToPlayer()\n            ResetChase()\n            \n        SpawnVFX.Disable()\n        \n\n    MoveSeek(TargetLocation: vector3, TargetRotation: rotation, OverTime: float)<suspends>: void =\n        # BGVFXLocation := TargetLocation + (TargetRotation.GetLocalForward() * -BGDistanceFromSeekProp) + (TargetRotation.GetLocalUp() * SeekPropHalfHeight)\n        # sync:\n            SeekProp.MoveTo(TargetLocation, TargetRotation, OverTime)\n            # BGVFX.MoveTo(BGVFXLocation, TargetRotation, OverTime)\n            # ExternalDevicesRoot.MoveTo(TargetLocation, TargetRotation, OverTime)\n\n    CalculateSeekSpeed(SeekTransform : transform, PlayerTransform : transform) : float=\n        SeekLoc : vector3 = SeekTransform.Translation\n        PlayerLoc : vector3 = PlayerTransform.Translation\n        Dist : float = DistanceXY(SeekLoc, PlayerLoc) / 100.0 # converting to meters\n\n        return CalculateTime(SeekSpeed, Dist)\n\n    ChasePlayer()<suspends>: void =\n        if(Player := CurrentPlayer?, PlayerCharacter := CurrentPlayerCharacter?):\n            loop:\n                # if(not ChaseActive?):\n                if(ChaseState <> CHASE_STATE.CHASE_STARTED):\n                    break\n\n                # BGVFX.Restart()\n                PlayerTransform := PlayerCharacter.GetTransform()\n                var SeekTime : float = CalculateSeekSpeed(SeekProp.GetTransform(), PlayerTransform)\n                SeekMoveRotation := FindLookAtYawRotation(SeekProp.GetTransform(), PlayerTransform)\n                if(SeekTime <= 0.0):\n                    set SeekTime = 0.01\n\n                race:\n                    MoveSeek(PlayerTransform.Translation, SeekMoveRotation, SeekTime)\n                    Sleep(0.1)\n                \n                DistToPlayer := Distance(SeekProp.GetTransform().Translation, PlayerTransform.Translation)\n                # Print(\"SEEK: DistToPlayer {DistToPlayer}\")\n                # if(DistToPlayer <= 100.0 and ChaseActive?):\n                if(DistToPlayer <= 100.0 and ChaseState = CHASE_STATE.CHASE_STARTED):\n                    PlayerKill()\n        return\n\n    ChaseEndEntered(Agent : agent): void =\n        ChaseCamera.RemoveFrom(Agent)\n        spawn{PlayEndCutscene(Agent)}\n\n    PlayEndCutscene(Agent : agent)<suspends>: void =\n        # set ChaseActive = false\n        set ChaseState = CHASE_STATE.CHASE_STOPPING\n        ToggleChaseEndVolume(false)\n\n        ChaseMusic.Stop()\n        # ChaseMusic.Disable()\n\n        # ChaseEndMusic.Enable()\n        ChaseEndMusic.Play()\n\n        MoveSuccessful := CurrentPlayerData.CameraManager.MoveCameraFromPlayerToTarget(ChaseEndCameraLocationProp.GetTransform(), 2.0)\n        if(MoveSuccessful?):\n            EndDoorLockDevice.Close(Agent)\n            EndDoorLockDevice.Lock(Agent)\n            ResetEverythingBack()\n            CurrentPlayerData.CameraManager.MoveCameraBackToPlayer()\n            \n            GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_SURVIVED_ENTITY, event_player_survived_entity{EntityType := entity_type.SEEK}, false)\n\n    PlayerDeathCutsceneViewFullTransform(): transform = \n        return PlayerDeathCutsceneView.GetTransform()\n\n    PlayerDeathCutsceneViewOnlyRotation(): transform =\n        # just rotate player to look at the entity\n        if(PlayerCharacter := CurrentPlayerCharacter?):\n            # CutsceneViewLocation := PlayerCharacter.GetTransform().Translation\n            # CutsceneViewRotation := PlayerDeathCutsceneView.GetTransform().Rotation\n            # return transform { Translation := CutsceneViewLocation, Rotation := CutsceneViewRotation}\n\n            CutsceneViewLocation := PlayerCharacter.GetTransform().Translation\n            EntityLookAtRotation := FindLookAtRotation(PlayerCharacter.GetTransform(), PlayerDeathCutsceneView.GetTransform())\n            # CutsceneViewRotation := PlayerDeathCutsceneView.GetTransform().Rotation\n            return transform { Translation := CutsceneViewLocation, Rotation := EntityLookAtRotation}\n\n        return PlayerDeathCutsceneView.GetTransform()\n\n    PlayerKill(): void =\n        if(PlayerCharacter := CurrentPlayerCharacter?):\n            Print(\"SEEK: Player kill!\")\n            KillMessage := GetKillMessage()\n            # ResetChase()\n            # set ChaseActive = false\n            set ChaseState = CHASE_STATE.CHASE_STOPPING\n            ChaseMusic.Stop()\n\n            CurrentPlayerData.PlayerEliminateByEntity(PlayerDeathCutsceneViewFullTransform(), option{KillMessage})\n\n            if:\n                APlayer := CurrentPlayer?\n            then:\n                PlayerDeathAnalyticsDevice.Submit(APlayer)\n            # PlayerCharacter.Damage(PlayerCharacter.GetHealth())\n            # SendPlayerKilledMessage()\n\n    GetKillMessage(): string = \n        var KillMessage : string = \"dummy kill message\"\n        MessageIndex := GetRandomInt(0, AllKillMessages.Length - 1)\n        if(NewKillMessage := AllKillMessages[MessageIndex]):\n            set KillMessage = NewKillMessage\n        return KillMessage\n\n    EndChase(): void =\n        return\n\n    ResetChase(): void =\n        Print(\"Resetting chase\")\n        if:\n            APlayer := CurrentPlayer?\n        then:\n            EndDoorLockDevice.Unlock(APlayer)\n            EndDoorLockDevice.Open(APlayer)\n        # set ChaseActive = false\n        set ChaseState = CHASE_STATE.CHASE_STOPPED\n        ChaseMusic.Stop()\n        ResetEverythingBack()\n\n        UpdateChaseRoom(0)\n        ToggleChaseRoomDeathVolumes(true)\n\n    ResetVFX(): void =\n        SpawnVFX.Disable()\n        BGVFX.Disable()\n            \n    ResetEverythingBack(): void =\n        Print(\"SEEK: SendEverythingBack\")\n        option{SeekProp.TeleportTo[SeekInitialTransform]}\n        # option{CutsceneCameraHolder.TeleportTo[CutsceneCameraHolderInitialTransform]}\n        option{SpawnVFX.TeleportTo[SpawnVFXInitialTransform]}\n        # option{BGVFX.TeleportTo[BGVFXInitialTransform]}\n        option{ExternalDevicesRoot.TeleportTo[ExternalDevicesInitialPosition]}\n\n        ResetVFX()\n    \n    ToggleChaseEndVolume(Active: logic): void =\n        # PrintRoom(\"ToggleChaseEndVolume {Active.ToString()}\")\n        if(Active?):\n            ChaseEndVolume.Enable()\n        else:\n            ChaseEndVolume.Disable()\n\n    NewPlayerEvent(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        case (EventName):\n            event_names.PLAYER_START_RUN =>\n            event_names.PLAYER_END_RUN =>\n                ResetChase()\n            event_names.PLAYER_ELIMINATED =>\n                if:\n                    APlayer := CurrentPlayer?\n                then:\n                    if(ChaseRoomDeathAnalytics := ChaseRoomsDeathsAnalytics[ChaseRoomsProgress]):\n                        Print(\"SEEK: death analytics for room index {ChaseRoomsProgress}\")\n                        ChaseRoomDeathAnalytics.RoomDeathAnalyticsDevice.Submit(APlayer)\n                # if(ChaseActive?):\n                if(ChaseState <> CHASE_STATE.CHASE_STOPPED):\n                    ResetChase()\n            _ =>\n                return\n        \n    SetupRoomsDeathsAnalytics(): void =\n        set ChaseRoomsProgress = 0\n        for(Index -> Data : ChaseRoomsDeathsAnalytics):\n            RoomEnterHandler := room_enter_handler{\n                RoomIndex := Index\n                RoomEnterVolume := Data.RoomEnterVolume\n                UpdateChaseRoomFunction := UpdateChaseRoom\n            }            \n            Data.RoomEnterVolume.AgentEntersEvent.Subscribe(RoomEnterHandler.OnEnter)\n\n    ToggleChaseRoomDeathVolumes(Active: logic): void =\n        for(Data : ChaseRoomsDeathsAnalytics):\n            if(Active?):\n                Data.RoomEnterVolume.Enable()\n            else:\n                Data.RoomEnterVolume.Disable()\n\n    UpdateChaseRoom(NewRoomIndex: int): void =\n        Print(\"SEEK: UpdateChaseRoom to {NewRoomIndex}\")\n        set ChaseRoomsProgress = NewRoomIndex\n\n    ",
    "external_calls": [
      "event_communicator_device",
      "mutator_zone_device",
      "analytics_device",
      "agent",
      "gameplay_camera_first_person_device",
      "creative_prop",
      "cinematic_sequence_device",
      "vfx_spawner_device",
      "audio_player_device",
      "lock_device",
      "player",
      "fort_character",
      "player_data",
      "transform",
      "vector3",
      "rotation",
      "event_names",
      "event_data",
      "event_player_survived_entity",
      "entity_type",
      "int_function_type",
      "CHASE_STATE",
      "chase_room_death_analytics",
      "room_enter_handler",
      "DistanceXY",
      "Distance",
      "CalculateTime",
      "FindLookAtYawRotation",
      "FindLookAtRotation",
      "GetRandomInt",
      "Print",
      "Sleep"
    ]
  }
] 