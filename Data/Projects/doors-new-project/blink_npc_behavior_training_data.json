[
  {
    "file_name": "blink_npc_behavior.verse",
    "questions": [
      "How can I create a blinking NPC behavior that teleports around the player with visibility mechanics in Verse?",
      "What is the Verse code for implementing a horror game entity called 'BLINK' that uses hit-based elimination system?",
      "I need a script that handles a teleporting enemy with timed visibility and strategic positioning around the player.",
      "How do I create an NPC behavior with random teleportation, visibility toggling, and multiple hit mechanics?"
    ],
    "explanation": "This script provides a specialized blink NPC behavior for a horror game entity called 'BLINK', extending the basic_enemy_npc_behaviour class with unique teleportation mechanics, visibility control, and hit-based elimination system. The entity teleports around the player, becomes visible during attacks, and can be eliminated by looking at it for a specific duration.\n\n**Core Components:**\n- blink_npc_behavior: Specialized NPC behavior extending basic_enemy_npc_behaviour\n- Teleportation system with strategic positioning around player\n- Visibility mechanics with show/hide functionality\n- Hit-based elimination system with configurable hit count\n- Timed observation mechanics for player defense\n- HOVER state for hiding integration\n- Random positioning algorithm with fallback systems\n\n**Key Features:**\n1. **Teleportation System**: Strategic positioning around player using directional vectors\n2. **Visibility Control**: Dynamic show/hide mechanics during different phases\n3. **Hit-Based Elimination**: Configurable hit count system (default 1 hit)\n4. **Timed Observation**: Player can eliminate by looking for specified duration\n5. **Random Positioning**: Multi-vector placement with distance fallback\n6. **Audio Coordination**: Chase and hide audio states\n7. **HOVER State**: Special state for player hiding scenarios\n8. **Damage System**: Continuous damage during chase phase\n\n**Inheritance Architecture:**\n- **Extends basic_enemy_npc_behaviour**: Inherits all base AI functionality\n- **Selective Overrides**: Customizes chase, positioning, and detection behaviors\n- **State Machine Extension**: Adds HOVER state for hiding mechanics\n- **Data Integration**: Works with blink_data for specialized configuration\n\n**Teleportation System:**\n- **PlaceNPCAtAvailablePointAroundPlayer()**: Strategic positioning algorithm\n- **Multi-Vector Placement**: Forward, 45-degree angles for optimal positioning\n- **Distance Fallback**: Reduces distance if placement fails\n- **Retry Mechanism**: Multiple attempts with different parameters\n- **Collision Detection**: TeleportTo() with validation\n\n**Visibility Mechanics:**\n- **ToggleVisibility()**: Dynamic show/hide control\n- **IsVisible**: State tracking for visibility status\n- **NPCCharacter.Show()**: Makes entity visible\n- **NPCCharacter.Hide()**: Makes entity invisible\n- **Strategic Timing**: Coordinates with attack and retreat phases\n\n**Hit-Based Elimination:**\n- **RemainingHits**: Configurable hit count (default from blink_data)\n- **CheckVisibleAndSeen()**: Observation-based hit detection\n- **Hit Reduction**: Decrements hit count when observed\n- **Elimination Trigger**: EliminateNPC() when hits reach zero\n- **VFX Integration**: Hit and elimination effects\n\n**Observation Mechanics:**\n- **SecondsToLookAt**: Configurable observation duration (default 1.0 seconds)\n- **PlayerLookingAtMe**: Tracks player observation status\n- **OnNPCSeenByPlayer()**: Triggers observation timer\n- **OnNPCLostByPlayer()**: Cancels observation timer\n- **Race Condition**: Timer vs. player looking away\n\n**State Machine Extension:**\n- **IDLE State**: Waiting phase before teleportation\n- **CHASE State**: Active teleportation and attack phase\n- **HOVER State**: Special state when player is hiding\n- **WaitInIdle()**: Transition delay from idle to chase\n- **DoAHover()**: Hiding response behavior\n\n**Strategic Positioning Algorithm:**\n- **PlayerForwardVector**: Player's facing direction\n- **PlayerRightVector**: Player's right direction\n- **Player45Vector**: Diagonal positioning (forward + right)\n- **PlayerMinus45Vector**: Diagonal positioning (forward - right)\n- **MaxDistanceToPlayer**: 500.0 unit maximum range\n- **Distance Calculation**: Current distance consideration\n\n**Placement Logic:**\n- **Vector Array**: Multiple directional options for placement\n- **Random Selection**: GetRandomInt() for unpredictable positioning\n- **Collision Testing**: TeleportTo() validation\n- **Fallback System**: Distance reduction and retry attempts\n- **Elimination Fallback**: Destroys NPC if placement fails completely\n\n**Audio Management:**\n- **ChaseSFX**: NPCAudioDevices[0] for attack audio\n- **HideSFX**: NPCAudioDevices[1] for retreat audio\n- **Context-Aware**: Audio matches behavior phase\n- **State Synchronized**: Audio coordinated with visibility\n\n**Chase Override:**\n- **DoAChase()**: Complete override of parent chase behavior\n- **Teleportation First**: Positioning before attack\n- **Visibility Sequence**: Hide → Teleport → Show → Attack\n- **Synchronized Actions**: Movement, audio, and damage coordination\n- **Navigation Override**: Replaces traditional pathfinding\n\n**Damage System:**\n- **DoPlayerSmallDamage()**: Continuous damage during chase\n- **DoPlayerDamage()**: Inherited elimination damage\n- **Damage Timing**: 2-second intervals during chase\n- **Damage Coordination**: Synchronized with movement\n\n**Player Detection Override:**\n- **OnPlayerSeen()**: Disabled to prevent traditional AI\n- **OnPlayerLost()**: Disabled to prevent traditional AI\n- **Custom Detection**: Uses visibility-based observation system\n- **Event-Driven**: PlayerStartedLookingEvent and PlayerStoppedLookingEvent\n\n**Hiding Integration:**\n- **OnPlayerHidden()**: Triggers HOVER state\n- **DoAHover()**: Waits invisibly until player stops hiding\n- **PlayerStoppedHidingEvent**: Resumes chase when player exits hiding\n- **State Preservation**: Maintains invisibility during hover\n\n**Data Integration:**\n- **SetupNPC()**: Configures blink-specific parameters\n- **blink_data**: External configuration for seconds and hit count\n- **SecondsToLookAt**: Configurable observation duration\n- **NumberOfHits**: Configurable elimination threshold\n\n**Race Condition Management:**\n- **CheckVisibleAndSeen()**: Concurrent observation timer\n- **PlayerStoppedLookingEvent**: Event-driven observation cancellation\n- **Synchronized Actions**: Proper coordination of concurrent operations\n- **Event Cleanup**: Proper handling of racing conditions\n\n**Technical Implementation:**\n- **Vector Mathematics**: Directional calculations for positioning\n- **Random Number Generation**: GetRandomInt() for unpredictable behavior\n- **Distance Calculations**: Spatial awareness for positioning\n- **Transform Manipulation**: Position and rotation management\n\n**Performance Considerations:**\n- **Efficient Teleportation**: Direct TeleportTo() calls\n- **Selective Audio**: Audio only during relevant phases\n- **Event-Based Updates**: Efficient observation state changes\n- **Fallback Systems**: Prevents infinite loops in placement\n\n**Gameplay Mechanics:**\n- **Unpredictable Positioning**: Creates tension through randomness\n- **Defensive Mechanics**: Player can eliminate by observation\n- **Risk/Reward**: Balances attack opportunity with vulnerability\n- **Strategic Timing**: Requires precise player reaction\n\n**Integration Points:**\n- **Player Hiding System**: Coordinates with stealth mechanics\n- **Audio System**: Dual audio states for different phases\n- **Damage System**: Integrates with player health management\n- **Event System**: Uses custom observation and hiding events\n\n**Positioning Strategy:**\n- **Forward Positioning**: Direct confrontation angles\n- **Diagonal Positioning**: Flanking approaches\n- **Distance Variation**: Adaptive range based on placement success\n- **Collision Avoidance**: Automatic retry with different parameters\n\n**Elimination Mechanics:**\n- **Hit-Based System**: Multiple observations required\n- **Timed Observation**: Specific duration requirement\n- **Visual Feedback**: Hit and elimination VFX integration\n- **Progressive Difficulty**: Configurable hit count for balancing\n\n**State Transitions:**\n- **IDLE → CHASE**: After 2-second delay\n- **CHASE → IDLE**: After successful attack or observation hit\n- **ANY → HOVER**: When player hides\n- **HOVER → CHASE**: When player stops hiding\n\n**Audio State Management:**\n- **Chase Phase**: ChaseSFX active during teleportation and attack\n- **Retreat Phase**: HideSFX active when becoming invisible\n- **Hover Phase**: All audio disabled\n- **Clean Transitions**: Proper audio start/stop coordination\n\n**Visibility Coordination:**\n- **Teleportation Phase**: Invisible during positioning\n- **Attack Phase**: Visible during chase and damage\n- **Observation Phase**: Visible for player defense opportunity\n- **Hiding Phase**: Invisible during player hiding\n\n**Use Cases:**\n- **Fast-Paced Horror**: Creates intense, quick encounters\n- **Skill-Based Defense**: Requires player reaction and observation\n- **Unpredictable Encounters**: Random positioning prevents pattern learning\n- **Balanced Gameplay**: Offensive threat with defensive opportunity\n\n**How It Works:**\n1. **Initialization**: SetupNPC() configures blink-specific parameters\n2. **Idle Phase**: WaitInIdle() provides 2-second preparation time\n3. **Teleportation**: PlaceNPCAtAvailablePointAroundPlayer() positions strategically\n4. **Attack Phase**: Becomes visible, plays audio, navigates to player\n5. **Damage Phase**: DoPlayerSmallDamage() applies continuous damage\n6. **Observation Window**: CheckVisibleAndSeen() allows player defense\n7. **Hit Processing**: Reduces hit count or eliminates based on observation\n8. **Retreat Phase**: Becomes invisible, plays hide audio, returns to idle\n\n**Behavioral Flow:**\n1. **Initial State**: NPC in IDLE, invisible, preparing for teleportation\n2. **Teleportation**: Strategically positions around player using vector math\n3. **Visibility**: Becomes visible and plays chase audio\n4. **Attack**: Navigates to player while applying damage\n5. **Observation Window**: Player can look at NPC to score hits\n6. **Hit Resolution**: Either hit scored or attack completes\n7. **Retreat**: Becomes invisible, plays hide audio\n8. **Cycle Repeat**: Returns to IDLE for next teleportation\n\n**Strategic Gameplay:**\n- **Positioning Awareness**: Players must be ready for multi-directional attacks\n- **Reaction Time**: Quick observation required during visibility window\n- **Hit Management**: Multiple hits required for elimination\n- **Audio Cues**: Sound provides warning and feedback\n\n**Technical Advantages:**\n- **Efficient Teleportation**: Direct positioning without pathfinding\n- **Flexible Configuration**: Adjustable timing and hit counts\n- **Event-Driven**: Responsive to player actions\n- **Fallback Systems**: Robust error handling\n\n**Comparison with Traditional AI:**\n- **No Pathfinding**: Direct teleportation instead of navigation\n- **Visibility-Based**: Show/hide mechanics instead of always-visible\n- **Hit-Based**: Elimination through observation instead of damage\n- **Event-Driven**: Player observation events instead of proximity detection\n\n**Development Benefits:**\n- **Configurable Parameters**: Easy balancing through blink_data\n- **Modular Design**: Clear separation of teleportation, visibility, and combat\n- **Robust Placement**: Multiple fallback systems prevent failures\n- **Event Integration**: Proper event system usage for responsive gameplay",
    "code": "using { /Fortnite.com/AI }\nusing { /Fortnite.com/Devices }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /Verse.org/Simulation }\nusing { /Verse.org/Simulation/Tags }\nusing { /Fortnite.com/Characters }\nusing { /Verse.org/Random }\nusing { Entities }\n\n# A Verse-authored NPC Behavior that can be used within an NPC Character Definition or an NPC Spawner device's NPC Behavior Script Override.\nblink_npc_behavior := class(basic_enemy_npc_behaviour):\n\n    var IsVisible: logic = false\n    var PlayerLookingAtMe: logic = false\n    var EntityName<override>: string = \"BLINK\"\n    var SecondsToLookAt: float = 1.0\n    var RemainingHits: int = 1\n\n    SetupNPC<override>(NPCData: entity_data): void =\n        SetupNPCBase(NPCData)\n        if(NPCBlinkData := blink_data[NPCData]):\n            set SecondsToLookAt = NPCBlinkData.SecondsToLookAt\n            set RemainingHits = NPCBlinkData.NumberOfHits\n\n    MoveToSpawnTransform<override>(): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            if(NPCBlinkData := blink_data[NPCEntityData]):\n                if(ReceivedPlayer := NPCBlinkData.Player?, ReceivedPlayerCharacter := ReceivedPlayer.GetFortCharacter[]):\n                    set SeenPlayerCharacter = option{ReceivedPlayerCharacter}\n                    PrintNPC(\"Player found {ReceivedPlayerCharacter.GetTransform().Translation}\")\n                    # PlaceNPCAtAvailablePointAroundPlayer()\n                else:\n                    PrintNPC(\"no player....\")\n\n    StartNPCBehaviour<override>(): void =\n        MoveToSpawnTransform()\n        for(AudioDevices : NPCAudioDevices):\n            AudioDevices.Enable()\n\n        spawn{RunNPCStateMachine()}\n\n    ResetNPC<override>(): void =\n        (super:)ResetNPC()\n        set IsVisible = false\n        set PlayerLookingAtMe = false\n        set RemainingHits = 3\n        set SecondsToLookAt = 1.0\n\n    RunNPCStateMachine<override>()<suspends>: void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n            NPCFocus := NPCCharacter.GetFocusInterface[]\n            NPCNavigatable := NPCCharacter.GetNavigatable[]\n        then:\n            loop:\n                if(not NPCCharacter.IsActive[] or IsPlayerDead[]):\n                    PrintNPC(\"break state machine loop\")\n                    break\n                \n                case (CurrentNPCBehaviourState):\n                    NPC_BEHAVIOUR_STATE.IDLE =>\n                        WaitInIdle()\n                    NPC_BEHAVIOUR_STATE.CHASE =>\n                        DoAChase(NPCAgent, NPCCharacter, NPCFocus, NPCNavigatable)\n                    NPC_BEHAVIOUR_STATE.HOVER =>\n                        DoAHover()\n                    _ => # default\n                        PrintNPC(\"How RunNPCStateMachine reached here?\")\n                        break\n                \n                Sleep(0.1)\n\n    OnPlayerSeen<override>(Agent: agent): void =\n        # (super:)OnPlayerSeen(Agent)\n        return\n\n    OnPlayerLost<override>(Agent: agent): void =\n        # (super:)OnPlayerLost(Agent)\n        return\n\n    OnNPCSeenByPlayer<override>(Agent: agent): void =\n        if(not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            PlayerStartedLookingEvent.Signal()\n            PrintNPC(\"Player seeing ME\")\n            set PlayerLookingAtMe = true\n            spawn{CheckVisibleAndSeen()}\n\n    OnNPCLostByPlayer<override>(Agent: agent): void =\n        if(not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            PlayerStoppedLookingEvent.Signal()\n            PrintNPC(\"Player not seeing, chase resume\")\n            set PlayerLookingAtMe = false\n\n    WaitInIdle()<suspends>: void =\n        PrintNPC(\"Waiting in idling\")\n        Sleep(2.0)\n        StartChasing()\n\n    DoAHover()<suspends>: void =\n        # when the player is hidden (in a cupboard etc.) just stay where you are, pause all movement, stay invisible and wait for the player to stop hiding.\n        PrintNPC(\"DoAHover\")\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n            NPCNavigatable := NPCCharacter.GetNavigatable[]\n        then:\n            # set IsPlayerSeen = false\n            NPCNavigatable.StopNavigation()\n            ToggleVisibility(false)\n            PlayerStoppedHidingEvent.Await()\n            StartChasing()\n\n    PlaceNPCAtAvailablePointAroundPlayer(): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n\n            ChasingPlayerCharacter := SeenPlayerCharacter?\n        then:\n            PlayerForwardVector := ChasingPlayerCharacter.GetTransform().Rotation.GetLocalForward()\n            PlayerRightVector := ChasingPlayerCharacter.GetTransform().Rotation.GetLocalRight()\n\n            if:\n                Player45Vector := (PlayerForwardVector + PlayerRightVector).MakeUnitVector[]\n                PlayerMinus45Vector := (PlayerForwardVector - PlayerRightVector).MakeUnitVector[]\n            then:\n                PlayerAllVectors := array{\n                    PlayerForwardVector,            # Player's forward direction\n                    # -PlayerForwardVector,         # Player's behind direction\n                    # PlayerRightVector,              # Player's right direction\n                    # -PlayerRightVector,             # Player's left direction\n                    Player45Vector,                 # Direction between forward and right \n                    # -Player45Vector,              # Direction between behind and left\n                    PlayerMinus45Vector             # Direction between forward and left\n                    # -PlayerMinus45Vector          # Direction between behind and right\n                }\n\n                MaxDistanceToPlayer := 500.0\n                CurrentDistanceToPlayer := Distance(ChasingPlayerCharacter.GetTransform().Translation, NPCCharacter.GetTransform().Translation)\n\n                var TestDistanceToPlayer : float = Min(MaxDistanceToPlayer, CurrentDistanceToPlayer)\n                PlayerLocation := ChasingPlayerCharacter.GetTransform().Translation\n                var NPCPlaced: logic = false\n                var PlacingAttempts: int = 5\n                loop:\n                    if(PlacingAttempts > 0):\n                        # PrintNPC(\"Next placing attempt. Attempts left {PlacingAttempts}\")\n                        if(not NPCPlaced?):\n                            PlayerTestAllVectors := PlayerAllVectors\n                            # PrintNPC(\"Checking across {PlayerTestAllVectors.Length} vectors\")\n                            loop:\n                                if(NPCPlaced?):\n                                    PrintNPC(\"Placed!\")\n                                    break\n\n                                RandomVectorIndex := GetRandomInt(0, PlayerTestAllVectors.Length)\n                                if(RandomVector := PlayerTestAllVectors[RandomVectorIndex].MakeUnitVector[]):\n                                    RandomLocation := PlayerLocation + (RandomVector * TestDistanceToPlayer)\n                                    if(NPCCharacter.TeleportTo[RandomLocation, IdentityRotation()]):\n                                        set NPCPlaced = true\n                                        # play sfx at RandomLocation\n                                    else:\n                                        if:\n                                            PlayerTestAllVectors.RemoveElement[RandomVectorIndex]\n                                        else:\n                                            break\n\n                            set PlacingAttempts -= 1\n                            set TestDistanceToPlayer -= 50.0\n                        else:\n                            break\n                    else:\n                        PrintNPC(\"Could not place anywhere! Destroying...\")\n                        EliminateNPC()\n                        break\n                    \n\n    DoAChase<override>(NPCAgent: agent, NPCCharacter: fort_character, NPCFocus: focus_interface, NPCNavigatable: navigatable)<suspends>: void =\n        if(not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            NPCNavigatable.StopNavigation()\n\n            ToggleVisibility(false)\n            PlaceNPCAtAvailablePointAroundPlayer()\n\n            if(ChasingPlayerCharacter := SeenPlayerCharacter?, PlayerAgent := ChasingPlayerCharacter.GetAgent[]):\n                PrintNPC(\"Basic: Player pursuit!\")\n                PlayerNavigationTarget := MakeNavigationTarget(PlayerAgent)\n                # race:\n                sync:\n                    block:\n                        PrintNPC(\"Move, show yourself\")\n                        StopPlayingAllAudio()\n                        if(ChaseSFX := NPCAudioDevices[0]):\n                            ChaseSFX.Play()\n\n                        ToggleVisibility(true)\n                        NPCNavResult := NPCNavigatable.NavigateTo(PlayerNavigationTarget, ?MovementType := movement_types.Running, ?ReachRadius := 10.0, ?AllowPartialPath := true)\n                        PrintNavigationResult(NPCNavResult, \"Pursuit\")\n                        if(NPCNavResult = navigation_result.Reached):\n                            if(ChasingPlayerCharacter.IsActive[]):\n                                PrintNPC(\"Player reached!\")\n                                DoPlayerDamage(ChasingPlayerCharacter)\n                        else:\n                            StopChasing()\n                    block:\n                        DoPlayerSmallDamage(ChasingPlayerCharacter)\n                        Sleep(2.0)\n                    # block:\n                    #     Sleep(SecondsToLookAt)\n                    #     PrintNPC(\"Enough, hide now\")\n                    #     StopChasing()\n\n    DoPlayerSmallDamage(PlayerCharacter: fort_character): void =\n        PrintNPC(\"Player small damage!\")\n        PlayerCharacter.Damage(NPCEntityData.Damage)\n\n    \n    StopChasing<override>(): void =\n        if(not IsPlayerDead[]):\n            PrintNPC(\"Stop chasing\")\n            if:\n                NPCAgent := GetAgent[]\n                NPCCharacter := NPCAgent.GetFortCharacter[]\n                NPCNavigatable := NPCCharacter.GetNavigatable[]\n            then:\n                StopPlayingAllAudio()\n                if(HideSFX := NPCAudioDevices[1]):\n                    HideSFX.Play()\n                # set IsPlayerSeen = false\n                NPCNavigatable.StopNavigation()\n                ToggleVisibility(false)\n                SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.IDLE)\n\n    ToggleVisibility(NewVisibility: logic): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            set IsVisible = NewVisibility\n            if(IsVisible?):\n                NPCCharacter.Show()\n                # spawn{CheckVisibleAndSeen()}\n            else:\n                NPCCharacter.Hide()\n\n    CheckVisibleAndSeen()<suspends>: void =\n        race:\n            block:\n                Sleep(SecondsToLookAt)\n                if(IsVisible? and PlayerLookingAtMe?):\n                    if(RemainingHits > 1):\n                        PrintNPC(\"Uh oh, take a hit!\")\n                        # hit VFX\n                        set RemainingHits -= 1\n                        StopChasing()\n                    else:\n                        # eliminate VFX\n                        EliminateNPC()\n            block:\n                PlayerStoppedLookingEvent.Await()\n\n    # GetNextNPCBehaviourState<override>(): NPC_BEHAVIOUR_STATE =\n    #     var NextNPCBehaviourState: NPC_BEHAVIOUR_STATE = NPC_BEHAVIOUR_STATE.IDLE\n\n    #     case (CurrentNPCBehaviourState):\n    #         NPC_BEHAVIOUR_STATE.CHASE => \n    #             set NextNPCBehaviourState = NPC_BEHAVIOUR_STATE.IDLE\n    #         NPC_BEHAVIOUR_STATE.IDLE =>\n    #             set NextNPCBehaviourState = NPC_BEHAVIOUR_STATE.CHASE\n    #         _ => # default\n    #             PrintNPC(\"How GetNextNPCBehaviourState reached here?\")\n                \n    #     return NextNPCBehaviourState\n                \n    OnPlayerHidden<override>(EventHideSuccessData: event_player_hide_success): void =\n        (super:)OnPlayerHidden(EventHideSuccessData)\n        SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.HOVER)\n\n    # OnPlayerUnhidden<override>(): void =\n    #     (super:)OnPlayerUnhidden()",
    "external_calls": [
      "basic_enemy_npc_behaviour",
      "entity_data",
      "blink_data",
      "agent",
      "fort_character",
      "focus_interface",
      "navigatable",
      "audio_player_device",
      "event_player_hide_success",
      "NPC_BEHAVIOUR_STATE",
      "PlayerStartedLookingEvent",
      "PlayerStoppedLookingEvent",
      "PlayerStoppedHidingEvent",
      "movement_types",
      "navigation_result",
      "GetRandomInt",
      "Distance",
      "Min",
      "MakeNavigationTarget",
      "IdentityRotation",
      "PrintNPC",
      "Sleep",
      "PrintNavigationResult"
    ]
  }
] 