[
  {
    "file_name": "persistence_manager.verse",
    "questions": [
      "How can I create a comprehensive persistence system for saving game progress and player data in Verse?",
      "What is the Verse code for managing persistent data structures with upgrades, vaults, and player progress?",
      "I need a script that handles game save data, room progress tracking, and upgrade systems with persistence.",
      "How do I create a persistence manager that saves player achievements, vault states, and game progression?"
    ],
    "explanation": "This script provides a comprehensive persistence system for a horror game, managing all aspects of player progress, game state, and persistent data across game sessions. It's the backbone of the game's save system, handling everything from first-time player experiences to complex upgrade and vault systems.\n\n**Core Components:**\n- game_persistent_data: Main persistable class containing all player progress and game state data\n- vault_data_persistent: Specialized persistence for vault systems with prop placement tracking\n- upgrade_data_persistent: Handles upgrade system progression and levels\n- persistence_manager: Main manager class coordinating all persistence operations\n\n**Key Features:**\n1. **Comprehensive Save System**: Tracks multiple aspects of player progress including room progression, side room exploration, vault states, and upgrade levels\n2. **Version Control**: Built-in versioning system to handle data structure changes over time\n3. **First-Time Experience Tracking**: Monitors first-time events for analytics and tutorial purposes\n4. **Room Progress Management**: Tracks maximum room reached and side room exploration for unlock conditions\n5. **Vault System Integration**: Saves vault unlock states and lobby prop placements\n6. **Upgrade System Support**: Manages upgrade levels and progression data\n7. **Coin Economy Persistence**: Tracks coin collection progress and counts\n8. **Analytics Integration**: Supports first-time event tracking for analytics systems\n\n**Data Structure Design:**\n- **game_persistent_data**: Main container with version control, progress tracking, and all game state\n- **vault_data_persistent**: Specialized for vault systems with unlock states and prop placement arrays\n- **upgrade_data_persistent**: Simple upgrade tracking with type and level information\n- **Global GameSaveData**: Weak map linking players to their persistent data\n\n**Persistence Operations:**\n1. **Data Retrieval**: GetGameSaveData() provides safe access to player's persistent data\n2. **Progress Updates**: Specialized update methods for different game systems\n3. **Safe Data Modification**: Uses constructor pattern to ensure data integrity\n4. **Logging System**: Comprehensive logging for debugging and monitoring\n\n**Update Methods:**\n- **UpdateSaveFirstTimeGameEntered()**: Tracks first game entry for analytics\n- **UpdateSaveReceptionEntered()**: Monitors reception area visits\n- **UpdateSaveMaxRoom()**: Updates maximum room progression\n- **UpdateSaveSideRoom()**: Tracks side room exploration\n- **UpdateFirstRunCompleted()**: Marks first run completion\n- **UpdateSaveUpgrades()**: Manages upgrade progression\n\n**Data Safety Features:**\n- Version control for handling data structure changes\n- Safe data access with fallback to defaults\n- Immutable update pattern using constructors\n- Comprehensive error logging and debugging support\n\n**Integration Points:**\n- Works with lobby_manager for vault and prop persistence\n- Integrates with room_manager for progress tracking\n- Supports analytics systems for first-time events\n- Coordinates with upgrade systems for progression\n\n**How It Works:**\n1. **Initialization**: Sets up player reference and initializes save data structure\n2. **Data Access**: Provides safe access to persistent data with fallback defaults\n3. **Progress Tracking**: Updates specific aspects of player progress through specialized methods\n4. **Data Integrity**: Uses constructor pattern to ensure consistent data updates\n5. **Debugging**: Comprehensive logging and data printing for development support\n6. **Session Management**: Maintains data across game sessions and handles player reconnection",
    "code": "using { /Fortnite.com/Devices }\nusing { /Fortnite.com/Characters }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\n\ngame_persistent_data := class<final><persistable>:\n    ## ----------------------------------------------------\n    ## DON'T FORGET TO UPDATE MakeGameSaveData() TOO\n    ## when you add a new variable here \n    ## ----------------------------------------------------\n\n    # used to force update when this data structure changes\n    Version: int = 1\n    # to track when player joined first time\n    FirstTimeGameEntered: logic = false\n    # to track when reception entered for only the first run\n    ReceptionEntered: logic = false\n    # to send room_entered analytics events for only the first run\n    MaxRoomIndexReached: int = -1\n    # to send side_room_entered analytics events for only the first run\n    SideRoomChecked: [int]logic = map{}\n    # to track when first run is done\n    FirstRunCompleted: logic = false\n    # which vaults in lobby are opened\n    LobbyVaults: [vault_type]vault_data_persistent = map{}\n    # coins collected in lobby\n    CoinCollectedCount : int = 0\n    # current upgrades level\n    Upgrades: [upgrade_type]upgrade_data_persistent = map{}\n\n    FastestRunYetSeconds: int = 9999 # ~2.7 hours\n\nvault_data_persistent := class<final><persistable>:\n    VaultType: vault_type = vault_type.NONE\n    IsUnlocked: logic = false\n    IsButtonEnabled: logic = false\n    LobbyPropsPlaced: []logic = array{}\n\nupgrade_data_persistent := class<final><persistable>:\n    UpgradeType: upgrade_type = upgrade_type.NONE\n    CurrentLevel: int = 0\n\nvar GameSaveData:weak_map(player, game_persistent_data) = map{}\n\nMakeGameSaveData<constructor>(OldData: game_persistent_data)<transacts> := game_persistent_data:\n    Version := OldData.Version\n    FirstTimeGameEntered := OldData.FirstTimeGameEntered\n    ReceptionEntered := OldData.ReceptionEntered\n    MaxRoomIndexReached := OldData.MaxRoomIndexReached\n    SideRoomChecked := OldData.SideRoomChecked\n    LobbyVaults := OldData.LobbyVaults\n    CoinCollectedCount := OldData.CoinCollectedCount\n    Upgrades := OldData.Upgrades\n    \npersistence_log := class(log_channel){}\npersistence_manager := class():\n    Logger : log = log{Channel := persistence_log}\n    var Player: ?player = false\n\n    GetGameSaveData()<decides><transacts>: game_persistent_data =\n        var SaveData: game_persistent_data = game_persistent_data{}\n        if:\n            APlayer := Player?\n            PlayerSaveData := GameSaveData[APlayer]\n            set SaveData = PlayerSaveData\n        return SaveData\n\n    # UpdateSaveVaultsData(NewVaultsData: [vault_type]vault_data_persistent): void = \n    #     if:\n    #         APlayer := Player?\n    #         PlayerSaveData := GetGameSaveData[]\n    #         set GameSaveData[APlayer] = game_persistent_data:\n    #             MakeGameSaveData<constructor>(PlayerSaveData)\n    #             LobbyVaults := NewVaultsData\n        \n    #         Logger.Print(\"UpdateSaveVaultsData success\")\n\n    UpdateSaveFirstTimeGameEntered(): void = \n        Logger.Print(\"UpdateSaveFirstTimeGameEntered attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                FirstTimeGameEntered := true\n        \n            Logger.Print(\"UpdateSaveFirstTimeGameEntered success\")\n\n    UpdateSaveReceptionEntered(): void = \n        Logger.Print(\"UpdateSaveReceptionEntered attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                ReceptionEntered := true\n        \n            Logger.Print(\"UpdateSaveReceptionEntered success\")\n    \n    UpdateSaveMaxRoom(NewRoomIndex: int): void = \n        Logger.Print(\"UpdateSaveMaxRoom attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                MaxRoomIndexReached := NewRoomIndex\n        \n            Logger.Print(\"UpdateSaveMaxRoom success\")\n        Logger.Print(\"UpdateSaveMaxRoom done\")\n\n    UpdateSaveSideRoom(NewSideRoomIndex: int): void = \n        Logger.Print(\"UpdateSaveSideRoom attempt\")\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            NewSideRoomKeyVal := map{NewSideRoomIndex => true}\n            NewSideRoomChecked := ConcatenateMaps(PlayerSaveData.SideRoomChecked, NewSideRoomKeyVal)\n\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                SideRoomChecked := NewSideRoomChecked\n        \n            Logger.Print(\"UpdateSaveSideRoom success\")\n        Logger.Print(\"UpdateSaveSideRoom done\")\n\n    UpdateFirstRunCompleted(): void = \n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n            set GameSaveData[APlayer] = game_persistent_data:\n                MakeGameSaveData<constructor>(PlayerSaveData)\n                FirstRunCompleted := true\n        \n            Logger.Print(\"UpdateFirstRunCompleted success\")\n\n    UpdateSaveUpgrades(NewUpgradeType: upgrade_type, NewUpgradeData: upgrade_data_persistent): void =\n        if:\n            APlayer := Player?\n            PlayerSaveData := GetGameSaveData[]\n        then:\n            var SavedUpgrades : [upgrade_type]upgrade_data_persistent = PlayerSaveData.Upgrades\n            if:\n                set SavedUpgrades[NewUpgradeType] = NewUpgradeData\n                set GameSaveData[APlayer] = game_persistent_data:\n                    MakeGameSaveData<constructor>(PlayerSaveData)\n                    Upgrades := SavedUpgrades\n\n                Logger.Print(\"UpdateSaveUpgrades success\")\n\n    InitializeGameSaveData(NewPlayer: ?player): void = # , VaultsData: []vault_data\n        set Player = NewPlayer\n        # if:\n        #     PlayerSaveData := GetGameSaveData[]\n        # then:\n        #     # check if save data has the correct number of vaults and lobby props. If not, add them.\n        #     CurrentLobbyVaults := VaultsData\n        #     var SavedLobbyVaults : [vault_type]vault_data_persistent = PlayerSaveData.LobbyVaults\n\n        #     for(CurrentVaultIndex -> CurrentVaultData : CurrentLobbyVaults):\n        #         CurrentVaultType := CurrentVaultData.VaultType\n        #         if(SaveVaultData := SavedLobbyVaults[CurrentVaultType]):\n        #             # vault exists in persistent data\n        #             Logger.Print(\"vault {CurrentVaultType.ToString()} found in persistent data\")\n        #             for(CurrentLobbyPropIndex -> CurrentLobbyPropData : CurrentVaultData.LobbyProps):\n        #                 if(SaveLobbyPropData := SaveVaultData.LobbyPropsPlaced[CurrentLobbyPropIndex]):\n        #                     # lobby prop exists in persistent data\n        #                     if(SaveLobbyPropData?):\n        #                         CurrentLobbyPropData.Prop.Show()\n        #                     else:\n        #                         CurrentLobbyPropData.Prop.Hide()\n        #                 else:\n        #                     # lobby prop doesn't exist in persistent data, add it\n        #                     if:\n        #                         SaveVaultData.LobbyPropsPlaced.Insert[CurrentLobbyPropIndex, array { CurrentLobbyPropData.IsPlaced }]\n\n        #         else:\n        #             # vault doesn't exist in persistent data, add it\n        #             Logger.Print(\"vault {CurrentVaultType.ToString()} NOT found in persistent data\")\n\n        #             NewLobbyProps := for(CurrentLobbyPropData : CurrentVaultData.LobbyProps):\n        #                 CurrentLobbyPropData.IsPlaced\n\n        #             if:\n        #                 set SavedLobbyVaults[CurrentVaultType] = vault_data_persistent{\n        #                     VaultType := CurrentVaultType\n        #                     IsUnlocked := false\n        #                     LobbyPropsPlaced := NewLobbyProps\n        #                 }\n                        \n        PrintGameSaveData()\n\n    PrintGameSaveData(): void =\n        if:\n            PlayerSaveData := GetGameSaveData[]\n        then:\n            Logger.Print(\"GAME SAVE DATA:\")\n\n            Logger.Print(\"Version: {PlayerSaveData.Version}\")\n\n            Logger.Print(\"FirstTimeGameEntered: {PlayerSaveData.FirstTimeGameEntered.ToString()}\")\n\n            Logger.Print(\"ReceptionEntered: {PlayerSaveData.ReceptionEntered.ToString()}\")\n\n            Logger.Print(\"MaxRoomIndexReached: {PlayerSaveData.MaxRoomIndexReached}\")\n\n            Logger.Print(\"Side rooms: ---------------------\")\n            for(SideRoomIndex -> IsSideRoomChecked : PlayerSaveData.SideRoomChecked):\n                Logger.Print(\"Side room {SideRoomIndex}: {IsSideRoomChecked.ToString()}\")\n\n            Logger.Print(\"Upgrades: ---------------------\")\n            for(UpgradeData : PlayerSaveData.Upgrades):\n                UpgradeType := UpgradeData.UpgradeType\n                Logger.Print(\"Upgrade {UpgradeType.ToString()}: {UpgradeData.CurrentLevel}\")\n\n            Logger.Print(\"Vaults: ---------------------\")\n            for(SaveVaultIndex -> SaveVaultData : PlayerSaveData.LobbyVaults):\n                SaveVaultType := SaveVaultData.VaultType\n                Logger.Print(\"Vault {SaveVaultType.ToString()}:\")\n                    for(SaveLobbyPropIndex -> SaveLobbyPropUnlocked : SaveVaultData.LobbyPropsPlaced):\n                        Logger.Print(\"Prop {SaveLobbyPropIndex}: {SaveLobbyPropUnlocked.ToString()}\")",
    "external_calls": [
      "vault_type",
      "upgrade_type",
      "log_channel",
      "log",
      "ConcatenateMaps"
    ]
  }
] 