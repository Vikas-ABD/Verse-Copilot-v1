[
  {
    "file_name": "basic_enemy_npc_behaviour.verse",
    "questions": [
      "How can I create a comprehensive AI enemy NPC behavior system with patrol, chase, and search states in Verse?",
      "What is the Verse code for implementing enemy AI with perception, navigation, and player interaction mechanics?",
      "I need a script that handles NPC state machines, player detection, and combat mechanics for a horror game.",
      "How do I create an enemy AI system with patrol routes, player pursuit, and elimination mechanics?"
    ],
    "explanation": "This script provides a comprehensive AI behavior system for enemy NPCs in a horror game, implementing advanced state machine logic, player detection, navigation, and combat mechanics. It's designed to create intelligent and challenging enemy encounters with realistic AI behaviors.\n\n**Core Components:**\n- basic_enemy_npc_behaviour: Main NPC behavior class extending npc_behavior\n- State machine with DISABLED, IDLE, PATROL, CHASE, SEARCH, HOVER states\n- Perception system for player detection and line-of-sight tracking\n- Navigation system with patrol routes, chase mechanics, and search patterns\n- Combat system with damage dealing and player elimination\n- External device management for audio, perception, and analytics\n\n**Key Features:**\n1. **Advanced State Machine**: Multi-state AI with PATROL, CHASE, SEARCH behaviors\n2. **Player Detection**: Sophisticated perception system with sight tracking\n3. **Navigation System**: Intelligent pathfinding with patrol routes and dynamic targeting\n4. **Combat Mechanics**: Player damage, elimination, and death sequences\n5. **Audio Integration**: Dynamic audio management tied to AI states\n6. **Patrol System**: Configurable patrol routes with multiple movement patterns\n7. **Search Behavior**: Last-seen location tracking and intelligent search patterns\n8. **Device Management**: External device coordination and positioning\n\n**State Machine Architecture:**\n- **DISABLED**: Inactive state during initialization\n- **IDLE**: Default waiting state between behaviors\n- **PATROL**: Active patrolling with configurable routes\n- **CHASE**: Player pursuit with running movement\n- **SEARCH**: Investigation of last known player location\n- **HOVER**: Special state for specific behaviors\n\n**Perception and Detection:**\n- **NPCPerception**: perception_trigger_device for player detection\n- **OnPlayerSeen/OnPlayerLost**: Event handlers for player visibility\n- **OnNPCSeenByPlayer/OnNPCLostByPlayer**: Bidirectional awareness system\n- **ReactsToPlayer**: Dynamic reaction control based on player hiding state\n- **SeenPlayerCharacter**: Tracking of detected player character\n- **LastSeenPlayerLocation**: Memory system for search behavior\n\n**Navigation and Movement:**\n- **PatrolDetails**: Configurable patrol point system with multiple patterns\n- **ONE_SHOT, PING_PONG, CYCLE**: Different patrol route types\n- **ReachRadius**: Configurable navigation precision\n- **MovementTypes**: Walking for patrol, Running for chase\n- **NavigationTarget**: Dynamic targeting system for agents and positions\n\n**Combat System:**\n- **DoPlayerDamage**: Configurable damage dealing to players\n- **PlayerKill**: Instant elimination with cutscene integration\n- **KillPlayerOnReach**: Toggle for lethal vs damage-based combat\n- **GetKillMessage**: Randomized death messages for variety\n- **PlayerDeathCutsceneView**: Cinematic death sequence integration\n\n**External Device Management:**\n- **ExternalDevicesRoot**: Central device positioning system\n- **NPCAudioDevices**: Array of audio players for NPC sounds\n- **PlayerDeathAnalyticsDevice**: Analytics tracking for player deaths\n- **StickExternalDevicesToNPC**: Dynamic device positioning system\n\n**How It Works:**\n1. **Initialization**: OnBegin() sets up NPC character, perception, and external devices\n2. **State Management**: RunNPCStateMachine() continuously evaluates and executes current state\n3. **Player Detection**: Perception system triggers state changes based on player visibility\n4. **Navigation**: Intelligent pathfinding adapts to current state and target\n5. **Combat**: Proximity-based damage system with elimination mechanics\n6. **Event Integration**: Global event system coordinates with other game systems\n7. **Cleanup**: Proper resource management and state reset on NPC elimination",
    "code": "using { /Fortnite.com/AI }\nusing { /Verse.org/Simulation }\nusing { /Fortnite.com/Characters }\nusing { /Fortnite.com/Devices }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /Verse.org/Simulation/Tags }\nusing { /Verse.org/Random }\nusing { /Fortnite.com/Game }\nusing { Entities }\n \n# Reference: https://dev.epicgames.com/documentation/en-us/uefn/create-your-own-npc-medic-in-unreal-editor-for-fortnite\n\nbasic_enemy_npc_behaviour<public> := class(npc_behavior):\n    @editable\n    ExternalDevicesRoot: creative_prop = creative_prop{}\n    @editable\n    NPCPerception: perception_trigger_device = perception_trigger_device{}\n    @editable\n    NPCAudioDevices: []audio_player_device = array{}\n    @editable\n    PlayerDeathCutsceneView: creative_prop = creative_prop{}\n    @editable\n    PlayerDeathAnalyticsDevice: analytics_device = analytics_device{}\n    # @editable\n    # SkilledInteraction: skilled_interaction_device = skilled_interaction_device{}\n\n    var PatrolDetails: patrol_details = patrol_details{}\n    var SearchDetails: search_details = search_details{}\n\n    var GlobalEventChannel: global_event_channel = global_event_channel{}\n    var CurrentNPCBehaviourState: NPC_BEHAVIOUR_STATE = NPC_BEHAVIOUR_STATE.DISABLED\n    # var PreviousNPCBehaviourState: NPC_BEHAVIOUR_STATE = NPC_BEHAVIOUR_STATE.IDLE\n\n    # var IsNPCBehaviourInitialized: logic = false\n    # var NPCBehaviourStartRequested: logic = false\n\n    var NPCEntityData: entity_data = entity_data{}\n    NPCWorldHelper: npc_world_helper = npc_world_helper{}\n\n    # Used to specify how quickly to update the position of the external devices this NPC depends on\n    ExternalDevicesUpdateRateSeconds<private>:float = 0.1\n    var ExternalDevicesInitialPosition<private>: transform = transform{}\n\n    var IsPlayerSeen: logic = false\n    # var IsPlayerDead: logic = false\n    var CurrentPatrolPointIndex: int = 0\n    var CurrentPatrolDirection: int = 1\n    var NPCBehaviourID<public>: string = \"defaultNPCID\"\n    var SeenPlayerCharacter: ?fort_character = false\n    var LastSeenPlayerLocation: vector3 = vector3{X := 0.0, Y := 0.0, Z := 0.0}\n\n    var GlobalEventChannelCancelable: string = \"\"\n    var EntityName: string = \"Basic\"\n    AllKillMessages: []string = array {\n        \"BEWARE\",\n        \"FRESH CATCH\"\n    }\n\n    var PlayerSeenEvent: event() = event(){}\n    var PlayerLostEvent: event() = event(){}\n    var PlayerStartedLookingEvent: event() = event(){}\n    var PlayerStoppedLookingEvent: event() = event(){}\n    var PlayerStartedHidingEvent: event() = event(){}\n    var PlayerStoppedHidingEvent: event() = event(){}\n    \n    OnBegin<override>()<suspends>:void =\n        # PrintNPC(\"Basic: OnBegin\")\n        Initialize()\n\n    # This function runs when the NPC is despawned or eliminated from the world.\n    OnEnd<override>():void=\n        PrintNPC(\"Basic: Goodbye, NPC!\")\n        ResetNPC()\n        GlobalEventChannel.PlayerEventChannel.UnsubscribeChannel(GlobalEventChannelCancelable)\n        if:\n            ExternalDevicesRoot.TeleportTo[ExternalDevicesInitialPosition]\n\n    Initialize<public>(): void =\n        # if(not IsNPCBehaviourInitialized?):\n        #     set IsNPCBehaviourInitialized = true\n            if:\n                # Get the Agent (the NPC).\n                NPCAgent := GetAgent[]\n    \n                # Gets the Fortnite Character interface, which gets you access to its gameplay data \n                # including its AI module for navigation and focus.\n                NPCCharacter := NPCAgent.GetFortCharacter[]\n    \n                # Get the Navigatable Interface, this allows you to tell it to move.\n                NPCNavigatable := NPCCharacter.GetNavigatable[]\n    \n                # Get the Focus Interface, this allows you to tell it to look at something or somewhere.\n                NPCFocus := NPCCharacter.GetFocusInterface[]\n            then:\n                PrintNPC(\"Basic: Hi, NPC!\")\n                spawn{StickExternalDevicesToNPC()}\n    \n                # For some reason, FindCreativeObjectsWithTag DOES NOT work in NPC behaviour, even though the function exists.\n                # for(Element : FindCreativeObjectsWithTag(global_event_channel_tag{}), FoundGlobalEventChannel := global_event_channel[Element]):\n                #     PrintNPC(\"Basic: FoundGlobalEventChannel in NPC\")\n                #     set GlobalEventChannel = FoundGlobalEventChannel\n\n                NPCCharacter.EliminatedEvent().Subscribe(OnEliminatedNPC)\n    \n                NPCPerception.Disable()\n                NPCPerception.DeviceSeesAgentEvent.Subscribe(OnPlayerSeen)\n                NPCPerception.DeviceLosesSightOfAgentEvent.Subscribe(OnPlayerLost)\n                NPCPerception.AgentLooksAtDeviceEvent.Subscribe(OnNPCSeenByPlayer)\n                NPCPerception.AgentLooksAwayFromDeviceEvent.Subscribe(OnNPCLostByPlayer)\n                # NPCPerception.Enable()\n    \n                # PrintNPC(\"Basic: What's NPCBehaviourStartRequested? {NPCBehaviourStartRequested.ToString()}\")\n                # if NPC behaviour start has been requested already...\n                # if(NPCBehaviourStartRequested?):\n                #     PrintNPC(\"Basic: Was NPCBehaviourStartRequested\")\n                #     # ...then start the behaviour, now that it is ready.\n                #     spawn{StartNPCBehaviour()}\n                # PrintNPC(\"Basic: IsNPCBehaviourInitialized in OnBegin: {IsNPCBehaviourInitialized.ToString()}\")\n                set NPCBehaviourID = \"thisOneIsOnBegined\"\n    \n    ResetNPC(): void =\n        PrintNPC(\"Basic: Resetting NPC...\")\n        ToggleNPCVisible(false)\n        set CurrentNPCBehaviourState = NPC_BEHAVIOUR_STATE.DISABLED\n        set NPCEntityData = entity_data{}\n        # set PreviousNPCBehaviourState = NPC_BEHAVIOUR_STATE.IDLE\n        # set IsPlayerSeen = false\n        set PatrolDetails = patrol_details{}\n        set SearchDetails = search_details{}\n        set SeenPlayerCharacter = false\n        set CurrentPatrolPointIndex = 0\n        set CurrentPatrolDirection = 1\n        set LastSeenPlayerLocation = vector3{X := 0.0, Y := 0.0, Z := 0.0}\n        # set IsPlayerDead = false\n        ToggleNPCSystems(false)\n\n    StopPlayingAllAudio(): void =\n        for(AudioDevices : NPCAudioDevices):\n            AudioDevices.Stop()\n    \n    InitializeBehavior<public>(NewGlobalEventChannel: global_event_channel): void =\n        set GlobalEventChannel = NewGlobalEventChannel\n        set GlobalEventChannelCancelable = GlobalEventChannel.PlayerEventChannel.SubscribeChannel(NewPlayerEvent, \"basic_ai\")\n        \n    SetupNPCBase(NPCData: entity_data): void =\n        # ResetNPC()\n        set NPCEntityData = NPCData\n        IsPlayerAlreadyHiding := NPCEntityData.PlayerData.CheckIsHiding()\n        set NPCEntityData.ReactsToPlayer = logic{not IsPlayerAlreadyHiding?}\n        ToggleNPCSystems(false)\n        # PrintNPC(\"Basic: ReactsToPlayer: {ReactsToPlayer.ToString()}\")\n\n    SetupNPC<public>(NPCData: entity_data): void =\n        SetupNPCBase(NPCData)\n\n    MoveToSpawnTransform<public>(): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            # SpawnTransformUpVector := NPCEntityData.SpawnDetails.SpawnTransformProp.GetTransform().Rotation.GetLocalUp()\n            SpawnTransformPosition := NPCEntityData.SpawnDetails.SpawnTransformProp.GetTransform().Translation\n            # PrintNPC(\"SpawnTransformPosition {SpawnTransformPosition}\")\n            SpawnPosition := vector3{\n                X := SpawnTransformPosition.X,\n                Y := SpawnTransformPosition.Y,\n                Z := SpawnTransformPosition.Z + NPCCharacter.GetTransform().Translation.Z\n            }\n            ToggleNPCVisible(false)\n            if:\n                NPCCharacter.PutInStasis(stasis_args{})\n                # NPCCharacter.TeleportTo[SpawnPosition, NPCCharacter.GetTransform().Rotation]\n                NPCCharacter.TeleportTo[SpawnPosition, NPCEntityData.SpawnDetails.SpawnTransformProp.GetTransform().Rotation]\n                NPCCharacter.ReleaseFromStasis()\n            then:\n                PrintNPC(\"Moved to spawn location: {SpawnPosition}\")\n            else:\n                PrintNPC(\"Move FAILED to spawn location: {SpawnPosition}\")\n\n    AnnounceArrival()<suspends>: void =\n        MoveToSpawnTransform()\n        \n        ToggleAllAudioDevices(true)\n        ToggleNPCSystems(true)\n        \n        GoToFirstState()\n        ToggleNPCVisible(true)\n        RunNPCStateMachine()\n\n    GoToFirstState(): void =\n        SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.IDLE)\n\n    IsPlayerDead()<transacts><decides>: void =\n        logic{NPCEntityData.PlayerData.CheckIsPlayerDead[]}?\n\n    IsNPCActive()<transacts><decides>: void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            logic{NPCCharacter.IsActive[] and CurrentNPCBehaviourState <> NPC_BEHAVIOUR_STATE.DISABLED}?\n        else:\n            false?\n\n    ToggleNPCSystems(Active: logic): void =\n        ToggleAllAudioDevices(Active)\n        if(Active?):\n            NPCPerception.Enable()\n        else:\n            NPCPerception.Disable()\n    \n    ToggleAllAudioDevices(Active: logic): void =\n        if(Active?):\n            for(AudioDevices : NPCAudioDevices):\n                AudioDevices.Enable()\n        else:\n            for(AudioDevices : NPCAudioDevices):\n                AudioDevices.Stop()\n                AudioDevices.Disable()\n\n\n    ToggleNPCVisible(Visible: logic): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            if(Visible?):\n                NPCCharacter.Show()\n            else:\n                NPCCharacter.Hide()\n\n    StartNPCBehaviour<public>(): void =\n        spawn{AnnounceArrival()}\n\n    RunNPCStateMachine()<suspends>: void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n            NPCFocus := NPCCharacter.GetFocusInterface[]\n            NPCNavigatable := NPCCharacter.GetNavigatable[]\n        then:\n            loop:\n                if(not NPCCharacter.IsActive[] or IsPlayerDead[]):\n                    PrintNPC(\"Basic: break state machine loop\")\n                    break\n                \n                case (CurrentNPCBehaviourState):\n                    NPC_BEHAVIOUR_STATE.DISABLED => \n                        PrintNPC(\"Basic: Waiting for announcement to finish\")\n                    NPC_BEHAVIOUR_STATE.IDLE =>\n                        PrintNPC(\"Basic: NPC Idling\")\n                        # Sleep(2.0)\n                    NPC_BEHAVIOUR_STATE.PATROL =>\n                        PrintNPC(\"Basic: GoToNextPatrolPoint\")\n                        GoToNextPatrolPoint(NPCAgent, NPCCharacter, NPCFocus, NPCNavigatable)\n                    NPC_BEHAVIOUR_STATE.CHASE =>\n                        DoAChase(NPCAgent, NPCCharacter, NPCFocus, NPCNavigatable)\n                    NPC_BEHAVIOUR_STATE.SEARCH =>\n                        DoASearch(NPCAgent, NPCCharacter, NPCFocus, NPCNavigatable)\n                    _ => # default\n                        PrintNPC(\"Basic: How RunNPCStateMachine reached here?\")\n                        break\n                \n                Sleep(0.5)\n\n    \n    SetNPCBehaviourState(NewState: NPC_BEHAVIOUR_STATE): void =\n        # set PreviousNPCBehaviourState = CurrentNPCBehaviourState\n        set CurrentNPCBehaviourState = NewState\n        PrintCurrentState()\n\n    GetNextNPCBehaviourState(): NPC_BEHAVIOUR_STATE =\n        var NextNPCBehaviourState: NPC_BEHAVIOUR_STATE = NPC_BEHAVIOUR_STATE.IDLE\n\n        case (CurrentNPCBehaviourState):\n            NPC_BEHAVIOUR_STATE.CHASE => \n                set NextNPCBehaviourState = NPC_BEHAVIOUR_STATE.SEARCH\n            NPC_BEHAVIOUR_STATE.SEARCH =>\n                set NextNPCBehaviourState = NPC_BEHAVIOUR_STATE.PATROL\n            _ => # default\n                PrintNPC(\"Basic: How GetNextNPCBehaviourState reached here?\")\n                \n        return NextNPCBehaviourState\n\n    StickExternalDevicesToNPC()<suspends>: void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            set ExternalDevicesInitialPosition = ExternalDevicesRoot.GetTransform()\n            # Loop MoveTo on the devices to match their position to the NPC\n            loop:\n                if(not NPCCharacter.IsActive[] or IsPlayerDead[]):\n                    # PrintNPC(\"Basic: Stop sticking devices to NPC\")\n                    break\n\n                # PrintNPC(\"ExternalDevicesRoot: {ExternalDevicesRoot.GetTransform().Translation}\")\n                NPCCharacterTransform := NPCCharacter.GetTransform()\n                ExternalDevicesRoot.MoveTo(NPCCharacterTransform, ExternalDevicesUpdateRateSeconds)\n\n                Sleep(ExternalDevicesUpdateRateSeconds)\n\n    OnPlayerSeen(Agent: agent): void =\n        if(IsNPCActive[] and not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            PrintNPC(\"Basic: Player SEEN: {NPCEntityData.ReactsToPlayer.ToString()}\")\n            if:\n                NPCAgent := GetAgent[]\n                NPCCharacter := NPCAgent.GetFortCharacter[]\n\n                PlayerCharacter := Agent.GetFortCharacter[]\n            then:\n                if(NPCCharacter.IsActive[]):\n                    PlayerSeenEvent.Signal()\n                    # set IsPlayerSeen = true\n                    set SeenPlayerCharacter = option{PlayerCharacter}\n                    StartChasing()\n                \n    OnPlayerLost(Agent: agent): void =\n        if(IsNPCActive[] and not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            PrintNPC(\"Basic: Player LOST\")\n            # set IsPlayerSeen = false\n            PlayerLostEvent.Signal()\n            StopChasing()\n\n    OnNPCSeenByPlayer(Agent: agent): void =\n        if(IsNPCActive[] and not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            PlayerStartedLookingEvent.Signal()\n            # PrintNPC(\"Basic: Player seeing NPC\")\n\n    OnNPCLostByPlayer(Agent: agent): void =\n        if(IsNPCActive[] and not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            PlayerStoppedLookingEvent.Signal()\n            # PrintNPC(\"Basic: Player not seeing NPC\")\n\n    PrintNavigationResult(NavResult: navigation_result, NavReason: string): void =\n        case (NavResult):\n            navigation_result.Reached =>\n                PrintNPC(\"Basic: NavResult for {NavReason}: Reached\")\n            navigation_result.PartiallyReached =>\n                PrintNPC(\"Basic: NavResult for {NavReason}: PartiallyReached\")\n            navigation_result.Interrupted =>\n                PrintNPC(\"Basic: NavResult for {NavReason}: Interrupted\")\n            navigation_result.Blocked =>\n                PrintNPC(\"Basic: NavResult for {NavReason}: Blocked\")\n            navigation_result.Unreachable =>\n                PrintNPC(\"Basic: NavResult for {NavReason}: Unreachable\")\n\n    PrintCurrentState(): void =\n        case (CurrentNPCBehaviourState):\n            NPC_BEHAVIOUR_STATE.DISABLED =>\n                PrintNPC(\"STATE: DISABLED\")\n            NPC_BEHAVIOUR_STATE.IDLE =>\n                PrintNPC(\"STATE: IDLE\")\n            NPC_BEHAVIOUR_STATE.PATROL =>\n                PrintNPC(\"STATE: PATROL\")\n            NPC_BEHAVIOUR_STATE.CHASE =>\n                PrintNPC(\"STATE: CHASE\")\n            NPC_BEHAVIOUR_STATE.SEARCH =>\n                PrintNPC(\"STATE: SEARCH\")\n            NPC_BEHAVIOUR_STATE.HOVER =>\n                PrintNPC(\"STATE: HOVER\")\n\n    SetupPatrolPoints(): void =\n        set PatrolDetails.PatrolPoints = for(PatrolPointProp: PatrolDetails.PatrolPointProps):\n            PatrolPointProp.GetTransform().Translation\n\n    StartPatroling(): void =\n        SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.PATROL)\n        PrintNPC(\"Basic: Start patroling\")\n        \n    GoToNextPatrolPoint(NPCAgent: agent, NPCCharacter: fort_character, NPCFocus: focus_interface, NPCNavigatable: navigatable)<suspends>: void =\n        NPCNavigatable.StopNavigation()\n        if(NextPatrolPoint := PatrolDetails.PatrolPoints[CurrentPatrolPointIndex], NextPatrolPointPosition := NextPatrolPoint):\n            PrintNPC(\"Basic: NextPatrolPoint: {CurrentPatrolPointIndex} in direction {CurrentPatrolDirection}\")\n            PatrolNavigationTarget := MakeNavigationTarget(NextPatrolPointPosition)\n            NPCNavResult := NPCNavigatable.NavigateTo(PatrolNavigationTarget, ?MovementType := movement_types.Walking, ?ReachRadius := 10.0, ?AllowPartialPath := true)\n            PrintNavigationResult(NPCNavResult, \"Patrol\")\n            if(NPCNavResult = navigation_result.Reached):\n                PrintNPC(\"Basic: NPC reached patrol point {CurrentPatrolPointIndex}\")\n                set CurrentPatrolPointIndex += CurrentPatrolDirection\n                NPCNavigatable.Wait(?Duration := PatrolDetails.PauseSecondsAtPatrolPoint)\n        else:\n            case (PatrolDetails.PatrolType):\n                NPC_PATROL_TYPE.ONE_SHOT =>\n                    StopPatroling()\n                NPC_PATROL_TYPE.PING_PONG =>\n                    set CurrentPatrolDirection *= -1\n                    set CurrentPatrolPointIndex += CurrentPatrolDirection\n                NPC_PATROL_TYPE.CYCLE =>\n                    set CurrentPatrolPointIndex = 0\n    \n    StopPatroling<public>(): void =\n        # SetNPCBehaviourState(GetNextNPCBehaviourState())\n        PrintNPC(\"Basic: Stop patroling\")\n        EliminateNPC()\n    \n    StartChasing<public>(): void =\n        if(NPCEntityData.ReactsToPlayer?):\n            if:\n                NPCAgent := GetAgent[]\n                NPCCharacter := NPCAgent.GetFortCharacter[]\n                NPCNavigatable := NPCCharacter.GetNavigatable[]\n            then:\n                NPCNavigatable.StopNavigation()\n                SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.CHASE)\n\n    DoAChase(NPCAgent: agent, NPCCharacter: fort_character, NPCFocus: focus_interface, NPCNavigatable: navigatable)<suspends>: void =\n        if(not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            NPCNavigatable.StopNavigation()\n            if(ChasingPlayerCharacter := SeenPlayerCharacter?, PlayerAgent := ChasingPlayerCharacter.GetAgent[]):\n                PrintNPC(\"Basic: Player pursuit!\")\n                PlayerNavigationTarget := MakeNavigationTarget(PlayerAgent)\n                # if(Distance(PlayerCharacter.GetTransform().Translation, NPCCharacter.GetTransform().Translation) > 500.0):\n                NPCNavResult := NPCNavigatable.NavigateTo(PlayerNavigationTarget, ?MovementType := movement_types.Running, ?ReachRadius := 10.0, ?AllowPartialPath := true)\n                PrintNavigationResult(NPCNavResult, \"Pursuit\")\n                if(NPCNavResult = navigation_result.Reached):\n                    PrintNPC(\"Basic: Player reached!\")\n                    # do continuous damage\n                    loop:\n                        if(ChasingPlayerCharacter.IsActive[]):\n                            if(Distance(ChasingPlayerCharacter.GetTransform().Translation, NPCCharacter.GetTransform().Translation) <= 100.0 and CurrentNPCBehaviourState = NPC_BEHAVIOUR_STATE.CHASE):\n                                DoPlayerDamage(ChasingPlayerCharacter)\n                                Sleep(1.0)\n                            else:\n                                break\n                        else:\n                            StopChasing()\n                            break\n\n    StopChasing<public>(): void =\n        if(not IsPlayerDead[]): # and NPCEntityData.ReactsToPlayer?):\n            PrintNPC(\"Basic: Stop chasing\")\n            if:\n                NPCAgent := GetAgent[]\n                NPCCharacter := NPCAgent.GetFortCharacter[]\n                NPCNavigatable := NPCCharacter.GetNavigatable[]\n            then:\n                # set IsPlayerSeen = false\n                NPCNavigatable.StopNavigation()\n                StartSearching()\n                # SetNPCBehaviourState(GetNextNPCBehaviourState())\n    \n    # not used right now, we directly do SetNPCBehaviourState(GetNextNPCBehaviourState()) inside StopChasing\n    StartSearching(): void =\n        if(not IsPlayerDead[] and NPCEntityData.ReactsToPlayer?):\n            if:\n                NPCAgent := GetAgent[]\n                NPCCharacter := NPCAgent.GetFortCharacter[]\n                NPCNavigatable := NPCCharacter.GetNavigatable[]\n            then:\n                NPCNavigatable.StopNavigation()\n                if(SearchDetails.SearchType = NPC_SEARCH_TYPE.LAST_SEEN):\n                    if(PlayerCharacter := SeenPlayerCharacter?):\n                        set LastSeenPlayerLocation = PlayerCharacter.GetTransform().Translation\n\n                if(SearchDetails.SearchType <> NPC_SEARCH_TYPE.WEAK_CHASE):\n                    set SeenPlayerCharacter = false\n\n                SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.SEARCH)\n\n    DoASearch(NPCAgent: agent, NPCCharacter: fort_character, NPCFocus: focus_interface, NPCNavigatable: navigatable)<suspends>: void =\n        NPCNavigatable.StopNavigation()\n        PrintNPC(\"Basic: Searching for player for {SearchDetails.GiveUpSearchAfterTimeSeconds} seconds\")\n        var NPCNavResult : navigation_result = navigation_result.Unreachable\n\n        race:\n            block:\n                case (SearchDetails.SearchType):\n                    NPC_SEARCH_TYPE.LAST_SEEN =>\n                        SearchNavigationTarget := MakeNavigationTarget(LastSeenPlayerLocation)\n                        set NPCNavResult = NPCNavigatable.NavigateTo(SearchNavigationTarget, ?MovementType := movement_types.Walking, ?ReachRadius := 10.0, ?AllowPartialPath := true)\n                    NPC_SEARCH_TYPE.WEAK_CHASE =>\n                        if(ChasingPlayerCharacter := SeenPlayerCharacter?, PlayerAgent := ChasingPlayerCharacter.GetAgent[]):\n                            SearchNavigationTarget := MakeNavigationTarget(PlayerAgent)\n                            set NPCNavResult = NPCNavigatable.NavigateTo(SearchNavigationTarget, ?MovementType := movement_types.Walking, ?ReachRadius := 10.0, ?AllowPartialPath := true)\n\n                PrintNavigationResult(NPCNavResult, \"Search\")\n                if(NPCNavResult = navigation_result.Reached):\n                    PrintNPC(\"Basic: Search location reached!\")\n                    if(not SeenPlayerCharacter?):\n                        StopSearching()\n                return\n            block:\n                if(SearchDetails.GiveUpSearchAfterTimeSeconds > 0.0):\n                    Sleep(SearchDetails.GiveUpSearchAfterTimeSeconds)\n                    StopSearching()\n\n    StopSearching(): void =\n        PrintNPC(\"Basic: Stop searching, go back to normal\")\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n            NPCNavigatable := NPCCharacter.GetNavigatable[]\n        then:\n            NPCNavigatable.StopNavigation()\n            # SetNPCBehaviourState(GetNextNPCBehaviourState())\n            ResumePatroling()\n\n    ResumePatroling(): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            PrintNPC(\"ResumePatroling\")\n            if(PatrolDetails.ResumePatrolType = NPC_RESUME_PATROL_TYPE.CLOSEST_PATROL_POINT):\n                PrintNPC(\"Finding CLOSEST_PATROL_POINT...\")\n                if:\n                    var ClosestPatrolPointIndex: int = 0\n                    NPCLocation := NPCCharacter.GetTransform().Translation\n                    var ClosestPatrolPointDistance: float = Distance(NPCLocation, PatrolDetails.PatrolPoints[ClosestPatrolPointIndex])\n                then:\n                    for(PatrolPointIndex := 0..PatrolDetails.PatrolPoints.Length - 1):\n                        if(NewDistance := Distance(NPCLocation, PatrolDetails.PatrolPoints[PatrolPointIndex]), NewDistance < ClosestPatrolPointDistance):\n                            set ClosestPatrolPointDistance = NewDistance\n                            set ClosestPatrolPointIndex = PatrolPointIndex\n\n                    set CurrentPatrolPointIndex = ClosestPatrolPointIndex\n\n        SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.PATROL)\n\n    DoPlayerDamage(PlayerCharacter: fort_character): void =\n        if(not IsPlayerDead[]):\n            PrintNPC(\"Basic: Player damage!\")\n            if(NPCEntityData.KillPlayerOnReach?):\n                PlayerKill(PlayerCharacter)\n            else:\n                PlayerCharacter.Damage(NPCEntityData.Damage)\n                # if(PlayerCharacter.GetHealth() <= 0.0):\n                    # SendPlayerKilledMessage()\n\n    PlayerKill(PlayerCharacter: fort_character): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            if(not IsPlayerDead[]):\n                PrintNPC(\"Basic: Player kill!\")\n                SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.IDLE)\n                # NPCCutsceneCameraLocation := \n                KillMessage := GetKillMessage()\n                NPCEntityData.PlayerData.PlayerEliminateByEntity(GetPlayerDeathCutsceneView(), option{KillMessage})\n\n                Player := NPCEntityData.PlayerData.GetPlayer()\n                if:\n                    APlayer := Player?\n                then:\n                    PlayerDeathAnalyticsDevice.Submit(APlayer)\n\n    GetPlayerDeathCutsceneView(): transform =\n        return PlayerDeathCutsceneViewFullTransform()\n\n    PlayerDeathCutsceneViewFullTransform(): transform = \n        return PlayerDeathCutsceneView.GetTransform()\n\n    PlayerDeathCutsceneViewOnlyRotation(): transform =\n        # just rotate player to look at the entity\n        if(PlayerCharacter := NPCEntityData.PlayerData.CurrentPlayerCharacter?):\n            # CutsceneViewLocation := PlayerCharacter.GetTransform().Translation\n            # CutsceneViewRotation := PlayerDeathCutsceneView.GetTransform().Rotation\n            # return transform { Translation := CutsceneViewLocation, Rotation := CutsceneViewRotation}\n\n            CutsceneViewLocation := PlayerCharacter.GetTransform().Translation\n            EntityLookAtRotation := FindLookAtRotation(PlayerCharacter.GetTransform(), PlayerDeathCutsceneView.GetTransform())\n            # CutsceneViewRotation := PlayerDeathCutsceneView.GetTransform().Rotation\n            return transform { Translation := CutsceneViewLocation, Rotation := EntityLookAtRotation}\n        \n        return PlayerDeathCutsceneViewFullTransform()\n\n    GetKillMessage(): string = \n        var KillMessage : string = \"dummy kill message\"\n        MessageIndex := GetRandomInt(0, AllKillMessages.Length - 1)\n        if(NewKillMessage := AllKillMessages[MessageIndex]):\n            set KillMessage = NewKillMessage\n        return KillMessage\n\n    # SendPlayerKilledMessage(): void =\n    #     if:\n    #         NPCAgent := GetAgent[]\n    #     then:\n    #         GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_ELIMINATED, event_player_eliminated{EntityType := NPCEntityData.EntityType}, option{NPCAgent})\n\n    OnPlayerKilled(): void =\n        PrintNPC(\"Player has been killed.\")\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n            NPCNavigatable := NPCCharacter.GetNavigatable[]\n        then:\n            NPCNavigatable.StopNavigation()\n\n    CleanupNPC<public>(): void =\n        return\n    \n    EliminateNPC(): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n        then:\n            NPCCharacter.Damage(NPCCharacter.GetHealth())\n        \n    OnEliminatedNPC(EliminationResult : elimination_result): void =\n        PrintNPC(\"On eliminated NPC\")\n        if(not IsPlayerDead[]):\n            GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_SURVIVED_ENTITY, event_player_survived_entity{EntityType := NPCEntityData.EntityType}, false)\n\n\n    NewPlayerEvent(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        # PrintNPC(\"NewPlayerEvent\")\n        case (EventName):\n            event_names.PLAYER_HIDE_SUCCESS =>\n                if(HideSuccessData := event_player_hide_success[Data]):\n                    OnPlayerHidden(HideSuccessData)\n            event_names.PLAYER_UNHIDE_SUCCESS =>\n                OnPlayerUnhidden()\n            event_names.PLAYER_ELIMINATED =>\n                OnPlayerKilled()\n            _ =>\n                return\n            \n    OnPlayerHidden(EventHideSuccessData: event_player_hide_success): void =\n        PrintNPC(\"OnPlayerHidden\")\n        set NPCEntityData.ReactsToPlayer = false\n        PlayerStartedHidingEvent.Signal()\n\n    OnPlayerUnhidden(): void =\n        PrintNPC(\"OnPlayerUnhidden\")\n        set NPCEntityData.ReactsToPlayer = true\n        PlayerStoppedHidingEvent.Signal()\n\n    PrintNPC(PrintString: string): void =\n        Print(\"{EntityName}: {PrintString}\")",
    "external_calls": [
      "npc_behavior",
      "creative_prop",
      "perception_trigger_device",
      "audio_player_device",
      "analytics_device",
      "patrol_details",
      "search_details",
      "global_event_channel",
      "NPC_BEHAVIOUR_STATE",
      "entity_data",
      "npc_world_helper",
      "transform",
      "fort_character",
      "vector3",
      "event",
      "agent",
      "navigatable",
      "focus_interface",
      "navigation_result",
      "navigation_target",
      "movement_types",
      "NPC_PATROL_TYPE",
      "NPC_SEARCH_TYPE",
      "NPC_RESUME_PATROL_TYPE",
      "stasis_args",
      "elimination_result",
      "event_names",
      "event_data",
      "event_player_hide_success",
      "event_player_survived_entity",
      "MakeNavigationTarget",
      "Distance",
      "FindLookAtRotation",
      "GetRandomInt",
      "Print",
      "Sleep"
    ]
  }
] 