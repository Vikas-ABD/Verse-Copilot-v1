[
  {
    "file_name": "room_manager.verse",
    "questions": [
      "How can I create a comprehensive room management system that handles different room types and entity spawning in Verse?",
      "What is the Verse code for managing room lifecycle, door locks, and lighting systems?",
      "I need a script that handles room transitions, entity probability calculations, and hiding mechanics.",
      "How do I create a room manager that coordinates with game events and handles multiple room types?"
    ],
    "explanation": "This script is a comprehensive room management system for a horror game, handling everything from room lifecycle management to entity spawning and player interactions. It's one of the most complex systems in the game, coordinating multiple subsystems.\n\n**Core Components:**\n- last_entity_details: Tracks the last entity spawned to prevent consecutive spawns\n- side_room_data: Manages side rooms with separate analytics and entry logic\n- room_data: Base class for all room types with common functionality\n- level_room_data: Main room class extending room_data with full game mechanics\n- room_hiding_button: Specialized button for hiding mechanics\n- room_button: Base button class for room interactions\n\n**Key Features:**\n1. **Room Lifecycle Management**: Complete room state management from initialization through cleanup\n2. **Entity Spawning System**: Sophisticated probability-based entity spawning with anti-repetition logic\n3. **Lighting Control**: Advanced lighting system with flickering effects and coordinated audio\n4. **Door Lock Management**: Automated door locking/unlocking with visual indicators\n5. **Hiding System**: Player hiding mechanics with button interactions and transform management\n6. **Volume Tracing**: Automatic device discovery and assignment using spatial volumes\n7. **Analytics Integration**: Comprehensive room and death analytics tracking\n8. **Event Communication**: Full integration with global event system for coordination\n\n**Room Lifecycle:**\n1. **InitializeRoom()**: Sets up basic room structure and event subscriptions\n2. **RoomEntered()**: Activates room systems, locks doors, processes entities\n3. **RoomExited()**: Cleans up entities, unsubscribes events, resets state\n4. **RoomStartRun()**: Prepares room for new game run\n5. **RoomDeath()**: Handles player death analytics and room reset\n\n**Entity Spawning Logic:**\n- Uses cumulative probability system for fair entity distribution\n- Prevents consecutive spawning of same entity type\n- Supports multiple spawn types: time-based, volume-based, trigger-based\n- Handles guaranteed spawns vs probabilistic spawns\n- Integrates with global entity management system\n\n**Device Management:**\n- Automatic device discovery using volume tracing and tags\n- Dynamic assignment of lights, locks, buttons, and analytics devices\n- Hiding point and exit point pairing for seamless hiding mechanics\n- Chase manager integration for entity AI coordination\n\n**How It Works:**\n- Room setup uses volume tracing to automatically find and categorize devices\n- Entity processing calculates spawn probabilities and selects entities fairly\n- Event system coordinates with game manager and other systems\n- Lighting system provides atmospheric effects with audio synchronization\n- Analytics track player progress and behavior for game improvement",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /Verse.org/Verse }\nusing { /Verse.org/Random }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /Verse.org/Simulation/Tags }\nusing { AI }\nusing {UtilityClasses}\nusing { Entities }\n\nRoomEntitiesCategory<public><localizes>:message := \"Room Entities\"\nlast_entity_details := class:\n    var LastEntitySpawnedType: entity_type = entity_type.NONE\n    var LastEntitySpawnedInRoomIndex: int = -1\n\nside_room_data := class(room_event_communicator):\n    @editable\n    SideRoomEnterVolume : mutator_zone_device = mutator_zone_device{}\n    @editable\n    SideRoomEnterAnalyticsDevice : analytics_device = analytics_device{}\n\n    var SideRoomIndex : int = -1\n    var PlayerInSideRoom: ?player = false\n\n    InitializeSideRoom(NewGlobalEventChannel: global_event_channel, NewSideRoomIndex: int): void =\n        Setup(NewGlobalEventChannel)\n        set SideRoomIndex = NewSideRoomIndex\n        SideRoomEnterVolume.AgentEntersEvent.Subscribe(OnSideRoomEntered)\n\n    SideRoomStartRun(): void =\n        ToggleSideRoomEnterVolume(true)\n        set PlayerInSideRoom = false\n\n    OnSideRoomEntered(Agent: agent): void =\n        if(NewPlayerInSideRoom := player[Agent], set PlayerInSideRoom = option{NewPlayerInSideRoom}):\n            GlobalEventChannel.RoomEventChannel.BroadcastChannel(event_names.NEW_SIDE_ROOM_ENTERED, event_player_entered_room{ RoomIndex := SideRoomIndex }, false)\n            ToggleSideRoomEnterVolume(false)\n\n    ToggleSideRoomEnterVolume(Active: logic): void =\n        if(Active?):\n            SideRoomEnterVolume.Enable()\n        else:\n            SideRoomEnterVolume.Disable()\n\n    SendAnalyticsSideRoomEntered(): void =\n        if(Player := PlayerInSideRoom?):\n            SideRoomEnterAnalyticsDevice.Submit(Player)\n\nroom_data := class(room_event_communicator):\n    @editable\n    TracerVolumeProp: creative_prop = creative_prop{}\n    var TracerVolume: tracing_volume = tracing_volume{}\n    @editable\n    IsDoorInitiallyLocked : logic = false\n    var RoomIndex : int = -1\n    var RoomEventsCancelable: string = \"\"\n    var PlayerEventsCancelable: string = \"\"\n    var StopLightsFlickerEvent: event() = event(){}\n\n    InitializeRoom(NewGlobalEventChannel: global_event_channel, NewRoomIndex: int): void =\n        Setup(NewGlobalEventChannel)\n        set RoomIndex = NewRoomIndex\n\n    AddToDeviceList(List : []creative_object_interface, DeviceType : devices_type): void=\n        Print(\"overridable Method\", ?Duration:=6.0)\n\nlevel_room_data := class(room_data):\n    var RoomEnterVolume : mutator_zone_device = mutator_zone_device{}\n    var RoomEnterAnalyticsDevice : analytics_device = analytics_device{}\n    var RoomDeathAnalyticsDevice : analytics_device = analytics_device{}\n    var DoorLockDevice : lock_device = lock_device{}\n    var DoorLockConditionalButtonDevice : conditional_button_device = conditional_button_device{}\n    var DoorLockIcon : creative_prop = creative_prop{}\n    var AllLights: []customizable_light_device = array{}\n    var EyesSpawnTransforms: []creative_prop = array{}\n    var HideButtons: []room_hiding_button = array{}\n    var SeekChaseManager: chase_manager = chase_manager{}\n\n    @editable:\n        Categories := array{RoomEntitiesCategory}\n    var SeekData: seek_data = seek_data{}\n    @editable:\n        Categories := array{RoomEntitiesCategory}\n    var RushData: rush_data = rush_data{}\n    @editable:\n        Categories := array{RoomEntitiesCategory}\n    var FreezeData: freeze_data = freeze_data{}\n    @editable:\n        Categories := array{RoomEntitiesCategory}\n    var FigureData: figure_data = figure_data{}\n    @editable:\n        Categories := array{RoomEntitiesCategory}\n    var BlinkData: blink_data = blink_data{}\n    @editable:\n        Categories := array{RoomEntitiesCategory}\n    var EyesData: eyes_data = eyes_data{}\n    @editable:\n        Categories := array{RoomEntitiesCategory}\n    var SpawnEntitiesOnEnteringVolume<public>: mutator_zone_device = mutator_zone_device{}\n    @editable\n    RandomSpooks: random_spooks_data = random_spooks_data{}\n    \n    var LastEntityDetails: last_entity_details = last_entity_details{}\n    var RoomEntityData: [entity_type]entity_data = map{}\n    var EntityReadyForSpawn : entity_data = entity_data{}\n    var EntitySpawned: entity_data = entity_data{}\n    var LightsFlickerAudioDevice: audio_player_device = audio_player_device{}\n    BlankAgent: ?agent = false\n    var PlayerInRoom: ?player = false\n    RandomSpooksManager: random_spooks_manager = random_spooks_manager{}\n\n    InitializeRoom<override>(NewGlobalEventChannel: global_event_channel, NewRoomIndex: int): void =\n        (super:)InitializeRoom(NewGlobalEventChannel, NewRoomIndex)\n        set SeekData.ChaseManager = SeekChaseManager\n        if:\n            set RoomEntityData[entity_type.SEEK] = SeekData\n            set RoomEntityData[entity_type.RUSH] = RushData\n            set RoomEntityData[entity_type.FREEZE] = FreezeData\n            set RoomEntityData[entity_type.FIGURE] = FigureData\n            set RoomEntityData[entity_type.BLINK] = BlinkData\n            set RoomEntityData[entity_type.EYES] = EyesData\n            set RoomEntityData[entity_type.NONE] = entity_data{}\n\n        RoomEnterVolume.AgentEntersEvent.Subscribe(RoomEntered)\n        DoorLockConditionalButtonDevice.ActivatedEvent.Subscribe(LockConditionalButtonActivated)\n        SpawnEntitiesOnEnteringVolume.AgentEntersEvent.Subscribe(SpawnEntityOnVolumeEnter)\n        for(HideButton : HideButtons):\n            HideButton.Setup(GlobalEventChannel)\n\n    SetupRoomTransferDetails(NewLastEntityDetails: last_entity_details): void =\n        set LastEntityDetails = NewLastEntityDetails\n\n    AddToDeviceList<override>(List:[]creative_object_interface, DeviceType:devices_type) : void=\n        case (DeviceType):\n            devices_type.LIGHTS =>\n                for(RawLight : List, Light := customizable_light_device[RawLight]):\n                    set AllLights += array{Light}\n            devices_type.ENTER_VOLUME =>\n                if(EnterVolume := mutator_zone_device[List[0]]):\n                    set RoomEnterVolume = EnterVolume\n            devices_type.LOCK =>\n                if(LockDevice := lock_device[List[0]]):\n                    set DoorLockDevice = LockDevice\n            devices_type.LOCK_CONDITIONAL_BUTTON_DEVICE =>\n                if(LockConditionalButtonDevice := conditional_button_device[List[0]]):\n                    set DoorLockConditionalButtonDevice = LockConditionalButtonDevice\n            devices_type.LOCK_ICON =>\n                if(LockIcon := creative_prop[List[0]]):\n                    set DoorLockIcon = LockIcon\n            devices_type.SEEK_CHASE_MANAGER =>\n                if(ChaseManager := chase_manager[List[0]]):\n                    set SeekChaseManager = ChaseManager\n            devices_type.ENTER_ANALYTICS_DEVICE =>\n                if(EnterAnalyticsDevice := analytics_device[List[0]]):\n                    set RoomEnterAnalyticsDevice = EnterAnalyticsDevice\n            devices_type.ROOM_DEATH_ANALYTICS_DEVICE =>\n                if(DeathAnalyticsDevice := analytics_device[List[0]]):\n                    set RoomDeathAnalyticsDevice = DeathAnalyticsDevice\n            _ =>\n                Print(\"no recognized devices\")\n    \n    AddDirectDevices(NewGameAudioDevices: game_audio_devices): void =\n        set LightsFlickerAudioDevice = NewGameAudioDevices.LightsFlicker\n\n    MakeCupboard(ButtonList:[]creative_object_interface, HidingPoints : []creative_prop, ExitPoints : []creative_prop) : void=\n        for(RawButton : ButtonList, HidingButton := button_device[RawButton]):\n            ButtonTransform := HidingButton.GetTransform()\n            var NearestHidingPoint :creative_prop = creative_prop{}\n            var NearestExitPoint :creative_prop = creative_prop{}\n            var NearestDistance : ?float = false\n            \n            for(HidingPoint : HidingPoints):\n                Dist := FindDistanceBetweenTwoVectors(ButtonTransform, HidingPoint.GetTransform())\n                if(not NearestDistance?):\n                    set NearestDistance = option{Dist}\n                    set NearestHidingPoint = HidingPoint\n                else if(Dist < NearestDistance?):\n                    set NearestDistance = option{Dist}\n                    set NearestHidingPoint = HidingPoint\n\n            set NearestDistance = false\n            for(ExitPoint : ExitPoints):\n                Dist := FindDistanceBetweenTwoVectors(ButtonTransform, ExitPoint.GetTransform())\n                if(not NearestDistance?):\n                    set NearestDistance = option{Dist}\n                    set NearestExitPoint = ExitPoint\n                else if(Dist < NearestDistance?):\n                    set NearestDistance = option{Dist}\n                    set NearestExitPoint = ExitPoint\n\n            set HideButtons += array:\n                room_hiding_button:\n                    HidingPoint := NearestHidingPoint\n                    ExitPoint := NearestExitPoint\n                    Button := HidingButton\n                \n    LockConditionalButtonActivated(Agent: agent): void =\n        UnlockDoor()\n\n    UnlockDoor(): void=\n        if(Agent := agent[PlayerInRoom?]):\n            DoorLockDevice.Unlock(Agent)\n            DoorLockDevice.Open(Agent)\n            DoorLockIcon.Hide()\n\n    LockDoor(): void=\n        if(Agent := agent[PlayerInRoom?]):\n            DoorLockDevice.Close(Agent)\n            DoorLockDevice.Lock(Agent)\n            DoorLockIcon.Show()\n            DoorLockConditionalButtonDevice.Reset()\n\n    FlickerLights(FlickerData: event_lights_flicker_start)<suspends>: void =\n        race:\n            block:\n                var EachFlickerLoopDuration: float = 0.1\n                loop:\n                    set EachFlickerLoopDuration = GetRandomFloat(0.05, 0.2)\n                    for(Light : AllLights):\n                        IsLightOn := logic{GetRandomInt(0,2) = 2}\n                        if(IsLightOn?):\n                            Light.TurnOn()\n                        else:\n                            Light.TurnOff()\n                        LightsFlickerAudioDevice.Stop()\n                        LightsFlickerAudioDevice.Play()\n                    Sleep(EachFlickerLoopDuration)\n            block:\n                EachFlickerLoopDuration := 1.0\n                if(FlickerData.FlickerForSeconds > 0.0):\n                    NumFlickers := FlickerData.FlickerForSeconds / EachFlickerLoopDuration\n                    if(var FlickersLeft: int = Ceil[NumFlickers]):\n                        loop:\n                            if(FlickersLeft <= 0):\n                                StopLightsFlickerEvent.Signal()\n                                break\n                            set FlickersLeft -= 1\n                            Sleep(EachFlickerLoopDuration)\n                else:\n                    loop:\n                        Sleep(EachFlickerLoopDuration)\n            block:\n                StopLightsFlickerEvent.Await()\n                if(FlickerData.FlickerForSeconds > 0.0):\n                    GlobalEventChannel.RoomEventChannel.BroadcastChannel(event_names.LIGHTS_FLICKER_END, event_lights_flicker_end{\n                        LightsDieOnEnd := true,\n                        RoomIndex := RoomIndex\n                    }, BlankAgent)\n\n    ToggleAllLights(IsOn: logic): void =\n        StopLightsFlickerEvent.Signal()\n        for(Light : AllLights):\n            if(IsOn?):\n                Light.TurnOn()\n            else:\n                Light.TurnOff()\n            LightsFlickerAudioDevice.Stop()\n            LightsFlickerAudioDevice.Play()\n        \n    RoomEntered(Agent: agent): void =\n        if(NewPlayerInRoom := player[Agent], set PlayerInRoom = option{NewPlayerInRoom}):\n            GlobalEventChannel.RoomEventChannel.BroadcastChannel(event_names.NEW_ROOM_ENTERED, event_player_entered_room{ RoomIndex := RoomIndex }, PlayerInRoom)\n            ToggleRoomEnterVolume(false)\n            LockDoor()\n            AllEventCommunicators : []room_event_communicator = HideButtons\n            for(EventCommunicator : AllEventCommunicators):\n                EventCommunicator.Setup(GlobalEventChannel)\n            set RoomEventsCancelable = GlobalEventChannel.RoomEventChannel.SubscribeChannel(NewRoomEvent, \"room_manager\")\n            set PlayerEventsCancelable = GlobalEventChannel.PlayerEventChannel.SubscribeChannel(NewPlayerEvent, \"room_manager\")\n            ProcessEntities()\n            spawn{SpawnEntityAfterSeconds()}\n            \n    SendAnalyticsRoomEntered(): void =\n        if(Player := PlayerInRoom?):\n            RoomEnterAnalyticsDevice.Submit(Player)\n\n    RoomExited(): void =\n        GlobalEventChannel.RoomEventChannel.BroadcastChannel(event_names.DESPAWN_ALL_ENTITIES, event_despawn_all_entities{}, PlayerInRoom)\n        GlobalEventChannel.RoomEventChannel.UnsubscribeChannel(RoomEventsCancelable)\n        GlobalEventChannel.PlayerEventChannel.UnsubscribeChannel(PlayerEventsCancelable)\n        StopLightsFlickerEvent.Signal()\n\n    RoomRestart(): void =\n        RoomExited()\n        ResetEntities()\n        ToggleRoomEnterVolume(true)\n        ToggleSpawnEntitiesVolume(true)\n        ToggleAllLights(true)\n\n    RoomStartRun(): void =\n        RoomRestart()\n        return\n\n    RoomDeath(): void =\n        if(Player := PlayerInRoom?):\n            RoomDeathAnalyticsDevice.Submit(Player)\n        RoomRestart()\n\n    ResetEntities(): void =\n        set EntityReadyForSpawn = entity_data{}\n        set EntitySpawned = entity_data{}\n\n    ToggleRoomEnterVolume(Active: logic): void =\n        if(Active?):\n            RoomEnterVolume.Enable()\n        else:\n            RoomEnterVolume.Disable()\n\n    ToggleSpawnEntitiesVolume(Active: logic): void =\n        if(Active?):\n            SpawnEntitiesOnEnteringVolume.Enable()\n        else:\n            SpawnEntitiesOnEnteringVolume.Disable()\n\n    ProcessEntities<public>(): void =\n        var EntitiesCumulativeProbability: [entity_type]int = map{}\n        var GuaranteedEntityType: entity_type = entity_type.NONE\n        var PreviousEntityCumulativeProbability: int = 0\n        var AllEntitiesProbability: int = 0\n\n        for (EntityType->EntityData : RoomEntityData):\n            if(EntityData.Probability >= 100):\n                set GuaranteedEntityType = EntityType\n\n            if(GuaranteedEntityType = entity_type.NONE):\n                if(EntityData.Probability > 0):\n                    if:\n                        set EntitiesCumulativeProbability[EntityType] = 0\n                        set AllEntitiesProbability += EntityData.Probability\n                        set EntitiesCumulativeProbability[EntityType] = EntityData.Probability + PreviousEntityCumulativeProbability\n                        if(CurrentEntityCumulativeProbability := EntitiesCumulativeProbability[EntityType]):\n                            set PreviousEntityCumulativeProbability = CurrentEntityCumulativeProbability\n\n        if(AllEntitiesProbability < 100):\n            if(set EntitiesCumulativeProbability[entity_type.NONE] = 100):\n                Print(\"\")\n\n        if(GuaranteedEntityType <> entity_type.NONE):\n            if(GuaranteedEntityData := RoomEntityData[GuaranteedEntityType]):\n                set EntityReadyForSpawn = GuaranteedEntityData\n        else:\n            RNG := GetRandomInt(1,100)\n            var ChosenEntity: entity_data = entity_data{}\n            for (EntityType->EntityProb : EntitiesCumulativeProbability):\n                if(ChosenEntity.EntityType = entity_type.NONE):\n                    EntityProbability := EntityProb\n                    if(RNG <= EntityProbability):\n                        if(FoundEntity := RoomEntityData[EntityType]):\n                            set ChosenEntity = FoundEntity\n\n            if(ChosenEntity.EntityType <> entity_type.NONE):\n                if(ChosenEntity.EntityType <> LastEntityDetails.LastEntitySpawnedType):\n                    set EntityReadyForSpawn = ChosenEntity\n\n        if(EntityReadyForSpawn.EntityType <> entity_type.NONE):\n            if(EntityReadyForSpawn.SpawnDetails.SpawnType = NPC_SPAWN_TYPE.ON_TRIGGER):\n                EntityReadyForSpawn.SpawnDetails.AssignTriggerFunction(SpawnEntityOnTrigger)\n\n    SpawnEntityOnVolumeEnter(Agent: agent): void =\n        if(EntityReadyForSpawn.EntityType <> entity_type.NONE):\n            if(EntityReadyForSpawn.SpawnDetails.SpawnType = NPC_SPAWN_TYPE.ON_ENTER_VOLUME):\n                ToggleSpawnEntitiesVolume(false)\n                SpawnEntity()\n      \n    SpawnEntityAfterSeconds()<suspends>: void =\n        if(EntityReadyForSpawn.EntityType <> entity_type.NONE):\n            if(EntityReadyForSpawn.SpawnDetails.SpawnType = NPC_SPAWN_TYPE.AFTER_SECONDS and EntityReadyForSpawn.SpawnDetails.SpawnSecondsAfterEntering >= 0.0):\n                Sleep(EntityReadyForSpawn.SpawnDetails.SpawnSecondsAfterEntering)\n                SpawnEntity()\n\n    SpawnEntityOnTrigger(Agent: ?agent): void =\n        if(EntityReadyForSpawn.EntityType <> entity_type.NONE):\n            if(EntityReadyForSpawn.SpawnDetails.SpawnType = NPC_SPAWN_TYPE.ON_TRIGGER):\n                SpawnEntity()\n\n    SpawnEntity(): void =\n        set EntityReadyForSpawn.SpawnDetails.SpawnRoomIndex = RoomIndex\n        GlobalEventChannel.RoomEventChannel.BroadcastChannel(event_names.SPAWN_ENTITY, event_spawn_entity{\n            EntityType := EntityReadyForSpawn.EntityType,\n            EntityData := EntityReadyForSpawn,\n            DespawnOthers := EntityReadyForSpawn.DespawnOthers,\n            RoomIndex := RoomIndex\n        }, PlayerInRoom)\n        set EntitySpawned = EntityReadyForSpawn\n    \n    CleanupEntity(): void =\n        if(EntitySpawned.EntityType <> entity_type.NONE):\n            GlobalEventChannel.RoomEventChannel.BroadcastChannel(event_names.CLEANUP_ENTITY_ROOM_EXITED, event_spawn_entity{\n                EntityType := EntitySpawned.EntityType,\n                EntityData := EntitySpawned,\n                DespawnOthers := EntitySpawned.DespawnOthers,\n                RoomIndex := RoomIndex\n            }, PlayerInRoom)\n            ResetEntities()\n\n    NewRoomEvent<override>(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        return\n\n    NewPlayerEvent<override>(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        return\n\n    PrintRoom(PrintString: string)<transacts>: void =\n        Print(\"Room {RoomIndex + 1}: {PrintString}\")\n\nroom_hiding_button := class(room_button):\n    @editable\n    HidingPoint: creative_prop = creative_prop{}\n    @editable\n    ExitPoint: creative_prop = creative_prop{}\n\n    ButtonInteractedEvent<override>(Agent: agent): void =\n        (super:)ButtonInteractedEvent(Agent)\n        if(InteractedPlayer := player[Agent]):\n            GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_HIDE_TOGGLE, event_player_hide{HidingButton:= Button, HidingTransform:= HidingPoint.GetTransform(), ExitTransform:= ExitPoint.GetTransform()}, option{Agent})\n\nroom_button := class(room_event_communicator):\n    @editable\n    Button: button_device = button_device{}\n\n    Setup<override>(NewGlobalEventChannel: global_event_channel): void =\n        (super:)Setup(NewGlobalEventChannel)\n        Button.InteractedWithEvent.Subscribe(ButtonInteractedEvent)\n    \n    ButtonInteractedEvent(Agent: agent): void =\n        Print(\"button pressed!\")",
    "external_calls": [
      "room_event_communicator",
      "global_event_channel",
      "event_names",
      "event_data",
      "event_player_entered_room",
      "event_lights_flicker_start",
      "event_lights_flicker_end",
      "event_spawn_entity",
      "event_despawn_all_entities",
      "event_player_hide",
      "entity_type",
      "entity_data",
      "seek_data",
      "rush_data",
      "freeze_data",
      "figure_data",
      "blink_data",
      "eyes_data",
      "random_spooks_data",
      "random_spooks_manager",
      "chase_manager",
      "game_audio_devices",
      "devices_type",
      "tracing_volume",
      "NPC_SPAWN_TYPE",
      "FindDistanceBetweenTwoVectors",
      "GetRandomFloat",
      "GetRandomInt",
      "Ceil"
    ]
  }
] 