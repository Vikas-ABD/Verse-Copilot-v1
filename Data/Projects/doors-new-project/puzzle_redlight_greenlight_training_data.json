[
  {
    "file_name": "puzzle_redlight_greenlight.verse",
    "questions": [
      "How do I create a 'Red Light, Green Light' puzzle in Verse?",
      "What is the code for a puzzle that damages players if they move during a 'Red Light' state, using input triggers?",
      "I need a script for a puzzle with a state machine (REDLIGHT, GREENLIGHT), cinematic effects, and custom audio management.",
      "How can I implement a puzzle that locks and unlocks doors, detects player movement, and plays custom elimination cutscenes?"
    ],
    "explanation": "This script implements the classic 'Red Light, Green Light' game as a puzzle within the game. It uses a state machine to alternate between 'GREENLIGHT' (players can move) and 'REDLIGHT' (players must stand still). During the 'REDLIGHT' phase, it uses input trigger devices to detect player movement and applies damage or elimination if they move. The puzzle is highly integrated with various devices to create an immersive experience, including audio players, cinematic sequences for post-processing effects, and lock devices for room control.\n\n**Core Components:**\n- `puzzle_redlight_greenlight`: The main class inheriting from `puzzle_base`.\n- `rg_state`: An enum (`GREENLIGHT`, `REDLIGHT`) that defines the current state of the game.\n- `rg_audio_manager`: A dedicated class to manage all sound effects and music for the puzzle.\n- **State Machine**: The `BeginPuzzle` loop function acts as the core state machine, switching between `PlayGreenLight` and `PlayRedLight`.\n- **Movement Detection**: `PlayerMovementCheck` uses `input_trigger_device.IsHeld` to detect if the player is pressing movement keys (W, A, S, D, or arrow keys).\n\n**Key Features:**\n1. **State-Driven Gameplay**: The puzzle's logic is cleanly separated into two states, `GREENLIGHT` and `REDLIGHT`, each with its own timing, visuals, and rules.\n2. **Input-Based Movement Detection**: It directly checks for player input via `input_trigger_device` to determine if the player is moving, offering a reliable detection method.\n3. **Cinematic and Audio Immersion**: Uses `cinematic_sequence_device` to apply post-processing effects that visually distinguish the two states and an `rg_audio_manager` to play corresponding soundscapes.\n4. **Player Punishment**: If a player moves during 'REDLIGHT', the `CheckForPlayerMovement` function repeatedly damages them and can trigger a custom elimination cutscene via `PlayerData.PlayerEliminateByEntity`.\n5. **Room and Puzzle Lifecycle**: Manages the entire lifecycle from the player entering the room (`OnPlayerEnterRoom`), which locks the door and starts the puzzle, to the player exiting (`OnPlayerExitRoom`), which solves the puzzle. It also includes a `PuzzleReset` function to return to its initial state.\n6. **Visual Feedback**: A rotating `SkullProp` provides visual feedback to the player during the 'REDLIGHT' phase, synced with the movement check timer.\n\n**Workflow:**\n1. **Initialization**: On `OnBegin`, the device subscribes to mutator zone events for room entry/exit and global events for player data and run resets.\n2. **Puzzle Start**: When a player enters the `MutatorZoneBegin`, `OnPlayerEnterRoom` is called. It locks the back door and spawns the `BeginPuzzle` loop.\n3. **Game Loop**: The loop alternates between `PlayGreenLight` (safe period) and `PlayRedLight` (danger period).\n4. **Red Light Phase**: During `PlayRedLight`, the `CheckForPlayerMovement` function is called. It spins the `SkullProp` and checks `input_trigger_device.IsHeld` every 0.1 seconds. If movement is detected, the player is damaged.\n5. **Puzzle Solved**: If the player successfully reaches and enters the `MutatorZoneEnd`, `OnPlayerExitRoom` is called, setting `IsSolved` to true, locking the forward door, and calling `OnPuzzleSolved` from the `puzzle_base` class.\n6. **Player Eliminated**: If the player is eliminated during the puzzle, `OnPlyerEliminated` cleans up the puzzle state and unlocks the doors.\n\n**Use Cases:**\n- Creating high-stakes traversal challenges.\n- Implementing timing-based puzzles that require players to pay close attention to environmental cues.\n- A template for any state-based game mechanic that alternates between safe and danger zones.",
    "code": "using { /Fortnite.com/Characters }\nusing { /Fortnite.com/Devices }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /Verse.org/Simulation }\nusing { /Fortnite.com/Game }\n\npuzzle_rlgl_log := class(log_channel){}\npuzzle_rlgl_drawlog := class(debug_draw_channel){}\n\nrg_state := enum:\n    GREENLIGHT\n    REDLIGHT\n\nrg_audio_manager := class:\n    @editable\n    BackgroundMusic : audio_player_device = audio_player_device{}\n\n    @editable\n    HeartBeat : audio_player_device = audio_player_device{}\n\n    @editable\n    StringForRedLight : audio_player_device = audio_player_device{}\n\n    @editable\n    SwitchToRedAudio : audio_player_device = audio_player_device{}\n\n    @editable\n    SwitchToGreenAudio : audio_player_device = audio_player_device{}\n    \n    @editable\n    WhispersAudio : audio_player_device = audio_player_device{}\n\n    PlayGreenLightSfx() : void=\n        SwitchToGreenAudio.Play()\n        WhispersAudio.Play()\n        BackgroundMusic.Play()\n\n    PlayRedLightSfx() : void=\n        StringForRedLight.Play()\n        HeartBeat.Play()\n        SwitchToRedAudio.Play()\n    \n    StopGreenLightSfx() : void=\n        SwitchToGreenAudio.Stop()\n        WhispersAudio.Stop()\n        BackgroundMusic.Stop()\n\n    StopRedLightSfx() : void=\n        StringForRedLight.Stop()\n        HeartBeat.Stop()\n        SwitchToRedAudio.Stop()\n\npuzzle_redlight_greenlight := class(puzzle_base):\n    Logger : log = log{Channel := puzzle_rlgl_log}\n    DebugDraw : debug_draw = debug_draw{Channel := puzzle_rlgl_drawlog}\n    var NamePuzzle<override> : puzzle_names = puzzle_names.REDLIGHT_GREENLIGHT\n\n    # Puzzle Settings for Timing and Damage--------\n\n    @editable\n    RedLightTime : float = 3.0\n\n    @editable\n    RedLightSafeTime : float = 1.0\n\n    @editable\n    RedLightDamageAmount : float = 20.0\n\n    @editable\n    GreenLightTime : float = 3.0\n\n    # Cinematic Device that handles the POST-PROCESS Volume according to Puzzle State [RED-GREEN]-----\n\n    @editable\n    GreenLightCinematic : cinematic_sequence_device = cinematic_sequence_device{}\n\n    # Skull prop references and Camera Move Prop on Death--------\n\n    @editable\n    SkullProp : creative_prop = creative_prop{}\n\n    @editable\n    DeathEliminationSourceProp : creative_prop = creative_prop{}\n\n    # AudioManager for managing the audio in RG puzzle--------\n\n    @editable\n    Sfxs : rg_audio_manager = rg_audio_manager{}\n\n    # Mutator Zone Devices to Detect the Puzzle Begin and End-------\n\n    @editable\n    MutatorZoneBegin : mutator_zone_device = mutator_zone_device{}\n\n    @editable\n    MutatorZoneEnd : mutator_zone_device = mutator_zone_device{}\n\n    # Input Trigger Devices for Detecting W,S,A,D key press or Arrow Keys--------\n\n    @editable\n    InputWalkFBDevice : input_trigger_device = input_trigger_device{}\n\n    @editable\n    InputWalkLRDevice : input_trigger_device = input_trigger_device{}\n\n    # Lock Devices for Front And Back door of the Room-----------\n\n    @editable\n    BackDoorLockDevice : lock_device = lock_device{}\n\n    @editable\n    ForwardDoorLockDevice : lock_device = lock_device{}\n\n    var PlayerData : player_data = player_data{}\n    var EliminationEvent : ?cancelable = false\n    var SkullTransform : transform = transform{}\n    var RGState : rg_state = rg_state.GREENLIGHT\n\n    # Runs when the device is started in a running game\n    OnBegin<override>()<suspends>:void=\n        # finding Global Event Channel\n        Setup()\n\n        # Event Binding to Room Enter and Exit\n        SubscribeToDeviceEvent(\"rg_enter_volume\", MutatorZoneBegin.AgentEntersEvent.Subscribe(OnPlayerEnterRoom))\n        SubscribeToDeviceEvent(\"rg_exit_volume\", MutatorZoneEnd.AgentEntersEvent.Subscribe(OnPlayerExitRoom))\n\n        # Global Event Channel Bindings to Get Player Data and Reset Event\n        SubscribeToPlayerEvent(PlayerDataEvent, \"puzzle_rglight_data\")\n        SubscribeToPlayerEvent(PuzzleResetReceived, \"puzzle_rglight_reset\")\n\n        # Storing Skull Initial Transform for Future References\n        set SkullTransform = SkullProp.GetTransform()\n\n    OnEnd<override>() : void=\n        (super:)OnEnd()\n        set IsActive = false\n\n    # Called when Reset Event received\n    PuzzleResetReceived(EventName : event_names, EventData : event_data, EventAgent : ?agent) : void=\n        # Print(\"PuzzleReset Base\", ?Duration:=6.0)\n        case (EventName):\n            event_names.PLAYER_END_RUN =>\n                spawn:\n                    PuzzleReset()\n            event_names.PLAYER_START_RUN =>\n                spawn:\n                    PuzzleReset()\n            _ =>\n\n    # Called When Player Data is Ready\n    PlayerDataEvent(EventName : event_names, EventData : event_data, EventAgent : ?agent) : void=\n        case (EventName):\n            event_names.PLAYER_DATA_READY =>\n                if(Data := event_player_data_ready[EventData]):\n                    set PlayerData = Data.NewPlayerData\n            _ => # default\n\n    # Called when Player Enter to Puzzle Enter Volume\n    OnPlayerEnterRoom(Agent : agent): void=\n        set IsActive = true\n        if:\n            FortChar := PlayerReference?.GetFortCharacter[]\n        then:\n            Cancelable := FortChar.EliminatedEvent().Subscribe(OnPlyerEliminated)\n            set EliminationEvent = option{Cancelable}\n        Logger.Print(\"Entering in Room\")\n        BackDoorLockDevice.Close(Agent)\n        BackDoorLockDevice.Lock(Agent)\n        spawn:\n            BeginPuzzle()\n\n    # Called When Player Eliminated While, In the Puzzle Room\n    OnPlyerEliminated(Result : elimination_result) : void=\n        if:\n            EliminatedPlayer := PlayerReference?\n        then:\n            set IsActive = false\n            set RGState = rg_state.GREENLIGHT\n            BackDoorLockDevice.Open(EliminatedPlayer)\n            BackDoorLockDevice.Unlock(EliminatedPlayer)\n            ForwardDoorLockDevice.Unlock(EliminatedPlayer)\n            if(Cancelable := EliminationEvent?):\n                Cancelable.Cancel()\n\n    # Called When Player Reach the End of the room [Puzzle Solved]\n    OnPlayerExitRoom(Agent : agent): void=\n        Logger.Print(\"Exit From Room\")\n        ForwardDoorLockDevice.Lock(Agent)\n        set IsSolved = true\n        set IsActive = false\n        OnPuzzleSolved()\n        \n    # To Begin the Game of Red-Green Light\n    BeginPuzzle()<suspends> : void=\n        loop:\n            if(IsSolved? or (not IsActive?)):\n                Sfxs.StopGreenLightSfx()\n                Sfxs.StopRedLightSfx()\n                GreenLightCinematic.Stop()\n                break\n            case (RGState):\n                rg_state.GREENLIGHT =>\n                    PlayGreenLight()\n                rg_state.REDLIGHT =>\n                    PlayRedLight()\n\n    # It Will Play Green Light When Called, Restores State to RedLight\n    PlayGreenLight()<suspends>: void=\n        Logger.Print(\"Playing Green\")\n        GreenLightCinematic.Play()\n        Sleep(0.5)\n        GreenLightCinematic.Pause()\n        Sfxs.PlayGreenLightSfx()\n        Sleep(GreenLightTime)\n        GreenLightCinematic.Stop()\n        Sfxs.StopGreenLightSfx()\n        set RGState = rg_state.REDLIGHT\n\n    # It Will Play Red Light When Called, Restores State to GreenLight\n    PlayRedLight()<suspends>: void=\n        Logger.Print(\"Playing Red\")\n        Sfxs.PlayRedLightSfx()\n        Sleep(RedLightSafeTime)\n        CheckForPlayerMovement()\n        Sfxs.StopRedLightSfx()\n        set RGState = rg_state.GREENLIGHT\n\n    # Rotates the Skull [Visually], Check for Player Movement Every 0.1 sec for RedLight Time: Synced\n    CheckForPlayerMovement()<suspends> : void=\n        var Checking : float = 0.0\n        if:\n            GetPlayer := PlayerReference?\n            FortCharacter := GetPlayer.GetFortCharacter[]\n        then:\n            loop:\n                if(IsSolved? or (not IsActive?) or Checking >= RedLightTime):\n                    break\n                sync:\n                    block:\n                        RotateSkull(360.0/(RedLightTime/0.1))\n                    block:\n                        CheckMovement := PlayerMovementCheck(GetPlayer)\n                        if(CheckMovement?):\n                            if(FortCharacter.GetHealth() <= RedLightDamageAmount):\n                                PlayerData.PlayerEliminateByEntity(DeathEliminationSourceProp.GetTransform(), option{\"I SAW YOU MOVE!\"})\n                                set IsActive = false\n                            DamagePlayer(RedLightDamageAmount)\n                        else:\n                            set Checking += 0.1\n                        Sleep(0.1)\n            SkullProp.MoveTo(SkullTransform.Translation, SkullTransform.Rotation, 0.1)\n\n    # Check for Player Movement, Player in Room or Not\n    PlayerMovementCheck(PlayerToCheck : player)<suspends> : logic=\n        if(InputWalkFBDevice.IsHeld[PlayerToCheck] or InputWalkLRDevice.IsHeld[PlayerToCheck]):\n            if(MutatorZoneBegin.IsInVolume[PlayerToCheck]):\n                return true\n        return false\n\n    # Rotates the Skull Each time by Given Step [Angle]\n    RotateSkull(RotationAngleSteps : float)<suspends> : void=\n        NewSkullRotation := SkullProp.GetTransform().Rotation.RotateBy(MakeRotationFromYawPitchRollDegrees(RotationAngleSteps, 0.0, 0.0))\n        SkullProp.MoveTo(SkullTransform.Translation, NewSkullRotation, 0.1)\n\n    # Resets The Puzzle to Default State\n    PuzzleReset()<suspends> : void=\n        Print(\"Reseting RedLight GreenLight\", ?Duration:=6.0)\n        set IsSolved = false\n        set IsActive = false\n        set RGState = rg_state.GREENLIGHT\n        SubscribeToDeviceEvent(\"rg_enter_volume\", MutatorZoneBegin.AgentEntersEvent.Subscribe(OnPlayerEnterRoom))\n        SubscribeToDeviceEvent(\"rg_exit_volume\", MutatorZoneEnd.AgentEntersEvent.Subscribe(OnPlayerExitRoom))\n        SubscribeToPlayerEvent(PlayerDataEvent, \"puzzle_rglight_data\")\n        SubscribeToPlayerEvent(PuzzleResetReceived, \"puzzle_rglight_reset\")\n\n        if:\n            GetPlayer := PlayerReference?\n        then:\n            BackDoorLockDevice.Open(GetPlayer)\n            BackDoorLockDevice.Unlock(GetPlayer)\n            ForwardDoorLockDevice.Unlock(GetPlayer)",
    "external_calls": [
      "puzzle_base",
      "log_channel",
      "debug_draw_channel",
      "audio_player_device",
      "cinematic_sequence_device",
      "creative_prop",
      "mutator_zone_device",
      "input_trigger_device",
      "lock_device",
      "player_data",
      "cancelable",
      "transform",
      "log",
      "debug_draw",
      "puzzle_names",
      "rg_state",
      "rg_audio_manager",
      "elimination_result",
      "player",
      "agent",
      "fort_character",
      "event_names",
      "event_data",
      "event_player_data_ready",
      "Play",
      "Stop",
      "Setup",
      "SubscribeToDeviceEvent",
      "SubscribeToPlayerEvent",
      "GetTransform",
      "OnEnd",
      "spawn",
      "EliminatedEvent",
      "Subscribe",
      "Close",
      "Lock",
      "Open",
      "Unlock",
      "Cancel",
      "OnPuzzleSolved",
      "loop",
      "Sleep",
      "Pause",
      "sync",
      "block",
      "GetHealth",
      "PlayerEliminateByEntity",
      "DamagePlayer",
      "MoveTo",
      "IsHeld",
      "IsInVolume",
      "RotateBy",
      "MakeRotationFromYawPitchRollDegrees",
      "Print"
    ]
  }
] 