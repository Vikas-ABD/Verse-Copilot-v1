[
  {
    "file_name": "freeze_npc_behavior.verse",
    "questions": [
      "How can I create a freeze NPC behavior that only moves when the player isn't looking at it in Verse?",
      "What is the Verse code for implementing a horror game entity called 'FREEZE' that uses line-of-sight mechanics?",
      "I need a script that handles a Weeping Angel style enemy that freezes when observed and chases when not seen.",
      "How do I create an NPC behavior with stasis mechanics and alarm system based on player observation duration?"
    ],
    "explanation": "This script provides a specialized freeze NPC behavior for a horror game entity called 'FREEZE' (also known as 'Rogue'), extending the basic_enemy_npc_behaviour class with unique line-of-sight mechanics inspired by Weeping Angels. The entity freezes completely when observed and only moves when the player isn't looking at it, creating intense psychological horror gameplay.\n\n**Core Components:**\n- freeze_npc_behavior: Specialized NPC behavior extending basic_enemy_npc_behaviour\n- Line-of-sight detection system with bidirectional awareness\n- Stasis mechanics for complete immobilization when observed\n- Alarm system with configurable observation duration threshold\n- Speed multiplier system for escalated threat levels\n- Simplified state machine focusing on IDLE and CHASE states\n\n**Key Features:**\n1. **Line-of-Sight Mechanics**: Only moves when player isn't looking at it\n2. **Stasis System**: Complete immobilization including turning prevention\n3. **Alarm Threshold**: Configurable timer for escalated behavior (default 5 seconds)\n4. **Speed Escalation**: 3x speed multiplier when alarmed\n5. **Bidirectional Detection**: Tracks both player seeing NPC and NPC seeing player\n6. **Audio State Management**: Context-aware audio activation\n7. **Hiding Integration**: Responds to player hiding mechanics\n8. **Simplified Chase Logic**: Direct pursuit without complex navigation\n\n**Inheritance Architecture:**\n- **Extends basic_enemy_npc_behaviour**: Inherits all base AI functionality\n- **Selective Overrides**: Customizes detection and chase behaviors\n- **State Machine Simplification**: Focuses on IDLE/CHASE binary states\n- **Observation-Based Logic**: Replaces traditional AI with line-of-sight mechanics\n\n**Line-of-Sight Detection System:**\n- **OnNPCSeenByPlayer()**: Triggered when player looks at NPC\n- **OnNPCLostByPlayer()**: Triggered when player stops looking at NPC\n- **OnPlayerSeen()**: Only activates when NPC is not alarmed\n- **OnPlayerLost()**: Disabled to prevent traditional AI interference\n- **Bidirectional Awareness**: Handles both directions of observation\n\n**Stasis Mechanics:**\n- **PutInStasis()**: Complete immobilization when observed\n- **AllowTurning := false**: Prevents even rotational movement\n- **ReleaseFromStasis()**: Enables movement when not observed\n- **Animation Control**: Integrates with animation system for freeze effects\n- **State Coordination**: Synchronized with behavior state changes\n\n**Alarm System:**\n- **SecondsLookingUntilAlarmed**: Configurable threshold (default 5.0 seconds)\n- **IsAlarmed**: Boolean flag for escalated behavior state\n- **PlayerLookingAtMe**: Tracks current observation status\n- **CountAlarm()**: Race condition timer for alarm activation\n- **ToggleAlarmed()**: Manages alarm state transitions\n\n**Speed Escalation System:**\n- **Normal Speed**: 1.0x multiplier for standard behavior\n- **Alarmed Speed**: 3.0x multiplier for escalated threat\n- **SetMovementSpeedMultiplier()**: Dynamic speed adjustment\n- **Persistent Escalation**: Alarm state persists until reset\n- **Performance Scaling**: Balances challenge with player capability\n\n**State Machine Override:**\n- **Simplified States**: Only IDLE and CHASE states used\n- **IDLE State**: Stasis mode with audio disabled\n- **CHASE State**: Active pursuit with audio enabled\n- **No Patrol**: Eliminates traditional patrol behavior\n- **Observation-Driven**: State changes based on line-of-sight\n\n**Audio Management:**\n- **ToggleAudio()**: Simple on/off audio control\n- **Chase Audio**: Single audio device (NPCAudioDevices[0])\n- **Context-Aware**: Audio only during active chase\n- **State Synchronized**: Audio matches behavior state\n\n**Player Detection Override:**\n- **OnPlayerSeen()**: Only functions when not alarmed\n- **OnPlayerLost()**: Disabled to prevent interference\n- **Selective Activation**: Prevents traditional AI when in freeze mode\n- **Alarm-Dependent**: Behavior changes based on alarm state\n\n**Observation Response Logic:**\n- **Freeze Response**: Immediate stop when observed\n- **Resume Response**: Immediate chase when not observed\n- **Alarm Consideration**: Different behavior when alarmed\n- **State Transitions**: Smooth switching between freeze and chase\n\n**Chase Mechanics:**\n- **DoAChase()**: Inherited chase behavior from parent class\n- **Speed Boosted**: Enhanced movement when alarmed\n- **Audio Enabled**: Chase audio during active pursuit\n- **Stasis Released**: Full movement capability enabled\n\n**Hiding Integration:**\n- **OnPlayerHidden()**: Responds to player hiding events\n- **ReactsToPlayer Reset**: Disables player detection when hidden\n- **Alarm Reset**: Clears alarm state when player hides\n- **Chase Interruption**: Stops active chase when player hides\n\n**Race Condition Management:**\n- **CountAlarm()**: Concurrent timer and observation tracking\n- **PlayerStoppedLookingEvent**: Event-driven observation state\n- **Alarm Activation**: Time-based escalation with observation validation\n- **Event Coordination**: Proper cleanup of racing conditions\n\n**Technical Implementation:**\n- **Event-Driven Architecture**: Uses custom events for observation state\n- **Stasis Integration**: Leverages Fortnite's stasis system\n- **Speed Multipliers**: Dynamic movement speed adjustment\n- **State Validation**: Proper state checking and transitions\n\n**Performance Considerations:**\n- **Simplified State Machine**: Reduced complexity for better performance\n- **Event-Based Updates**: Efficient observation state changes\n- **Selective Audio**: Audio only when needed\n- **Stasis Optimization**: Reduces processing when immobilized\n\n**Gameplay Mechanics:**\n- **Psychological Horror**: Creates tension through observation mechanics\n- **Strategic Gameplay**: Players must balance observation and movement\n- **Escalation System**: Increases threat over time\n- **Risk/Reward**: Longer observation leads to higher danger\n\n**Integration Points:**\n- **Player Hiding System**: Coordinates with stealth mechanics\n- **Audio System**: Single audio device for chase sounds\n- **Animation System**: Integrates with character animation control\n- **Event System**: Uses custom observation events\n\n**Alarm System Details:**\n- **Timer-Based**: 5-second default observation threshold\n- **Validation Check**: Ensures player is still looking when timer expires\n- **State Persistence**: Alarm state persists until manually reset\n- **Speed Boost**: 3x movement speed when alarmed\n- **Reset Conditions**: Hiding or manual reset clears alarm\n\n**Line-of-Sight Logic:**\n- **Player Observing NPC**: Triggers freeze behavior\n- **Player Not Observing**: Triggers chase behavior\n- **Alarm State Override**: Changes behavior when alarmed\n- **Hiding Override**: Player hiding stops all interactions\n\n**State Transitions:**\n- **Observed → Freeze**: Immediate stasis and audio stop\n- **Not Observed → Chase**: Stasis release and audio start\n- **Alarmed**: Maintains chase regardless of observation\n- **Hidden**: Resets all states and stops interactions\n\n**Audio State Management:**\n- **IDLE State**: Audio disabled, stasis enabled\n- **CHASE State**: Audio enabled, stasis disabled\n- **Alarm Independent**: Audio state matches behavior state\n- **Clean Transitions**: Proper audio start/stop coordination\n\n**Elimination Mechanics:**\n- **Custom Messages**: \"You have met Rogue\" with behavioral instructions\n- **Movement Instructions**: Explains the observation-based mechanics\n- **Player Education**: Helps players understand the threat\n\n**Use Cases:**\n- **Psychological Horror**: Creates intense observation-based gameplay\n- **Strategic Encounters**: Requires careful player movement and observation\n- **Escalation Scenarios**: Builds tension through alarm system\n- **Educational Gameplay**: Teaches players about observation mechanics\n\n**How It Works:**\n1. **Initialization**: SetupNPC() configures freeze-specific parameters\n2. **Observation Detection**: OnNPCSeenByPlayer() triggers freeze behavior\n3. **Stasis Activation**: PutInStasis() immobilizes the NPC completely\n4. **Alarm Timer**: CountAlarm() tracks observation duration\n5. **Observation Loss**: OnNPCLostByPlayer() triggers chase behavior\n6. **Chase Activation**: ReleaseFromStasis() and audio enable\n7. **Alarm Escalation**: Speed multiplier increases when alarmed\n8. **Hiding Response**: OnPlayerHidden() resets all states\n\n**Behavioral Flow:**\n1. **Initial State**: NPC in IDLE, ready to detect player\n2. **Player Observation**: NPC freezes completely, starts alarm timer\n3. **Continued Observation**: If 5+ seconds, NPC becomes alarmed\n4. **Observation Loss**: NPC immediately starts chasing\n5. **Alarmed Chase**: 3x speed pursuit until player hides\n6. **Player Hiding**: All states reset, NPC returns to IDLE\n7. **Cycle Repeat**: Process repeats with escalated threat level\n\n**Strategic Gameplay:**\n- **Observation Management**: Players must balance looking and moving\n- **Timing Awareness**: 5-second alarm threshold creates urgency\n- **Hiding Strategy**: Players must use hiding spots strategically\n- **Speed Awareness**: Alarmed state creates higher stakes\n\n**Technical Advantages:**\n- **Simplified Logic**: Easier to debug and maintain\n- **Event-Driven**: Efficient state management\n- **Stasis Integration**: Leverages engine capabilities\n- **Scalable Threat**: Configurable alarm threshold\n\n**Comparison with Traditional AI:**\n- **No Patrol**: Eliminates complex pathfinding\n- **Observation-Based**: Replaces traditional detection with line-of-sight\n- **Binary States**: Simplified IDLE/CHASE state machine\n- **Player-Driven**: Behavior entirely dependent on player actions\n\n**Development Benefits:**\n- **Clear Mechanics**: Easy to understand and implement\n- **Configurable**: Adjustable alarm threshold for balancing\n- **Modular Design**: Clean separation of concerns\n- **Event Integration**: Proper event system usage",
    "code": "using { /Fortnite.com/AI }\nusing { /Fortnite.com/Devices }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /Verse.org/Simulation }\nusing { /Verse.org/Simulation/Tags }\nusing { /Fortnite.com/Characters }\nusing { /Fortnite.com/Animation/PlayAnimation }\nusing { Entities }\n\n# A Verse-authored NPC Behavior that can be used within an NPC Character Definition or a NPC Spawner device's NPC Behavior Script Override.\nfreeze_npc_behavior := class(basic_enemy_npc_behaviour):\n\n    @editable\n    SecondsLookingUntilAlarmed: float = 5.0\n    var IsAlarmed: logic = false\n    var PlayerLookingAtMe: logic = false\n    var EntityName<override>: string = \"FREEZE\"\n    AllKillMessages<override>: []string = array {\n        # \"LOOK AT ME\",\n        # \"DON'T LOOK AWAY\",\n        # \"KEEP ME IN YOUR SIGHT\"\n        \"You have met Rogue.\\n\\nIt moves when you're not looking at it.\"\n    }\n\n    ResetNPC<override>(): void =\n        (super:)ResetNPC()\n        ToggleAlarmed(false)\n        set PlayerLookingAtMe = false\n\n    RunNPCStateMachine<override>()<suspends>: void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n            NPCFocus := NPCCharacter.GetFocusInterface[]\n            NPCNavigatable := NPCCharacter.GetNavigatable[]\n            # NPCAnimation := NPCCharacter.GetPlayAnimationController[]\n        then:\n            loop:\n                if(not NPCCharacter.IsActive[] or IsPlayerDead[]):\n                    PrintNPC(\"break state machine loop\")\n                    break\n                \n                case (CurrentNPCBehaviourState):\n                    NPC_BEHAVIOUR_STATE.IDLE =>\n                        ToggleAudio(false)\n                        NPCCharacter.PutInStasis(stasis_args{AllowTurning := false})\n                        # NPCAnimation.Pause()\n                        PrintNPC(\"NPC Idling\")\n                        Sleep(2.0)\n                    NPC_BEHAVIOUR_STATE.CHASE =>\n                        ToggleAudio(true)\n                        NPCCharacter.ReleaseFromStasis()\n                        DoAChase(NPCAgent, NPCCharacter, NPCFocus, NPCNavigatable)\n                    _ => # default\n                        PrintNPC(\"How RunNPCStateMachine reached here?\")\n                        break\n                \n                Sleep(0.5)\n\n    OnPlayerSeen<override>(Agent: agent): void =\n        PrintNPC(\"Player SEEN: {IsAlarmed.ToString()}\")\n        if(not IsAlarmed?):\n            (super:)OnPlayerSeen(Agent)\n\n    OnPlayerLost<override>(Agent: agent): void =\n        # if(not IsAlarmed?):\n        #     (super:)OnPlayerLost(Agent)\n        return\n\n    OnNPCSeenByPlayer<override>(Agent: agent): void =\n        if(not IsPlayerDead[]):\n            if(not IsAlarmed?):\n                PrintNPC(\"Player seeing, FREEZE!\")\n                set PlayerLookingAtMe = true\n                StopChasing()\n                # spawn{CountAlarm()}\n            else:\n                PrintNPC(\"Continue chase RUNNN\")\n\n    OnNPCLostByPlayer<override>(Agent: agent): void =\n        if(not IsPlayerDead[]):\n            if(not IsAlarmed?):\n                PrintNPC(\"Player not seeing, chase resume\")\n                PlayerStoppedLookingEvent.Signal()\n                set PlayerLookingAtMe = false\n                StartChasing()\n            else:\n                PrintNPC(\"Already chasing RUNNNNNN\")\n\n    StopChasing<override>(): void =\n        if(not IsPlayerDead[]):\n            PrintNPC(\"Stop chasing\")\n            if:\n                NPCAgent := GetAgent[]\n                NPCCharacter := NPCAgent.GetFortCharacter[]\n                NPCNavigatable := NPCCharacter.GetNavigatable[]\n            then:\n                # set IsPlayerSeen = false\n                ToggleAudio(false)\n                NPCNavigatable.StopNavigation()\n                SetNPCBehaviourState(NPC_BEHAVIOUR_STATE.IDLE)\n\n    # GetNextNPCBehaviourState<override>(): NPC_BEHAVIOUR_STATE =\n    #     var NextNPCBehaviourState: NPC_BEHAVIOUR_STATE = NPC_BEHAVIOUR_STATE.IDLE\n\n    #     case (CurrentNPCBehaviourState):\n    #         NPC_BEHAVIOUR_STATE.CHASE => \n    #             set NextNPCBehaviourState = NPC_BEHAVIOUR_STATE.IDLE\n    #         NPC_BEHAVIOUR_STATE.IDLE =>\n    #             set NextNPCBehaviourState = NPC_BEHAVIOUR_STATE.CHASE\n    #         _ => # default\n    #             PrintNPC(\"How GetNextNPCBehaviourState reached here?\")\n                \n    #     return NextNPCBehaviourState\n\n    ToggleAudio(Active: logic): void =\n        StopPlayingAllAudio()\n        if(ChaseAudio := NPCAudioDevices[0]):\n            if(Active?):\n                ChaseAudio.Play()\n            else:\n                ChaseAudio.Stop()\n\n    CountAlarm()<suspends>: void =\n        race:\n            block:\n                Sleep(SecondsLookingUntilAlarmed)\n                if(not IsAlarmed? and PlayerLookingAtMe?):\n                    ToggleAlarmed(true)\n                    StartChasing()\n            block:\n                PlayerStoppedLookingEvent.Await()\n\n    ToggleAlarmed(NewAlarmed: logic): void =\n        if:\n            NPCAgent := GetAgent[]\n            NPCCharacter := NPCAgent.GetFortCharacter[]\n            NPCFocus := NPCCharacter.GetFocusInterface[]\n            NPCNavigatable := NPCCharacter.GetNavigatable[]\n        then:\n            set IsAlarmed = NewAlarmed\n            PrintNPC(\"Freeze alarmed? {IsAlarmed.ToString()}\")\n            if(IsAlarmed?):\n                NPCNavigatable.SetMovementSpeedMultiplier(3.0)\n            else:\n                NPCNavigatable.SetMovementSpeedMultiplier(1.0)\n                \n    OnPlayerHidden<override>(EventHideSuccessData: event_player_hide_success): void =\n        if(CurrentNPCBehaviourState = NPC_BEHAVIOUR_STATE.CHASE):\n            StopChasing()\n        set NPCEntityData.ReactsToPlayer = false\n        ToggleAlarmed(false)\n\n    # GetPlayerDeathCutsceneView<override>(): transform =\n    #     return PlayerDeathCutsceneViewOnlyRotation()",
    "external_calls": [
      "basic_enemy_npc_behaviour",
      "agent",
      "fort_character",
      "focus_interface",
      "navigatable",
      "play_animation_controller",
      "stasis_args",
      "audio_player_device",
      "event_player_hide_success",
      "NPC_BEHAVIOUR_STATE",
      "PlayerStoppedLookingEvent",
      "PrintNPC",
      "Sleep"
    ]
  }
] 