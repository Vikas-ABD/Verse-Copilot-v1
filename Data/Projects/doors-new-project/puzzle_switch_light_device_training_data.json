[
  {
    "file_name": "puzzle_switch_light_device.verse",
    "questions": [
      "How do I implement a 'Lights Out' puzzle in Verse with randomized switch configurations?",
      "What is the code for a puzzle where buttons toggle multiple lights, and the puzzle is solved when all lights are on?",
      "I need a script for a switch-based puzzle that inherits from a 'puzzle_base' and communicates with a 'global_event_channel'.",
      "How can I create a puzzle with a move counter and visual feedback for puzzle state changes?"
    ],
    "explanation": "This script implements a 'Lights Out' style puzzle. The player interacts with a series of switches (`switch_light_button`), and each switch toggles the state of a predefined set of lights (`switch_light`). The goal is to turn all the lights on simultaneously. A key feature of this puzzle is that the connections between switches and lights are randomized at the start of each round, providing replayability.\n\n**Core Components:**\n- `puzzle_switch_light_device`: The main class that orchestrates the puzzle. It inherits from `puzzle_base` and manages the puzzle's state, setup, validation, and completion.\n- `switch_light_button`: A class representing an individual switch. It uses a `mutator_zone_device` for player interaction and holds references to the lights it controls.\n- `switch_light`: A class representing an individual light. It wraps a `customizable_light_device` and manages its on/off state (`CurrentState`).\n\n**Key Features:**\n1. **Randomized Configuration**: On `OnBegin`, the `SwitchToLightConnection` map (which defines which lights each switch toggles) is shuffled using `Shuffle()`. This ensures the puzzle solution is different each time.\n2. **Event-Driven Logic**: The puzzle uses a `global_event_channel` for communication. When a `switch_light_button` is pressed, it broadcasts a `PLAYER_SWITCHED_LIGHT` event. The main `puzzle_switch_light_device` listens for this event to check the puzzle's status.\n3. **State Management**: Each `switch_light` has a `CurrentState` (on/off). The `PuzzleAnswerValidationCheck` method iterates through all lights to see if they are all on, determining if the puzzle is solved.\n4. **Visual and Audio Feedback**: The script uses `audio_player_device`, `vfx_spawner_device`, and `prop_mover_device` to provide rich feedback for events like solving the puzzle, pressing a switch, and door animations.\n5. **Move Limit (Concept)**: The script includes variables like `MoveLimit` and `MoveExcededVFX`, suggesting an intended mechanic to limit player moves, although the core logic for counting moves and triggering consequences is not fully implemented in the provided code snippet (`MoveCounter` is declared but not incremented).\n6. **Reset Functionality**: A dedicated `ResetButton` allows the player to reset the puzzle to its initial (shuffled) state. The `PuzzleReset` function handles cleaning up and re-initializing the puzzle.\n\n**Workflow:**\n1. **Initialization**: `OnBegin` calls `Setup`, subscribes to necessary events, shuffles the `SwitchToLightConnection` array, and calls `InitialLightSetup` and `SetupConnections`.\n2. **Connection Setup**: `SetupConnections` iterates through the shuffled connection map and assigns the correct `switch_light` instances to each `switch_light_button`.\n3. **Player Interaction**: The player steps on a `mutator_zone_device` associated with a `switch_light_button`. This calls `OnSwitchPressed`.\n4. **State Change**: `OnSwitchPressed` toggles all its connected lights and broadcasts the `PLAYER_SWITCHED_LIGHT` event.\n5. **Validation**: The `puzzle_switch_light_device` receives the event via `OnButtonSwitched`, plays an audio cue, and calls `PuzzleAnswerValidationCheck`.\n6. **Puzzle Solved**: If all lights are on, `OnPuzzleSolved` is triggered. This disables all switch interactions, plays success audio, and initiates a sequence to open the doors.\n7. **Reset**: If the player interacts with the `ResetButton`, the `OnResetButtonPressed` function calls `Reset()` on every light, restoring their initial states. The game run itself can also trigger a full `PuzzleReset`.\n\n**Use Cases:**\n- Implementing logic puzzles like 'Lights Out'.\n- Creating interactive puzzles with randomized solutions for replayability.\n- A template for complex switch-and-gate mechanics in adventure or escape room games.",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /Verse.org/Random }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\n\n# https://en.wikipedia.org/wiki/Lights_Out_(game)\n# https://dev.epicgames.com/documentation/en-us/uefn/tagged-lights-puzzle-in-verse\n\nswitch_light_button := class(room_event_communicator):\n    @editable\n    Button : mutator_zone_device = mutator_zone_device{}\n    @editable\n    ButtonProp : creative_prop = creative_prop{}\n\n    var ConnectedLights : []switch_light = array{}\n    var ButtonEventCancelable : ?cancelable = false\n    var ExitEventCancelable : ?cancelable = false\n    var ButtonPropTranslation : vector3 = vector3{}\n\n    Setup<override>(NewGlobalEventChannel : global_event_channel): void=\n        (super:)Setup(NewGlobalEventChannel)\n        set ButtonEventCancelable = option{Button.AgentEntersEvent.Subscribe(OnSwitchPressed)}\n        set ExitEventCancelable = option{Button.AgentEntersEvent.Subscribe(OnSwitchUnPressed)}\n        set ButtonPropTranslation = ButtonProp.GetTranslation()\n\n    CancelInteractionEvent() : void=\n        if(Cancelable := ButtonEventCancelable?):\n            Cancelable.Cancel()\n        if(Cancelable := ExitEventCancelable?):\n            Cancelable.Cancel()\n        Button.Disable()\n        set ConnectedLights = array{}\n    \n    OnSwitchPressed(Agent : agent): void=\n        for(Light : ConnectedLights):\n            Light.ToggleLight()\n        GlobalEventChannel.RoomEventChannel.BroadcastChannel(event_names.PLAYER_SWITCHED_LIGHT, event_data{}, option{Agent})\n        spawn:\n            PlayButtonInteractionAsthetics(Agent)\n\n    OnSwitchUnPressed(Agent : agent): void=\n        spawn:\n            OnSwitchExit()\n    \n    PlayButtonInteractionAsthetics(Agent : agent)<suspends> : void=\n        # Button.Disable()\n        # MoveTranslation := vector3{X := ButtonTranslation.X, Y := ButtonTranslation.Y - 10.0, Z := ButtonTranslation.Z}\n        ButtonProp.MoveTo(ButtonPropTranslation + (-10.0), 0.2)\n\n    OnSwitchExit()<suspends> : void=\n        ButtonProp.MoveTo(ButtonPropTranslation, 0.2)\n        # Button.Enable()\n\n    Reset() : void=\n        set ConnectedLights = array{}\n        Button.Enable()\n        set ButtonEventCancelable = option{Button.AgentEntersEvent.Subscribe(OnSwitchPressed)}\n\nswitch_light := class:\n    @editable\n    Light : customizable_light_device = customizable_light_device{}\n\n    @editable\n    LightSourceTrigger : trigger_device = trigger_device{}\n\n    @editable\n    InitialState : logic = false\n    var CurrentState : logic = false\n\n    ToggleLight() : void=\n        if(CurrentState?):\n            set CurrentState = false\n        else:\n            set CurrentState = true\n        LightSourceTrigger.Trigger()\n        Light.Toggle()\n\n    TurnOff(): void=\n        if(CurrentState?):\n            LightSourceTrigger.Trigger()\n            Light.Toggle()\n\n    Initialize() : void=\n        if(InitialState?):\n            LightSourceTrigger.Trigger()\n            Light.Toggle()\n            set CurrentState = true\n\n    Reset() : void=\n        if(CurrentState? and not InitialState?):\n            LightSourceTrigger.Trigger()\n            Light.Toggle()\n            set CurrentState = false\n\npuzzle_switch_light_device := class(puzzle_base):\n    var NamePuzzle<override> : puzzle_names = puzzle_names.SWITCH_LIGHT\n\n    # min-max 4 lights and switches\n\n    @editable\n    SwitchButtons : []switch_light_button = array{}\n\n    @editable\n    SwitchLights : []switch_light = array{} \n\n    @editable\n    DoorPropMovers : []prop_mover_device = array{}\n\n    @editable\n    CameraShakeProp : creative_prop = creative_prop{}\n\n    @editable\n    DoorPropMoveAudio : audio_player_device = audio_player_device{}\n\n    @editable\n    DoorPropMoveVFX : vfx_spawner_device = vfx_spawner_device{}\n    \n    @editable\n    MoveLimitBars : []creative_prop = array{}\n    \n    @editable\n    MoveLimit : int = 12\n\n    @editable\n    MoveExcededVFX : []vfx_spawner_device = array{}\n\n    @editable\n    MoveExcededPPVolume : post_process_device = post_process_device{}\n\n    @editable\n    MoveExcededSwitchAudio : audio_player_device = audio_player_device{}\n\n    @editable\n    MoveExcededMoveAudio : audio_player_device = audio_player_device{}\n\n    @editable\n    LightSwitchAudio : audio_player_device = audio_player_device{}\n\n    @editable\n    PuzzleSolvedAudio : audio_player_device = audio_player_device{}\n\n    @editable\n    ResetButton : mutator_zone_device = mutator_zone_device{}\n\n    var SwitchToLightConnection :[][]int = array{\n        array{0, 3},\n        array{0, 1},\n        array{2, 3},\n        array{0, 1, 3}\n    }\n    # var SwitchToLightConnection :[][]int = array{\n    #     array{0, 1},\n    #     array{1, 2, 3},\n    #     array{0, 2, 4},\n    #     array{3, 5},\n    #     array{1, 4, 5},\n    #     array{0, 3, 5}\n    # }\n\n    var MoveCounter : int = 0\n    # Runs when the device is started in a running game\n    OnBegin<override>()<suspends>:void=\n\n        # finding Global Event Channel\n        Setup()\n        \n        for(SwitchButton : SwitchButtons):\n            SwitchButton.Setup(GlobalEventChannel)\n\n        # Subscribing To Event when player pressed any of the switches\n        # set EventCancelables += array{GlobalEventChannel.RoomEventChannel.SubscribeChannel(OnButtonSwitched)}\n        SubscribeToRoomEvent(OnButtonSwitched, \"puzzle_switch_light\")\n\n        # Shuffling Switch Configurations\n        set SwitchToLightConnection = Shuffle(SwitchToLightConnection)\n\n        # Setting Up Initial State of the Lights\n        InitialLightSetup()\n        \n        # Setting Up Connection Between Lights ans Switches, According to Configuration\n        SetupConnections()\n\n        SubscribeToPlayerEvent(PuzzleResetReceived, \"puzzle_switch_light\")\n\n        SubscribeToDeviceEvent(\"puzzle_switch_light_reset\",ResetButton.AgentEntersEvent.Subscribe(OnResetButtonPressed))\n\n    OnResetButtonPressed(Agent : agent) : void=\n        for(SwitchLight : SwitchLights):\n            SwitchLight.Reset()\n\n    PuzzleResetReceived(EventName : event_names, EventData : event_data, EventAgent : ?agent) : void=\n        # Print(\"PuzzleReset Base\", ?Duration:=6.0)\n        case (EventName):\n            event_names.PLAYER_END_RUN =>\n                spawn:\n                    PuzzleReset()\n            event_names.PLAYER_START_RUN =>\n                spawn:\n                    PuzzleReset()\n            _ =>\n\n    OnButtonSwitched(EventName: event_names, Data: event_data, Agent: ?agent) : void=\n        case (EventName):\n            event_names.PLAYER_SWITCHED_LIGHT => SwitchPressed()\n            _ => return\n    \n    SwitchPressed() : void=\n        LightSwitchAudio.Play()\n        IsPuzzleSolved := PuzzleAnswerValidationCheck()\n\n        if(IsPuzzleSolved?):\n            OnPuzzleSolved()\n\n    PuzzleAnswerValidationCheck<override>() : logic=\n        for(SwitchLight : SwitchLights):\n            if(not SwitchLight.CurrentState?):\n                return false\n        return true\n        \n    OnPuzzleSolved<override>(): void=\n        (super:)OnPuzzleSolved()\n        PuzzleSolvedAudio.Play()\n        MoveExcededPPVolume.Disable()\n        spawn:\n            PostSolvedEffects()\n        for(SwitchButton : SwitchButtons):\n            SwitchButton.CancelInteractionEvent()\n\n    PostSolvedEffects()<suspends> : void=\n        CSTransform := CameraShakeProp.GetTransform()\n        CameraShakeProp.MoveTo(DoorPropMoveAudio.GetTransform(), 0.1)\n        Sleep(3.0)\n        DoorPropMoveAudio.Play()\n        DoorPropMoveVFX.Enable()\n        for(PropMover : DoorPropMovers):\n            PropMover.Begin()\n        Sleep(5.0)\n        option:\n            CameraShakeProp.TeleportTo[CSTransform]\n\n    InitialLightSetup(): void=\n        for(SwitchLight : SwitchLights):\n            SwitchLight.Initialize()\n            \n    SetupConnections() : void=\n        var SwitchToButtonIndex : int = 0\n        for(Index->SwitchButton : SwitchButtons):\n            for(LightConnection : SwitchToLightConnection[Index]):\n                option:\n                    set SwitchButton.ConnectedLights += array{SwitchLights[LightConnection]}\n\n    PuzzleReset()<suspends> : void=\n        Print(\"Reseting Light Out Puzzle\", ?Duration:=6.0)\n\n        for(Button : SwitchButtons):\n            Button.Reset()\n        for(Light : SwitchLights):\n            Light.Reset()\n        for(DoorPropMover : DoorPropMovers):\n            DoorPropMover.Reset()\n\n        DoorPropMoveVFX.Disable()\n        MoveExcededPPVolume.Disable()\n        set MoveCounter = 0\n\n        # Subscribing To Event when player pressed any of the switches\n        SubscribeToRoomEvent(OnButtonSwitched, \"puzzle_switch_light\")\n        # Shuffling Switch Configurations\n        set SwitchToLightConnection = Shuffle(SwitchToLightConnection)\n        # Setting Up Connection Between Lights ans Switches, According to Configuration\n        SetupConnections()\n\n        SubscribeToDeviceEvent(\"puzzle_switch_light_reset\",ResetButton.AgentEntersEvent.Subscribe(OnResetButtonPressed))\n",
    "external_calls": [
      "agent",
      "audio_player_device",
      "Begin",
      "BroadcastChannel",
      "Cancel",
      "cancelable",
      "creative_prop",
      "customizable_light_device",
      "Disable",
      "Enable",
      "event_data",
      "event_names",
      "GetTransform",
      "GetTranslation",
      "global_event_channel",
      "Initialize",
      "int",
      "logic",
      "MoveTo",
      "mutator_zone_device",
      "OnBegin",
      "OnPuzzleSolved",
      "OnResetButtonPressed",
      "Play",
      "PostSolvedEffects",
      "post_process_device",
      "Print",
      "prop_mover_device",
      "puzzle_base",
      "puzzle_names",
      "Reset",
      "room_event_communicator",
      "Setup",
      "Shuffle",
      "Sleep",
      "spawn",
      "Subscribe",
      "SubscribeToDeviceEvent",
      "SubscribeToPlayerEvent",
      "SubscribeToRoomEvent",
      "TeleportTo",
      "Toggle",
      "ToggleLight",
      "Trigger",
      "TurnOff",
      "vector3",
      "vfx_spawner_device"
    ]
  }
] 