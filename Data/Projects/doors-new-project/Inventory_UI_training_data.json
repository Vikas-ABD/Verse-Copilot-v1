[
  {
    "file_name": "Inventory_UI.verse",
    "questions": [
      "How do I create a hotbar-style inventory system in Verse?",
      "What is the code for an inventory UI where players can scroll to select items and left-click to use them?",
      "I need a script that can handle different item types, like consumables and equipables, with custom logic for each.",
      "How can I design an extensible item system with base classes like `item_function`, `item_consumable`, and `item_equipable`?"
    ],
    "explanation": "This script implements a flexible, hotbar-style inventory system. It allows players to carry multiple items, select them using the scroll wheel, and use them with a mouse click. The system is highly extensible, supporting different item behaviors (e.g., consumables that restore health/shields, equipables like a flashlight) through an object-oriented class structure. The UI is dynamically generated and displayed on the player's screen.\n\n**Core Components:**\n- `inventory_ui`: The main device that manages the entire system. It handles player input for scrolling and item use, manages the UI state, and grants new items to the player.\n- `item_ui_slot`: Represents a single slot in the hotbar UI. It manages the visual state (equipped/unequipped) and holds a reference to the `inventory_item` it contains.\n- `inventory_item`: Defines the properties of an item, such as its name, type (consumable or equipable), and icon. Crucially, it holds a reference to an `item_function` class that defines its behavior.\n- `item_function`: A base class for all item behaviors. It has two main subclasses:\n  - `item_consumable`: For single-use items that affect player stats (e.g., health, shield).\n  - `item_equipable`: For items that have persistent or repeated actions. This is further subclassed into specific items like `item_flashlight`, `item_nitro`, and `item_lockpick`.\n\n**Key Features:**\n1. **Extensible Item System**: The use of inheritance (`item_function`, `item_consumable`, `item_equipable`) makes it easy to add new items with unique functionality without changing the core inventory logic. You simply create a new class that inherits from `item_equipable` or `item_consumable` and implement its `OnItemActionPerformed` or `OnItemConsumed` method.\n2. **Dynamic Hotbar UI**: The UI is built dynamically in `MakeUI` based on the number of items defined in the `Items` array. Each slot is an `overlay` of several textures and color blocks to create an outline and selection effect.\n3. **Scroll Wheel Selection**: The `OnScrollWheelUp` and `OnScrollWheelDown` functions handle item selection. They cycle through the available item slots, skipping empty ones, and update the visual state of the slots to show which item is currently equipped.\n4. **Event-Driven Actions**: Many item actions, like toggling the flashlight or using a lockpick, are communicated to other game systems via the `GlobalEventChannel`, allowing for a decoupled and scalable architecture.\n5. **Polymorphic Item Usage**: When the player uses an item, the script checks if it's consumable or equipable and calls the appropriate function (`OnItemConsumed` or `OnItemActionPerformed`) on the item's `ItemFunction` instance. This allows the core logic to handle any item type generically.\n\n**Workflow:**\n1. **Initialization**: On `OnBegin`, the `inventory_ui` device calls `MakeUI` to create the hotbar canvas and adds it to the player's screen. It then subscribes to input events for the scroll wheel and mouse clicks.\n2. **Granting Items**: The `GrantCustomItem` function (triggered by a button for demonstration) randomly selects an item and calls `AddItemToUI` to place it in the next available slot.\n3. **Item Selection**: The player uses the scroll wheel. `OnScrollWheelUp` or `OnScrollWheelDown` is called. The currently active slot is unequipped, the next valid slot is found, and that slot is equipped. The `ActiveItemSlot` variable is updated.\n4. **Item Usage**: The player left-clicks. `OnMouseLeftClick` calls `PerformActions` on the `ActiveItemSlot`. \n5. **Action Execution**: `PerformActions` determines the item's type. If it's a consumable, `OnItemConsumed` is called immediately. If it's an equipable, `OnItemActionPerformed` is called in a new coroutine (`spawn`).\n\n**Use Cases:**\n- A standard hotbar for player items in an adventure or survival game.\n- A framework for creating a wide variety of tools and consumables with unique behaviors.\n- A template for managing player input for item selection and usage.",
    "code": "using { /Fortnite.com/Devices }\nusing { /Fortnite.com/Characters }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /UnrealEngine.com/Temporary/UI}\nusing { /UnrealEngine.com/Temporary/SpatialMath}\nusing { /Fortnite.com/UI }\nusing { /Verse.org/Random }\nusing { /Verse.org/Assets }\nusing { /Verse.org/Colors }\n\nitem_function := class(event_communicator):\nitem_consumable := class(item_function):\n    @editable\n    ItemHealthValue : float = 0.0\n    @editable\n    ItemShieldValue : float = 0.0\n    OnItemConsumed(Agent : agent) : logic = \n        if:\n            Player := player[Agent]\n            FortCharacter := Player.GetFortCharacter[]\n            CurrentShield := FortCharacter.GetShield()\n            CurrentHealth := FortCharacter.GetHealth()\n        then:\n            FortCharacter.SetShield(CurrentShield + ItemShieldValue)\n            FortCharacter.SetHealth(CurrentShield + ItemHealthValue)\n            return true\n        return false\n        \nitem_equipable := class(item_function):\n    @editable\n    ItemActionLimit : int = 0 # means infinite\n    OnItemActionPerformed(Agent : agent)<suspends> : logic = false\n\nitem_flashlight := class(item_equipable):\n    @editable\n    var AvailibleUnits : float = 0.0\n    @editable\n    var UnitConsumptionRate : float = 0.0\n    var CurrentFlashlightState : logic = false\n    OnItemActionPerformed<override>(Agent : agent)<suspends> : logic=\n        if(not CurrentFlashlightState?):\n            set CurrentFlashlightState = true\n            spawn:\n                ConsumeUnits()\n        else:\n            set CurrentFlashlightState = false\n        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_FLASHLIGHT_TOGGLE, event_data{}, option{Agent})\n        return true\n    \n    ConsumeUnits()<suspends> : void=\n        loop:\n            if(AvailibleUnits <= 0.0):\n                #-----------Remove Item-------------------\n                break\n            if(not CurrentFlashlightState?):\n                break\n            Sleep(1.0)\n            set AvailibleUnits -= UnitConsumptionRate\nitem_nitro := class(item_equipable):\n    PlayerSpeedModifierDevice : movement_modulator_device\n    OnItemActionPerformed<override>(Agent : agent)<suspends> : logic=\n        PlayerSpeedModifierDevice.Activate(Agent)\n        return true\n\nitem_lockpick := class(item_equipable):\n    EventHandle : event(logic) = event(logic){}\n    OnItemActionPerformed<override>(Agent : agent)<suspends> : logic=\n        GlobalEventChannel.PlayerEventChannel.SubscribeChannel(OpenDoor)\n        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.LOCKPICK_PERFORM, event_data{}, option{Agent})\n        IsLockPicked := EventHandle.Await()\n        return IsLockPicked\n    OpenDoor(EventName : event_names, EventData : event_data, Agent : ?agent) : void=\n        case (EventName):\n            # event_names.LOCKPICK_RESULT =>\n            #     if(Data := event_lockpick_result[EventData], Data.Result?):\n            #         EventHandle.Signal(Data.Result)\n            #         #-------------Remove Item-------------------\n            _ => # default\n                Print(\"Default case body\")\n\ninventory_item := class(event_communicator):\n    @editable\n    ItemName : item_name = item_name.KEY\n    @editable\n    ItemType : item_type = item_type.CONSUMABLE\n    @editable\n    ItemIcon : texture = Textures_01.potion\n    @editable\n    ItemFunction : item_function = item_function{}\n\n    var IsItemGranted : logic = false\n\n    IsConsumable()<transacts> : logic=\n        case (ItemType):\n            item_type.CONSUMABLE => true\n            _ => false\n\n    GetConsumableItemFunction() : item_consumable=\n        if:\n            Item := item_consumable[ItemFunction]\n        then:\n            return Item\n        return item_consumable{}\n    GetEquipableItemFunction() : item_equipable=\n        if:\n            Item := item_equipable[ItemFunction]\n        then:\n            return Item\n        return item_equipable{}\n\nitem_ui_slot := class<unique>:\n    var Overlay : overlay = overlay{}\n    var IsSlotHasItem : logic = false\n    var IsItemEquiped : logic = false\n    var CurrentItem : ?inventory_item = false\n\n    ActiveSize : vector2 = vector2{X := 85.0, Y := 85.0}\n    InActiveSize : vector2 = vector2{X := 80.0, Y := 80.0}\n    ColorOverlay : color_block = color_block {DefaultColor := NamedColors.LightSkyBlue}\n    OutlineTextureBlock : texture_block = texture_block{DefaultImage := Textures_01.LoadOutoverlay}\n    ItemIconTextureBlock : texture_block = texture_block{DefaultImage := Textures_01.LoadOutoverlay}\n\n    EnableSlot(Item : inventory_item): void=\n        ItemIconTextureBlock.SetImage(Item.ItemIcon)\n        ItemIconTextureBlock.SetVisibility(widget_visibility.Visible)\n        ColorOverlay.SetVisibility(widget_visibility.Visible)\n        set IsSlotHasItem = true\n        set Item.IsItemGranted = true\n        set CurrentItem = option{Item}\n\n    PerformActions(Agent : agent) : void=\n        if(GetItem := CurrentItem?):\n            if(GetItem.IsConsumable()?):\n                ConsumableItemFuntion := GetItem.GetConsumableItemFunction()\n                ConsumableItemFuntion.OnItemConsumed(Agent)\n            else:\n                EquipableItemFuntion := GetItem.GetEquipableItemFunction()\n                spawn:\n                    EquipableItemFuntion.OnItemActionPerformed(Agent)\n\n    GetOverlay(PaddingBottom : float) : overlay=\n        ColorOverlay.SetDesiredSize(InActiveSize)\n        OutlineTextureBlock.SetDesiredSize(ActiveSize)\n        ItemIconTextureBlock.SetDesiredSize(InActiveSize)\n        set Overlay = overlay:\n            Slots := array:\n                overlay_slot:\n                    Padding := margin{Right := 20.0, Bottom := PaddingBottom}\n                    HorizontalAlignment := horizontal_alignment.Center\n                    VerticalAlignment := vertical_alignment.Center\n                    Widget := ColorOverlay\n                overlay_slot:\n                    Padding := margin{Right := 20.0, Bottom := PaddingBottom}\n                    HorizontalAlignment := horizontal_alignment.Center\n                    VerticalAlignment := vertical_alignment.Center\n                    Widget := OutlineTextureBlock\n                overlay_slot:\n                    Padding := margin{Right := 20.0, Bottom := PaddingBottom}\n                    HorizontalAlignment := horizontal_alignment.Center\n                    VerticalAlignment := vertical_alignment.Center\n                    Widget := ItemIconTextureBlock\n        return Overlay\n    \n    Equip() : void=\n        set IsItemEquiped = true\n        ColorOverlay.SetDesiredSize(ActiveSize)\n        ItemIconTextureBlock.SetDesiredSize(ActiveSize)\n    UnEquip() : void=\n        set IsItemEquiped = false\n        ColorOverlay.SetDesiredSize(InActiveSize)\n        ItemIconTextureBlock.SetDesiredSize(InActiveSize)\n    \ninventory_ui := class(event_communicator_device):\n    @editable\n    LeftMouseClickInput : input_trigger_device = input_trigger_device{}\n    @editable\n    RightMouseClickInput : input_trigger_device = input_trigger_device{}\n    @editable\n    ScrollWheelUp : input_trigger_device = input_trigger_device{}\n    @editable\n    ScrollWheelDown : input_trigger_device = input_trigger_device{}\n    @editable\n    PlayerSpeedModifier : movement_modulator_device = movement_modulator_device{}\n    @editable\n    Button : button_device = button_device{}\n    @editable\n    Items : []inventory_item = array{}\n\n    var ItemUISlots : []item_ui_slot = array{}\n    var ItemCanvas : canvas = canvas{}\n    var ItemIndex : int = 0\n    var ActiveItemIndex : int = 0\n    var TotalItemCount : int = 0\n    var ActiveItemSlot : item_ui_slot = item_ui_slot{}\n\n    OnBegin<override>()<suspends> : void=\n        # Finding Global Event Channel\n        Setup()\n        MakeUI()\n        ScrollWheelUp.PressedEvent.Subscribe(OnScrollWheelUp)\n        ScrollWheelDown.PressedEvent.Subscribe(OnScrollWheelDown)\n        LeftMouseClickInput.PressedEvent.Subscribe(OnMouseLeftClick)\n        RightMouseClickInput.PressedEvent.Subscribe(OnMouseRightClick)\n        Button.InteractedWithEvent.Subscribe(GrantCustomItem)\n        AddHandToUI()\n\n    OnScrollWheelUp(Agent : agent) : void=\n        var ActiveIndexTrackStart : int = ActiveItemIndex + 1\n        if(ActiveIndexTrackStart > TotalItemCount - 1):\n            set ActiveIndexTrackStart = 0\n        for(Index := 0..(TotalItemCount-1)):\n            if(Index = ActiveIndexTrackStart):\n                if(GetSlot := ItemUISlots[Index], GetSlot.IsSlotHasItem?):\n                    ActiveItemSlot.UnEquip()\n                    GetSlot.Equip()\n                    set ActiveItemIndex = ActiveIndexTrackStart\n                    set ActiveItemSlot = GetSlot\n                    Print(\"ItemEquipedUp: {Index}\", ?Duration:=6.0)\n                else:\n                    set ActiveIndexTrackStart += 1\n                \n\n    OnScrollWheelDown(Agent : agent) : void=\n        var ActiveIndexTrackStart : int = ActiveItemIndex - 1\n        if(ActiveIndexTrackStart < 0):\n            set ActiveIndexTrackStart = TotalItemCount - 1\n        for(Index := 0..(TotalItemCount - 1)):\n            if(Index = ActiveIndexTrackStart):\n                if(GetSlot := ItemUISlots[Index], GetSlot.IsSlotHasItem?):\n                    GetSlot.Equip()\n                    ActiveItemSlot.UnEquip()\n                    set ActiveItemSlot = GetSlot\n                    set ActiveItemIndex = ActiveIndexTrackStart\n                    Print(\"ItemEquipedDown: {Index}\", ?Duration:=6.0)\n                else:\n                    set ActiveIndexTrackStart -= 1\n                \n\n    OnMouseLeftClick(Agent : agent) : void=\n        if(ActiveItemSlot.IsSlotHasItem?):\n            ActiveItemSlot.CurrentItem\n    OnMouseRightClick(Agent : agent) : void=\n        Print(\"RightMouseClick\", ?Duration:=6.0)\n\n    GrantCustomItem(Agent : agent) : void=\n        set ItemIndex = GetRandomInt(1,Items.Length - 1)\n        AddItemToUI()\n\n    IncreaseHealth(Health : float) : logic=\n        if:\n            Player := GetPlayspace().GetPlayers()[0]\n            FortCharacter := Player.GetFortCharacter[]\n            CurrentHealth := FortCharacter.GetHealth()\n        then:\n            FortCharacter.SetHealth(CurrentHealth + Health)\n            return true\n        return false\n\n    IncreaseShield(Shield : float) : logic=\n        if:\n            Player := GetPlayspace().GetPlayers()[0]\n            FortCharacter := Player.GetFortCharacter[]\n            CurrentShield := FortCharacter.GetShield()\n        then:\n            FortCharacter.SetShield(CurrentShield + Shield)\n            return true\n        return false\n\n    IncreaseSpeed(Agent : agent) : logic=\n        PlayerSpeedModifier.Activate(Agent)\n        return true\n\n    TurnOnFlashLight(Agent : agent) : void=\n        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_FLASHLIGHT_TOGGLE, event_data{}, option{Agent})\n        \n\n    AddHandToUI() : void=\n        if(ItemSlot := ItemUISlots[0], Icon := Items[0].ItemIcon):\n            ItemSlot.ItemIconTextureBlock.SetImage(Icon)\n            ItemSlot.ItemIconTextureBlock.SetVisibility(widget_visibility.Visible)\n            ItemSlot.ColorOverlay.SetVisibility(widget_visibility.Visible)\n            set ItemSlot.IsSlotHasItem = true\n            set ActiveItemSlot = ItemSlot\n            ItemSlot.Equip()\n\n    AddItemToUI() : void=\n        for(ItemSlotIndex := 1..ItemUISlots.Length-1):\n            if:\n                ItemSlot := ItemUISlots[ItemSlotIndex]\n                not ItemSlot.IsSlotHasItem?\n                GetItem := Items[ItemIndex]\n                not GetItem.IsItemGranted?\n            then:\n                ItemSlot.EnableSlot(GetItem)\n                return\n\n    MakeUI() : void=\n        set ItemCanvas = canvas:\n            Slots := GetCanvasSlots(Items.Length)\n        if:\n            Player := GetPlayspace().GetPlayers()[0]\n            PlayerUI := GetPlayerUI[Player]\n        then:\n            PlayerUI.AddWidget(ItemCanvas)\n        set TotalItemCount = ItemUISlots.Length\n        Print(\"Total Items : {TotalItemCount}\", ?Duration:=6.0)\n\n    GetCanvasSlots(Count : int) : []canvas_slot=\n        var CanvasSlots : []canvas_slot = array{}\n        var PaddingTrack : float = 20.0\n        for(I := 1..Count):\n            MakeUISlot : item_ui_slot = item_ui_slot{}\n            MakeUISlot.ItemIconTextureBlock.SetVisibility(widget_visibility.Hidden)\n            MakeUISlot.ColorOverlay.SetVisibility(widget_visibility.Hidden)\n            set CanvasSlots += array{\n                canvas_slot:\n                    Anchors:=anchors{Minimum:=vector2{X:=1.0,Y:=1.0},Maximum:=vector2{X:=1.0,Y:=1.0}}\n                    Alignment:=vector2{X:=1.0,Y:=1.0}}\n                    SizeToContent:=true\n                    Widget := MakeUISlot.GetOverlay(PaddingTrack)\n            }\n            set PaddingTrack += 55.0\n            set ItemUISlots += array{MakeUISlot}\n\n        return CanvasSlots",
    "external_calls": [
      "event_communicator",
      "player",
      "fort_character",
      "GetFortCharacter",
      "GetShield",
      "GetHealth",
      "SetShield",
      "SetHealth",
      "agent",
      "logic",
      "item_equipable",
      "spawn",
      "GlobalEventChannel",
      "PlayerEventChannel",
      "BroadcastChannel",
      "event_names",
      "event_data",
      "loop",
      "Sleep",
      "movement_modulator_device",
      "Activate",
      "event",
      "SubscribeChannel",
      "Await",
      "Signal",
      "Print",
      "inventory_item",
      "item_name",
      "item_type",
      "texture",
      "item_function",
      "item_consumable",
      "overlay",
      "vector2",
      "color_block",
      "NamedColors",
      "texture_block",
      "widget_visibility",
      "SetImage",
      "SetVisibility",
      "overlay_slot",
      "margin",
      "horizontal_alignment",
      "vertical_alignment",
      "SetDesiredSize",
      "event_communicator_device",
      "input_trigger_device",
      "button_device",
      "canvas",
      "item_ui_slot",
      "OnBegin",
      "Setup",
      "MakeUI",
      "PressedEvent",
      "Subscribe",
      "InteractedWithEvent",
      "AddHandToUI",
      "OnScrollWheelUp",
      "UnEquip",
      "Equip",
      "OnScrollWheelDown",
      "OnMouseLeftClick",
      "OnMouseRightClick",
      "GetRandomInt",
      "AddItemToUI",
      "GetPlayspace",
      "GetPlayers",
      "EnableSlot",
      "GetCanvasSlots",
      "GetPlayerUI",
      "AddWidget"
    ]
  }
] 