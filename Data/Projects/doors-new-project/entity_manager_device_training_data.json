[
  {
    "file_name": "entity_manager_device.verse",
    "questions": [
      "How can I create an entity manager device that orchestrates all NPC behaviors and manages their lifecycle in Verse?",
      "What is the Verse code for implementing a centralized entity management system with event-driven spawning and cleanup?",
      "I need a script that handles multiple entity types with different data structures and spawn configurations.",
      "How do I create an entity manager that coordinates with game manager and global event channel for horror game NPCs?"
    ],
    "explanation": "This script provides a comprehensive entity management system that serves as the central orchestrator for all NPC behaviors in a horror game. It manages the complete lifecycle of multiple entity types (SEEK, RUSH, FREEZE, FIGURE, BLINK, EYES), handles event-driven spawning and cleanup, coordinates with the game manager and global event channel, and provides specialized data structures for each entity type.\n\n**Core Components:**\n- entity_manager_device: Main orchestrator extending event_communicator_device\n- Multiple entity data classes for different NPC types\n- entity_npc and entity_npc_seek classes for NPC lifecycle management\n- patrol_details, search_details, and spawn_details configuration structures\n- Event-driven architecture with room and player event handling\n- Integration with game manager and global event channel\n- Specialized handling for SEEK entity with chase manager integration\n\n**Key Features:**\n1. **Multi-Entity Management**: Handles 6 different entity types with specialized behaviors\n2. **Event-Driven Architecture**: Responds to room events, player events, and entity lifecycle events\n3. **Lifecycle Management**: Complete NPC spawn, setup, behavior start, and cleanup\n4. **Data Structure Specialization**: Unique data structures for each entity type\n5. **Game Manager Integration**: Coordinates with game manager for player data and state\n6. **Global Event Channel**: Centralized event communication system\n7. **Spawn Configuration**: Flexible spawn timing and trigger systems\n8. **Cleanup Management**: Proper resource cleanup and entity despawning\n\n**Entity Data Architecture:**\n- **entity_data**: Base class with common properties (damage, probability, spawn details)\n- **seek_data**: Specialized for SEEK with chase manager integration\n- **rush_data**: Specialized for RUSH with patrol details\n- **freeze_data**: Specialized for FREEZE (Weeping Angel behavior)\n- **figure_data**: Specialized for FIGURE with patrol and search details\n- **blink_data**: Specialized for BLINK with timing and hit configurations\n- **eyes_data**: Specialized for EYES entity\n\n**Configuration Structures:**\n- **patrol_details**: Patrol point configuration with patrol type and resume behavior\n- **search_details**: Search behavior configuration with search type and timeout\n- **spawn_details**: Spawn timing and trigger configuration\n- **agent_optional_function_type**: Function type for agent-based callbacks\n\n**Entity Management Classes:**\n- **entity_npc**: Standard NPC lifecycle management with spawner integration\n- **entity_npc_seek**: Specialized SEEK entity with chase manager integration\n- **entity_manager_device**: Main orchestrator device\n\n**Event Handling System:**\n- **Room Events**: SPAWN_ENTITY, CLEANUP_ENTITY_ROOM_EXITED, DESPAWN_ALL_ENTITIES\n- **Player Events**: PLAYER_START_RUN, PLAYER_END_RUN, PLAYER_DATA_READY\n- **Entity Events**: Spawn, elimination, behavior lifecycle\n- **Trigger Events**: Custom trigger-based spawning\n\n**Spawn Configuration:**\n- **NPC_SPAWN_TYPE.AFTER_SECONDS**: Time-based spawning\n- **NPC_SPAWN_TYPE.ON_ENTER_VOLUME**: Volume-based spawning\n- **NPC_SPAWN_TYPE.ON_TRIGGER**: Trigger-based spawning\n- **SpawnTransformProp**: Transform configuration for spawn location\n- **SpawnTrigger**: Trigger device for spawn activation\n\n**Patrol Configuration:**\n- **PatrolPointProps**: Array of creative props defining patrol points\n- **PatrolPoints**: Vector3 array of patrol locations\n- **PauseSecondsAtPatrolPoint**: Pause duration at each patrol point\n- **PatrolType**: ONE_SHOT, PING_PONG, or CYCLE patrol patterns\n- **ResumePatrolType**: LAST_PATROL_POINT or CLOSEST_PATROL_POINT resumption\n\n**Search Configuration:**\n- **SearchType**: LAST_SEEN or WEAK_CHASE search patterns\n- **GiveUpSearchAfterTimeSeconds**: Search timeout configuration\n- **Integration with patrol system**: Seamless transition between patrol and search\n\n**Entity Lifecycle Management:**\n1. **Initialization**: Initialize() sets up all entity NPCs with global event channel\n2. **Event Subscription**: Subscribe to room and player events\n3. **Spawn Request**: StartRequestedEntity() processes spawn events\n4. **Entity Creation**: Appropriate Start[Entity]() method called\n5. **Behavior Setup**: NPCSpawned() callback initializes behavior\n6. **Behavior Start**: StartNPCBehaviour() begins entity behavior\n7. **Cleanup**: StopNPC() and cleanup methods handle resource cleanup\n\n**SEEK Entity Specialization:**\n- **entity_npc_seek**: Specialized class for SEEK entity\n- **Chase Manager Integration**: Direct integration with chase manager\n- **Cinematic Sequences**: Full cinematic chase sequences\n- **Player Assignment**: Direct player assignment for chase targeting\n- **Simplified Lifecycle**: Streamlined lifecycle for chase scenarios\n\n**Game Manager Integration:**\n- **Player Data Access**: GetPlayerData() provides current player data\n- **State Coordination**: Coordinates with game manager state\n- **Event Synchronization**: Synchronized event handling\n- **Resource Management**: Shared resource management\n\n**Global Event Channel Integration:**\n- **Room Event Channel**: Handles room-based events\n- **Player Event Channel**: Handles player-based events\n- **Event Broadcasting**: Centralized event broadcasting\n- **Event Subscription**: Managed event subscription system\n\n**Entity Type Management:**\n- **entity_type Enum**: NONE, SEEK, RUSH, FREEZE, FIGURE, BLINK, EYES\n- **Type-Specific Handling**: Specialized handling for each entity type\n- **Data Casting**: Safe casting to appropriate data types\n- **Behavior Assignment**: Automatic behavior assignment based on type\n\n**Spawn Event Processing:**\n- **StartRequestedEntity()**: Main spawn event processor\n- **DespawnOthers Logic**: Conditional despawning of other entities\n- **Player Assignment**: Assigns target player for relevant entities\n- **Entity-Specific Setup**: Calls appropriate setup methods\n\n**Cleanup Management:**\n- **CleanupRequestedEntity()**: Handles cleanup events\n- **StopAllEntities()**: Emergency stop for all entities\n- **Individual Stop Methods**: Entity-specific stop methods\n- **Resource Cleanup**: Proper cleanup of spawners and behaviors\n\n**NPC Spawner Integration:**\n- **npc_spawner_device**: UEFN device for NPC spawning\n- **SpawnedEvent**: Event fired when NPC is spawned\n- **EliminatedEvent**: Event fired when NPC is eliminated\n- **Enable/Disable**: Spawner lifecycle management\n- **DespawnAll()**: Cleanup method for all spawned NPCs\n\n**Behavior Integration:**\n- **basic_enemy_npc_behaviour**: Base behavior class\n- **GetNPCBehavior()**: Extracts behavior from spawned agent\n- **InitializeBehavior()**: Initializes behavior with global event channel\n- **SetupNPC()**: Sets up NPC with entity data\n- **StartNPCBehaviour()**: Starts NPC behavior execution\n\n**Error Handling:**\n- **Safe Casting**: Safe casting with option types\n- **Null Checks**: Comprehensive null checking\n- **Default Cases**: Default case handling in switch statements\n- **Graceful Degradation**: Graceful handling of missing data\n\n**Performance Considerations:**\n- **Event-Driven Updates**: Efficient event-driven architecture\n- **Lazy Initialization**: Entities only initialized when needed\n- **Resource Cleanup**: Proper cleanup prevents memory leaks\n- **Selective Processing**: Only processes relevant events\n\n**Configuration Management:**\n- **Editable Properties**: Extensive use of @editable for configuration\n- **Default Values**: Sensible default values for all configurations\n- **Flexible Setup**: Configurable patrol, search, and spawn parameters\n- **Runtime Modification**: Some properties can be modified at runtime\n\n**Event Communication:**\n- **event_communicator_device**: Base class for event communication\n- **SubscribeToRoomEvent()**: Room event subscription\n- **SubscribeToPlayerEvent()**: Player event subscription\n- **Event Delegation**: Proper event delegation to entities\n\n**Trigger System:**\n- **trigger_device**: UEFN trigger device integration\n- **AssignTriggerFunction()**: Assigns callback functions to triggers\n- **OnTrigger()**: Trigger event handler\n- **Agent-Based Triggers**: Trigger events include agent information\n\n**Player Data Management:**\n- **InitializeEntitiesWithPlayerData()**: Updates all entities with player data\n- **Player Assignment**: Assigns players to relevant entities\n- **Data Synchronization**: Keeps entity data synchronized with player state\n- **Late Initialization**: Handles late player data availability\n\n**Room Integration:**\n- **Room Event Handling**: Responds to room entry and exit events\n- **Entity Spawning**: Room-based entity spawning\n- **Cleanup on Exit**: Automatic cleanup when leaving rooms\n- **Room-Specific Configuration**: Room-specific entity configuration\n\n**Development Benefits:**\n- **Centralized Management**: Single point of control for all entities\n- **Extensible Design**: Easy to add new entity types\n- **Event-Driven**: Responsive to game state changes\n- **Modular Architecture**: Clear separation of concerns\n- **Configuration Flexibility**: Extensive configuration options\n\n**Use Cases:**\n- **Horror Game Management**: Complete horror game entity orchestration\n- **Multi-Entity Scenarios**: Scenarios with multiple active entities\n- **Event-Driven Gameplay**: Gameplay driven by events and triggers\n- **Dynamic Spawning**: Dynamic entity spawning based on game state\n\n**Technical Advantages:**\n- **Type Safety**: Strong typing with safe casting\n- **Resource Management**: Proper resource lifecycle management\n- **Event Efficiency**: Efficient event-driven architecture\n- **Extensibility**: Easy to extend with new entity types\n\n**Integration Points:**\n- **Game Manager**: Core game state management\n- **Global Event Channel**: Centralized event communication\n- **Room Manager**: Room-based gameplay integration\n- **Player Data**: Player state and behavior integration\n- **Chase Manager**: Specialized chase sequence management\n\n**Entity-Specific Features:**\n- **SEEK**: Chase manager integration with cinematic sequences\n- **RUSH**: Patrol-based behavior with light flickering\n- **FREEZE**: Weeping Angel behavior with observation mechanics\n- **FIGURE**: Patrol and search with skilled interaction\n- **BLINK**: Teleportation with hit-based elimination\n- **EYES**: Static observation-based entity\n\n**Spawn Timing Control:**\n- **Immediate Spawning**: Instant spawning on events\n- **Delayed Spawning**: Time-based delayed spawning\n- **Conditional Spawning**: Spawning based on conditions\n- **Trigger-Based Spawning**: Manual trigger-based spawning\n\n**State Management:**\n- **Entity State Tracking**: Tracks state of all entities\n- **Player State Integration**: Integrates with player state\n- **Game State Coordination**: Coordinates with overall game state\n- **Event State Synchronization**: Keeps events synchronized\n\n**Cleanup Strategies:**\n- **Automatic Cleanup**: Automatic cleanup on events\n- **Manual Cleanup**: Manual cleanup methods\n- **Emergency Cleanup**: Emergency stop all entities\n- **Resource Cleanup**: Proper cleanup of all resources\n\n**How It Works:**\n1. **Initialization**: OnBegin() initializes all entity NPCs and subscribes to events\n2. **Event Processing**: NewRoomEvent() and NewPlayerEvent() process incoming events\n3. **Spawn Handling**: StartRequestedEntity() processes spawn requests\n4. **Entity Creation**: Appropriate Start[Entity]() method creates and configures entity\n5. **Behavior Setup**: NPCSpawned() callback initializes entity behavior\n6. **Lifecycle Management**: Entity runs its behavior until cleanup or elimination\n7. **Cleanup**: StopNPC() and cleanup methods handle resource cleanup\n\n**Event Flow:**\n1. **Room Entry**: Player enters room, triggers NEW_ROOM_ENTERED event\n2. **Spawn Decision**: Room manager decides to spawn entity\n3. **Spawn Event**: SPAWN_ENTITY event sent to entity manager\n4. **Entity Creation**: Entity manager creates appropriate entity\n5. **Behavior Start**: Entity begins its behavior (patrol, chase, etc.)\n6. **Player Interaction**: Entity interacts with player based on its behavior\n7. **Cleanup**: Entity cleaned up on room exit or player elimination\n\n**Configuration Flow:**\n1. **Data Structure Setup**: Entity data configured with appropriate parameters\n2. **Spawn Configuration**: Spawn details configured (timing, triggers, location)\n3. **Behavior Configuration**: Patrol, search, and other behavior parameters set\n4. **Integration Setup**: Game manager and event channel integration configured\n5. **Runtime Updates**: Configuration can be updated during gameplay\n\n**Error Recovery:**\n- **Safe Casting**: Handles type casting failures gracefully\n- **Null Handling**: Comprehensive null checking and handling\n- **Default Behavior**: Default behavior when configuration is missing\n- **Cleanup on Error**: Proper cleanup even when errors occur\n\n**Performance Optimization:**\n- **Event-Driven**: Only processes events when necessary\n- **Lazy Loading**: Entities only created when needed\n- **Resource Pooling**: Reuses resources where possible\n- **Efficient Cleanup**: Quick and efficient resource cleanup\n\n**Memory Management:**\n- **Proper Cleanup**: All resources properly cleaned up\n- **Event Unsubscription**: Events properly unsubscribed\n- **Reference Management**: Proper reference management\n- **Garbage Collection**: Helps garbage collection with proper cleanup\n\n**Extensibility Design:**\n- **New Entity Types**: Easy to add new entity types\n- **New Behaviors**: Easy to add new behavior types\n- **New Events**: Easy to add new event types\n- **New Configuration**: Easy to add new configuration options\n\n**Testing and Debugging:**\n- **Debug Prints**: Comprehensive debug printing\n- **State Inspection**: Easy state inspection methods\n- **Event Tracing**: Event tracing for debugging\n- **Error Logging**: Proper error logging and handling\n\n**Entity Manager Responsibilities:**\n- **Entity Lifecycle**: Complete entity lifecycle management\n- **Event Coordination**: Coordinates all entity-related events\n- **Resource Management**: Manages all entity resources\n- **State Synchronization**: Keeps entity state synchronized\n- **Configuration Management**: Manages entity configuration\n\n**Game Integration:**\n- **Player Integration**: Deep integration with player systems\n- **Room Integration**: Seamless room-based gameplay\n- **Event Integration**: Centralized event handling\n- **State Integration**: Integrated with game state management\n\n**Behavioral Coordination:**\n- **Multi-Entity Scenarios**: Handles multiple active entities\n- **Entity Conflicts**: Resolves conflicts between entities\n- **Behavior Priorities**: Manages behavior priorities\n- **Resource Sharing**: Manages shared resources between entities\n\n**Technical Implementation:**\n- **Class Hierarchy**: Well-designed class hierarchy\n- **Interface Design**: Clean interface design\n- **Event Architecture**: Robust event architecture\n- **Resource Management**: Comprehensive resource management\n\n**Quality Assurance:**\n- **Error Handling**: Comprehensive error handling\n- **Resource Cleanup**: Proper resource cleanup\n- **State Consistency**: Maintains consistent state\n- **Performance Monitoring**: Built-in performance considerations",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /Fortnite.com/AI }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { AI }\n\n# See https://dev.epicgames.com/documentation/en-us/uefn/create-your-own-device-in-verse for how to create a verse device.\n\n# MakeEntityData<constructor>(NewEntityData: entity_data):= entity_data:\n#     Player := NewPlayer\n#     GlobalEventChannel := NewGlobalEventChannel\n#     CurrentRoomNum := RoomNum\nagent_optional_function_type:= type{_(:?agent):void}\npatrol_details<public> := class<concrete>:\n    @editable\n    PatrolPointProps<public>: []creative_prop = array{}\n    var PatrolPoints<public>: []vector3 = array{}\n    @editable\n    PauseSecondsAtPatrolPoint<public>: float = 1.0\n    @editable\n    PatrolType<public>: NPC_PATROL_TYPE = NPC_PATROL_TYPE.ONE_SHOT\n    @editable\n    ResumePatrolType<public>: NPC_RESUME_PATROL_TYPE = NPC_RESUME_PATROL_TYPE.LAST_PATROL_POINT\n\nsearch_details<public> := class<concrete>:\n    @editable\n    SearchType<public>: NPC_SEARCH_TYPE = NPC_SEARCH_TYPE.LAST_SEEN\n    @editable\n    GiveUpSearchAfterTimeSeconds<public>: float = 1.0 # used only if >0\n\nspawn_details<public> := class<concrete>:\n    @editable\n    SpawnType<public>: NPC_SPAWN_TYPE = NPC_SPAWN_TYPE.AFTER_SECONDS\n    @editable\n    var SpawnTransformProp<public>: creative_prop = creative_prop{}\n    @editable\n    var SpawnSecondsAfterEntering<public>: float = 2.0\n    @editable\n    var SpawnTrigger<public>: trigger_device = trigger_device{}\n    var SpawnRoomIndex<public>: int = 0\n\n    var SpawnTriggerFunctions: []agent_optional_function_type =  array{}\n    var SpawnTriggerCancelable: ?cancelable = false\n\n    AssignTriggerFunction<public>(TriggerFunction: agent_optional_function_type): void =\n        if(SpawnTriggerCancelableActual := SpawnTriggerCancelable?):\n            SpawnTriggerCancelableActual.Cancel()\n\n        Print(\"AssignTriggerFunction for trigger at {SpawnTrigger.GetTransform().Translation}\")\n        set SpawnTriggerCancelable = option{SpawnTrigger.TriggeredEvent.Subscribe(OnTrigger)}\n        set SpawnTriggerFunctions = array{TriggerFunction}\n\n    OnTrigger(Agent: ?agent): void =\n        Print(\"OnTrigger\")\n        if(FoundSpawnTriggerFunction := SpawnTriggerFunctions[0]):\n            Print(\"FoundSpawnTriggerFunction\")\n            FoundSpawnTriggerFunction(Agent)\n\nentity_data<public> := class:\n    EntityType<public>: entity_type = entity_type.NONE\n    @editable\n    DespawnOthers<public>: logic = true\n    @editable\n    var Damage<public>: float = 5.0\n    @editable\n    var Probability<public>: int = 0\n    var ReactsToPlayer<public>: logic = true\n    @editable\n    var SpawnDetails<public>: spawn_details = spawn_details{}\n    \n    KillPlayerOnReach<public>: logic = true\n    var PlayerData<public>: player_data = player_data{}\n    var Player<public>: ?player = false\n\nseek_data<public> := class(entity_data):\n    EntityType<override>: entity_type = entity_type.SEEK\n    var ChaseManager<public>: chase_manager = chase_manager{}\n\nrush_data<public> := class(entity_data):\n    EntityType<override>: entity_type = entity_type.RUSH\n    @editable\n    PatrolDetails<public>: patrol_details = patrol_details{}\n\nfreeze_data<public> := class(entity_data):\n    EntityType<override>: entity_type = entity_type.FREEZE\n\nfigure_data<public> := class(entity_data):\n    EntityType<override>: entity_type = entity_type.FIGURE\n    @editable\n    PatrolDetails<public>: patrol_details = patrol_details{ResumePatrolType := NPC_RESUME_PATROL_TYPE.CLOSEST_PATROL_POINT}\n    SearchDetails<public>: search_details = search_details{}\n\nblink_data<public> := class(entity_data):\n    EntityType<override>: entity_type = entity_type.BLINK\n    @editable\n    SecondsToLookAt<public>: float = 1.0\n    @editable\n    NumberOfHits<public>: int = 3\n\neyes_data<public> := class(entity_data):\n    EntityType<override>: entity_type = entity_type.EYES\n\nentity_npc := class:\n    @editable\n    NPCSpawner: npc_spawner_device = npc_spawner_device{}\n    var NPCBehaviour: basic_enemy_npc_behaviour = basic_enemy_npc_behaviour{}\n    var NPCData: entity_data = entity_data{}\n    var GlobalEventChannel: global_event_channel = global_event_channel{}\n    var GameManager: game_manager = game_manager{}\n    var SpawnEventCancelable: ?cancelable = false\n    var EliminatedEventCancelable: ?cancelable = false\n\n    Initialize(NewGlobalEventChannel: global_event_channel, NewGameManager: game_manager): void =\n        set GlobalEventChannel = NewGlobalEventChannel\n        set GameManager = NewGameManager\n        set SpawnEventCancelable = option{NPCSpawner.SpawnedEvent.Subscribe(NPCSpawned)}\n        set EliminatedEventCancelable = option{NPCSpawner.EliminatedEvent.Subscribe(EliminatedNPC)}\n\n    StartNPC(NewNPCData: entity_data): void =\n        StopNPC()\n        set NPCData = NewNPCData\n        set NPCData.PlayerData = GameManager.GetPlayerData()\n        SpawnNPC()\n\n    NPCSpawned(NPCAgent: agent): void =\n        # Print(\"{NPCData.EntityType.ToString()}: NPCSpawned\")   \n        if(NewNPCBehavior := basic_enemy_npc_behaviour[NPCAgent.GetNPCBehavior[]]):\n            # Print(\"{NPCData.EntityType.ToString()}: NewNPCBehavior set\")   \n            set NPCBehaviour = NewNPCBehavior\n            NPCBehaviour.InitializeBehavior(GlobalEventChannel)\n            NPCBehaviour.SetupNPC(NPCData)\n            NPCBehaviour.StartNPCBehaviour()\n\n    SpawnNPC(): void =\n        # Print(\"{NPCData.EntityType.ToString()}: SpawnNPC\")\n        NPCSpawner.Enable()\n        NPCSpawner.Spawn()\n\n    CheckNPCBehaviour(): void =\n        Print(\"CheckNPCBehaviour: NPCBehaviourID: {NPCBehaviour.NPCBehaviourID}\")\n\n    CleanupNPC(): void =\n        NPCBehaviour.CleanupNPC()\n\n    EliminatedNPC(Result: device_ai_interaction_result): void = \n        Print(\"{NPCData.EntityType.ToString()}: EliminatedNPC\")\n        StopNPC()\n\n    StopNPC(): void =\n        Print(\"{NPCData.EntityType.ToString()}: StopNPC\")\n        # if(SpawnEvent := SpawnEventCancelable?):\n        #     SpawnEvent.Cancel()\n        # if(EliminatedEvent := EliminatedEventCancelable?):\n        #     EliminatedEvent.Cancel()\n        NPCSpawner.DespawnAll(false)\n        NPCSpawner.Disable()\n\nentity_npc_seek := class:\n    var NPCData: seek_data = seek_data{}\n    var GameManager: game_manager = game_manager{}\n\n    Initialize(NewGameManager: game_manager): void =\n        set GameManager = NewGameManager\n\n    StartNPC(NewSeekData: seek_data): void =\n        set NPCData = NewSeekData\n        set NPCData.PlayerData = GameManager.GetPlayerData()\n        NPCData.ChaseManager.StartChase(NewSeekData.Player, NewSeekData.PlayerData, NewSeekData.SpawnDetails.SpawnTransformProp)\n\n    StopNPC(): void =\n        # do actual stop with cinematics via mutator zone in chase manager\n        return\n\n\n# A Verse-authored creative device that can be placed in a level\nentity_manager_device<public> := class(event_communicator_device):\n    # @editable\n    # NPCSeek: entity_npc = entity_npc{}\n    @editable\n    NPCRush: entity_npc = entity_npc{}\n    @editable\n    NPCFigure: entity_npc = entity_npc{}\n    @editable\n    NPCFreeze: entity_npc = entity_npc{}\n    @editable\n    NPCBlink: entity_npc = entity_npc{}\n    var EMID: string = \"defaultEMID\"\n    @editable\n    CurrentGameManager: game_manager = game_manager{}\n\n    var NPCSeek: entity_npc_seek = entity_npc_seek{}\n\n    OnBegin<override>()<suspends>: void =\n        Initialize()\n\n    Initialize<public>(): void =\n        # if(not IsInitialized?):\n            # Print(\"EM INIT\")\n            # set IsInitialized = true\n            Setup()\n            set EMID = \"ooolalalala\"\n            SubscribeToRoomEvent(NewRoomEvent, \"entity_manager\")\n            SubscribeToPlayerEvent(NewPlayerEvent, \"entity_manager\")\n\n            # CurrentGameManager := game_manager{}\n            # CurrentGameManager := FindGameManager()\n            NPCSeek.Initialize(CurrentGameManager)\n            NPCRush.Initialize(GlobalEventChannel, CurrentGameManager)\n            NPCFigure.Initialize(GlobalEventChannel, CurrentGameManager)\n            NPCFreeze.Initialize(GlobalEventChannel, CurrentGameManager)\n            NPCBlink.Initialize(GlobalEventChannel, CurrentGameManager)\n\n    InitializeEntitiesWithPlayerData(NewPlayerData: player_data): void =\n        # Print(\"InitializeEntitiesWithPlayerData\")\n        set NPCSeek.NPCData.PlayerData = NewPlayerData\n        set NPCRush.NPCData.PlayerData = NewPlayerData\n        set NPCFigure.NPCData.PlayerData = NewPlayerData\n        set NPCFreeze.NPCData.PlayerData = NewPlayerData\n        set NPCBlink.NPCData.PlayerData = NewPlayerData\n\n    NewRoomEvent(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        case (EventName):\n            event_names.SPAWN_ENTITY =>\n                if(EventData := event_spawn_entity[Data], EventPlayer := player[Agent?]):\n                    StartRequestedEntity(EventData, EventPlayer)\n            event_names.CLEANUP_ENTITY_ROOM_EXITED =>\n                if(EventData := event_spawn_entity[Data]):\n                    CleanupRequestedEntity(EventData)\n            event_names.DESPAWN_ALL_ENTITIES =>\n                StopAllEntities()\n            _ =>\n                return\n\n    NewPlayerEvent(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        case (EventName):\n            event_names.PLAYER_START_RUN =>\n            event_names.PLAYER_END_RUN =>\n                StopAllEntities()\n            # event_names.PLAYER_SPAWNED =>\n                # InitializeEntities()\n            # event_names.PLAYER_ELIMINATED =>\n                # StopAllEntities()\n            event_names.PLAYER_DATA_READY =>\n                # For situations like the player hid before an entity was spawned in the room. In that case, the NPC behaviour would have missed the PLAYER_HIDE_SUCCESS event.\n                if(EventData := event_player_data_ready[Data]):\n                    InitializeEntitiesWithPlayerData(EventData.NewPlayerData)\n            _ =>\n                return\n\n    StartRequestedEntity(SpawnEntityEvent: event_spawn_entity, TargetPlayer: player): void =\n        # Print(\"StartRequestedEntity: {SpawnEntityEvent.EntityType.ToString()}\")\n        if(SpawnEntityEvent.DespawnOthers?):\n            StopAllEntities()\n        \n        case (SpawnEntityEvent.EntityType):\n            entity_type.SEEK =>\n                if(SeekData := seek_data[SpawnEntityEvent.EntityData]):\n                    set SeekData.Player = option{TargetPlayer}\n                    StartSeek(SeekData)\n                    \n            entity_type.RUSH =>\n                if(RushData := rush_data[SpawnEntityEvent.EntityData]):\n                    StartRush(RushData)\n                    \n            entity_type.FREEZE =>\n                if(FreezeData := freeze_data[SpawnEntityEvent.EntityData]):\n                    StartFreeze(FreezeData)\n                    \n            entity_type.FIGURE =>\n                if(FigureData := figure_data[SpawnEntityEvent.EntityData]):\n                    StartFigure(FigureData)\n                \n            entity_type.BLINK =>\n                if(BlinkData := blink_data[SpawnEntityEvent.EntityData]):\n                    set BlinkData.Player = option{TargetPlayer}\n                    StartBlink(BlinkData)\n                \n            entity_type.EYES =>\n                if(EyesData := eyes_data[SpawnEntityEvent.EntityData]):\n                    # StartEyes(EyesData)\n                \n            _ => # default\n                Print(\"NONE entity specified\")\n\n    CleanupRequestedEntity(CleanupEntityEvent: event_spawn_entity): void =\n        # Print(\"CleanupRequestedEntity: {CleanupEntityEvent.EntityType.ToString()}\")        \n        case (CleanupEntityEvent.EntityType):\n            entity_type.RUSH =>\n                if(RushData := rush_data[CleanupEntityEvent.EntityData]):\n                    NPCRush.CleanupNPC()\n                \n            _ => # default\n                Print(\"NONE entity specified\")\n        \n    StopAllEntities<public>(): void =\n        StopSeek()\n        StopRush()\n        StopFigure()\n        StopFreeze()\n        StopBlink()\n\n    StartSeek<public>(NewSeekData: seek_data): void =\n        StopSeek()\n        NPCSeek.StartNPC(NewSeekData)\n\n    StopSeek<public>(): void =\n        NPCSeek.StopNPC()\n        return\n\n    StartRush<public>(NewRushData: rush_data): void =\n        StopRush()\n        # Print(\"StartRush: NPCRush\")\n        NPCRush.StartNPC(NewRushData)\n        # NPCRush.NPCBehaviour.SetupNPC(NewRushData)\n        # NPCRush.NPCBehaviour.StartNPCBehaviour()\n        # NPCRush.CheckNPCBehaviour()\n        # Print(\"{EMID}\")\n\n    StopRush<public>(): void =\n        NPCRush.StopNPC()\n\n    StartFigure<public>(NewFigureData: figure_data): void =\n        StopFigure()\n        NPCFigure.StartNPC(NewFigureData)\n        # NPCFigure.NPCBehaviour.SetupNPC(NewFigureData)\n        # NPCFigure.NPCBehaviour.StartNPCBehaviour()\n\n    StopFigure<public>(): void =\n        NPCFigure.StopNPC()\n\n    StartFreeze<public>(NewFreezeData: freeze_data): void =\n        StopFreeze()\n        # Print(\"StartFreeze\")\n        NPCFreeze.StartNPC(NewFreezeData)\n        # NPCFreeze.NPCBehaviour.SetupNPC(freeze_data{})\n        # NPCFreeze.NPCBehaviour.StartNPCBehaviour()\n\n    StopFreeze<public>(): void =\n        NPCFreeze.StopNPC()\n\n    StartBlink<public>(NewBlinkData: blink_data): void =\n        StopBlink()\n        NPCBlink.StartNPC(NewBlinkData)\n\n    StopBlink<public>(): void =\n        NPCBlink.StopNPC()\n\n    \n    \n    TestEM<public>(): void =\n        Print(\"{EMID}\")\n        Print(\"{GetTransform().Translation}\") \n        NPCRush.CheckNPCBehaviour()\n\n# entity_chase := class(entity_device):\n#     @editable\n#     ChaseSpeed : float = 0.0\n\n# entity_static := class(entity_device):\n#     OnBegin<override>()<suspends>: void=\n#         (super:)OnBegin()\n#         set DamageAmount = 1.0\n\n# entity_follow := class(entity_device):\n#     @editable\n#     FollowDistance : float = 0.0\n\n# entity_figure := class(entity_chase):\n# entity_weeping_angel := class(entity_chase):\n# entity_rush := class(entity_chase):\n# entity_horde := class(entity_chase):\n\n# entity_popcorn := class(entity_static):\n# entity_apparition := class(entity_static):\n# entity_eyes := class(entity_static):\n\n# entity_dementor := class(entity_follow):",
    "external_calls": [
      "event_communicator_device",
      "creative_device",
      "npc_spawner_device",
      "basic_enemy_npc_behaviour",
      "global_event_channel",
      "game_manager",
      "player_data",
      "chase_manager",
      "trigger_device",
      "creative_prop",
      "agent",
      "player",
      "entity_type",
      "entity_data",
      "seek_data",
      "rush_data",
      "freeze_data",
      "figure_data",
      "blink_data",
      "eyes_data",
      "patrol_details",
      "search_details",
      "spawn_details",
      "event_names",
      "event_data",
      "event_spawn_entity",
      "event_player_data_ready",
      "NPC_SPAWN_TYPE",
      "NPC_PATROL_TYPE",
      "NPC_RESUME_PATROL_TYPE",
      "NPC_SEARCH_TYPE",
      "device_ai_interaction_result",
      "cancelable",
      "vector3",
      "transform",
      "agent_optional_function_type",
      "Print",
      "Setup",
      "SubscribeToRoomEvent",
      "SubscribeToPlayerEvent",
      "GetTransform",
      "GetNPCBehavior",
      "InitializeBehavior",
      "SetupNPC",
      "StartNPCBehaviour",
      "GetPlayerData",
      "StartChase",
      "Enable",
      "Disable",
      "Spawn",
      "DespawnAll",
      "CleanupNPC",
      "TriggeredEvent",
      "Subscribe",
      "Cancel",
      "SpawnedEvent",
      "EliminatedEvent"
    ]
  }
] 