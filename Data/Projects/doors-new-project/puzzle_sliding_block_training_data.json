[
  {
    "file_name": "puzzle_sliding_block.verse",
    "questions": [
      "How do I create a solvable sliding block (n-puzzle) in Verse?",
      "What is the code for a 3x3 sliding puzzle that shuffles into a guaranteed solvable state and checks for completion?",
      "I need a script that uses an event-based system for moving tiles and ensures the puzzle's initial state is always solvable.",
      "How can I implement the logic to check if a sliding puzzle's configuration is solvable based on inversion count?"
    ],
    "explanation": "This script implements a classic sliding block puzzle (also known as an n-puzzle or 15-puzzle) on a 3x3 grid. A key feature is its ability to shuffle the tiles into a random but guaranteed solvable configuration. The puzzle logic is robust, handling player interactions, move validation, and win conditions. It is event-driven, using a `global_event_channel` to manage tile movements initiated by the player.\n\n**Core Components:**\n- `puzzle_sliding_block`: The main class inheriting from `puzzle_base`, which manages the overall puzzle state and logic.\n- `puzzle_tile`: Represents a single tile in the puzzle. It holds its visual representation (`creative_prop`), its correct final position (`TargetIndex`), and its current position (`CurrentIndex`).\n- `puzzle_button`: Manages player interaction for each slot in the grid. It contains a `button_device` and knows which `puzzle_tile` (if any) currently occupies its slot.\n- **Solvability Algorithm**: The script includes a set of functions (`CustomShuffle`, `IsSolvable`, `CountInversions`, `FixPuzzle`) to ensure the puzzle is always solvable. It calculates the number of inversions in the shuffled puzzle to determine if a solution is possible. If not, it corrects the configuration.\n\n**Key Features:**\n1. **Guaranteed Solvable Shuffle**: The `CustomShuffle` function first shuffles the tiles randomly and then uses the `IsSolvable` algorithm to check if the resulting state can be solved. If not, `FixPuzzle` swaps two tiles to make it solvable, preventing impossible puzzle states.\n2. **Event-Driven Tile Movement**: When a player interacts with a tile's button, the `puzzle_button` broadcasts a `PLAYER_MOVED_TILE` event. The main `puzzle_sliding_block` class listens for this event and calls the `MoveTile` function.\n3. **Adjacency-Based Move Logic**: `MoveTile` uses a predefined `IndexArray` to check for valid moves. A tile can only move into an adjacent empty slot. It provides audio feedback for both valid (`SlidingAudio`) and invalid (`SlidingBlockedAudio`) move attempts.\n4. **State Tracking**: Each `puzzle_tile` tracks its `CurrentIndex`. The `PuzzleAnswerValidationCheck` function determines if the puzzle is solved by comparing the `CurrentIndex` of each tile to its `TargetIndex`.\n5. **Clear Visual and Audio Feedback**: The puzzle provides immediate feedback through tile movement, success/fail sounds, and a HUD message upon completion.\n\n**Workflow:**\n1. **Initialization**: On `OnBegin`, the puzzle sets up its event listeners. It then calls `CustomShuffle` to arrange the `PuzzleTiles` into a solvable random order.\n2. **Setup Loop**: It iterates through each `puzzle_button`, assigning it a `puzzle_tile` from the shuffled list, setting its initial transform, and subscribing to its interaction event.\n3. **Player Interaction**: The player presses a `button_device` linked to a `puzzle_button`. This triggers `OnButtonInteraction`, which broadcasts the `PLAYER_MOVED_TILE` event with the tile's current index.\n4. **Move Processing**: `OnRoomEvent` catches the event and calls `MoveTile`.\n5. **Move Validation**: `MoveTile` checks if the selected tile is adjacent to the `IsEmptySlot`. If so, it swaps the tile with the empty slot, updates the `CurrentIndex` for the tile, and plays a sliding sound. If not, it plays a blocked sound.\n6. **Win Condition Check**: After every valid move, `PuzzleAnswerValidationCheck` is called. If all tiles are in their target positions, `OnPuzzleSolved` is triggered.\n7. **Puzzle Completion**: `OnPuzzleSolved` disables all buttons, shows a victory message, and moves the entire puzzle prop away.\n\n**Use Cases:**\n- Creating classic logic puzzles like the sliding tile game.\n- A template for grid-based puzzles that require item swapping or repositioning.\n- Demonstrating how to implement algorithms for ensuring puzzle solvability in a game context.",
    "code": "using { /Fortnite.com/Devices }\nusing { /Fortnite.com/Characters }\nusing { /Verse.org/Random }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\n\n# Represents a single puzzle piece with its position information\npuzzle_tile := class:\n    @editable\n    TileProp : creative_prop = creative_prop{}    # The visual representation of the tile\n\n    @editable\n    TargetIndex: int = -1    # The correct position this tile should be in\n\n    var CurrentIndex : int = -1    # Current position of the tile in the grid\n\n# Manages interaction with each tile in the puzzle\npuzzle_button := class(room_event_communicator):\n    @editable\n    InteractButton : button_device = button_device{}    # Button for player interaction\n\n    var IsEmptySlot : logic = false    # True if this position has no tile\n    var ButtonTransform : transform = transform{}    # Position and rotation of this button\n    var CurrentTile : puzzle_tile = puzzle_tile{}    # The tile currently at this position\n    var ButtonEventHandle : ?cancelable = false    # Handle for the interaction event\n\n    # Initialize the button and position its tile\n    Setup<override>(EventChannel: global_event_channel) : void=\n        (super:)Setup(EventChannel)\n        if:\n            CurrentTile.TileProp.IsValid[]\n            Rotation := CurrentTile.TileProp.GetTransform().Rotation\n        then:\n            option:\n                CurrentTile.TileProp.TeleportTo[ButtonTransform.Translation, Rotation]\n        set ButtonEventHandle = option{InteractButton.InteractedWithEvent.Subscribe(OnButtonInteraction)}\n\n    # Handle when a player interacts with this button\n    OnButtonInteraction(Agent : agent) : void=\n        if(not IsEmptySlot?):\n            GlobalEventChannel.RoomEventChannel.BroadcastChannel(\n                event_names.PLAYER_MOVED_TILE, \n                event_player_moved_piece{Index := CurrentTile.CurrentIndex}, \n                option{Agent}\n            )\n\n# Main puzzle device that manages game logic\npuzzle_sliding_block := class(puzzle_base):\n    var NamePuzzle<override> : puzzle_names = puzzle_names.SLIDING_BLOCK # overriding Puzzle Name\n    \n    # Represents valid moves for each position in a 3x3 grid\n    # Each array contains indices of positions a tile can move to\n    var IndexArray : [][]int = array{\n        array{1,3},      # Position 0 can move to 1 or 3\n        array{0,2,4},    # Position 1 can move to 0, 2, or 4\n        array{1,5},      # Position 2 can move to 1 or 5\n        array{0,4,6},    # Position 3 can move to 0, 4, or 6\n        array{1,3,5,7},  # Position 4 can move to 1, 3, 5, or 7\n        array{2,4,8},    # Position 5 can move to 2, 4, or 8\n        array{3,7},      # Position 6 can move to 3 or 7\n        array{4,6,8},    # Position 7 can move to 4, 6, or 8\n        array{5,7}       # Position 8 can move to 5 or 7\n    }\n\n    @editable\n    var PuzzleButtons : []puzzle_button = array{}    # Array of interactive buttons\n\n    @editable\n    var PuzzleTiles : []puzzle_tile = array{}    # Array of all puzzle tiles\n\n    @editable\n    SlidingAudio : audio_player_device = audio_player_device{}    # Sound for valid moves\n\n    @editable\n    SlidingBlockedAudio : audio_player_device = audio_player_device{}    # Sound for invalid moves\n\n    @editable\n    PuzzleSolvedMessage : hud_message_device = hud_message_device{}    # Victory message display\n\n    @editable\n    PuzzleHoldingProp : creative_prop = creative_prop{}\n\n    # Initialize the puzzle when the game starts\n    OnBegin<override>()<suspends>:void=\n        Setup()\n        set EventCancelables += array{GlobalEventChannel.RoomEventChannel.SubscribeChannel(OnRoomEvent)}\n        \n        var Index : int = 0\n        set PuzzleTiles = CustomShuffle(PuzzleTiles)    # Shuffle tiles into a solvable configuration\n        for(ButtonData : PuzzleButtons):\n            if(TileData := PuzzleTiles[Index]):\n                if(not TileData.TileProp.IsValid[]):\n                    set ButtonData.IsEmptySlot = true\n                    Print(\"Empty Adding\", ?Duration:=6.0) \n                set ButtonData.CurrentTile = TileData\n            set ButtonData.ButtonTransform = ButtonData.InteractButton.GetTransform()\n            set ButtonData.CurrentTile.CurrentIndex = Index\n            ButtonData.Setup(GlobalEventChannel)\n            Print(\"{ButtonData.CurrentTile.CurrentIndex}\", ?Duration:=6.0)\n            set Index += 1\n\n    # Check if the puzzle is solved\n    PuzzleAnswerValidationCheck<override>() : logic=\n        for(Tile : PuzzleTiles, Tile.TargetIndex <> -1):\n            if(Tile.TargetIndex <> Tile.CurrentIndex):\n                return false\n        return true\n    \n    # Handle puzzle completion\n    OnPuzzleSolved<override>() : void=\n        (super:)OnPuzzleSolved()\n        for(ButtonData : PuzzleButtons, Cancelable := ButtonData.ButtonEventHandle?):\n            Cancelable.Cancel()\n            ButtonData.InteractButton.Disable()\n        PuzzleSolvedMessage.Show()\n        spawn:\n            MoveAwayFromDoor()\n            \n    MoveAwayFromDoor()<suspends> : void=\n        Sleep(1.0)\n        PuzzleHoldingTranslation := PuzzleHoldingProp.GetTranslation()\n        PuzzleHoldingProp.MoveTo(PuzzleHoldingTranslation + 400.0, PuzzleHoldingProp.GetRotation(), 2.0)\n    # Process events from the room\n    OnRoomEvent(EventName: event_names, Data: event_data, Agent: ?agent) : void=\n        case (EventName):\n            event_names.PLAYER_MOVED_TILE => \n                if(MoveData := event_player_moved_piece[Data]): \n                    MoveTile(MoveData.Index)\n            _ => return\n\n    # Move a tile if the move is valid\n    MoveTile(Index : int) : void=\n        var HasMoved : logic = false\n        if(PuzzleButtons[Index].IsEmptySlot?):\n            return\n        for(ValidPosition : IndexArray[Index]):\n            if(AdjacentButton := PuzzleButtons[ValidPosition]):\n                if:\n                    AdjacentButton.IsEmptySlot?\n                    CurrentButton := PuzzleButtons[Index]\n                then:\n                    set HasMoved = true\n                    SlidingAudio.Play()\n                    spawn:\n                        CurrentButton.CurrentTile.TileProp.MoveTo(\n                            AdjacentButton.ButtonTransform.Translation,\n                            CurrentButton.CurrentTile.TileProp.GetTransform().Rotation, \n                            0.1\n                        )\n                    set AdjacentButton.CurrentTile = CurrentButton.CurrentTile\n                    set AdjacentButton.CurrentTile.CurrentIndex = ValidPosition\n                    set AdjacentButton.IsEmptySlot = false\n                    set CurrentButton.CurrentTile = puzzle_tile{}\n                    set CurrentButton.IsEmptySlot = true\n                    option:\n                        set PuzzleButtons[Index] = CurrentButton\n                        set PuzzleButtons[ValidPosition] = AdjacentButton\n                    IsSolved := PuzzleAnswerValidationCheck()\n                    if(IsSolved?):\n                        OnPuzzleSolved()\n        if(not HasMoved?):\n            SlidingBlockedAudio.Play()\n\n    # Generate a solvable puzzle configuration\n    CustomShuffle(Input:[]puzzle_tile) : []puzzle_tile=\n        var ShuffledPuzzle : []puzzle_tile = array{}\n        set ShuffledPuzzle = Shuffle(Input)\n        var TileIndices : []int = array{}\n        for(I := 0..ShuffledPuzzle.Length):\n            if:\n                TileValidIndex := ShuffledPuzzle[I].TargetIndex\n                set ShuffledPuzzle[I].CurrentIndex = I\n            then:\n                set TileIndices += array{TileValidIndex}\n\n        CanBeSolved := IsSolvable(TileIndices, 3, ShuffledPuzzle.Length)\n        if(CanBeSolved?):\n            return ShuffledPuzzle\n        else:\n            return FixPuzzle(ShuffledPuzzle, TileIndices)\n\n\n#-----------------------------------------------------------------\n# Code for finding the correct shuffle that is solvable, more info:\n#-----------------------------------------------------------------\n# https://developerslogblog.wordpress.com/2020/04/01/how-to-shuffle-an-slide-puzzle/\n#-----------------------------------------------------------------\n    # Count inversions for solvability check\n    CountInversions(Puzzle : []int, Size : int): int=\n        var Inversions: int = 0\n        for (i := 0..Size-1, Puzzle[i] <> -1):\n                for (j := (i + 1)..Size-1, Puzzle[j] <> -1):\n                    if(Puzzle[i] > Puzzle[j]):\n                        set Inversions+=1\n        return Inversions\n\n    # Get row position from bottom for empty tile\n    GetEmptyTileRow(Array : []int,  Size : int): int=\n        var EmptyTilePos: int = -1\n        for (i := 0..Size-1):\n            if (Array[i] = -1):\n                set EmptyTilePos = i\n                Print(\"Empty Tile: {EmptyTilePos}\", ?Duration:=6.0)\n                RowCalc := EmptyTilePos * 1.0 / 3.0\n                if:\n                    RowFromBottom : int = Floor[RowCalc]\n                then:\n                    Print(\"Empty Row : {3 - RowFromBottom}\", ?Duration:=6.0)\n                    return 3 - RowFromBottom\n        return -1\n\n    # Fix an unsolvable puzzle configuration\n    FixPuzzle(Input : []puzzle_tile, IntArray : []int) : []puzzle_tile=\n        var FixedPuzzle : []puzzle_tile = Input\n        Print(\"Fixing Puzzle\", ?Duration:=6.0)\n        if(IntArray[0] <> -1, IntArray[1] <> -1):\n            if:\n                FirstElement := FixedPuzzle[0]\n                SecondElement := FixedPuzzle[1]\n                set FirstElement.CurrentIndex = 1\n                set SecondElement.CurrentIndex = 0\n                set FixedPuzzle[0] = SecondElement\n                set FixedPuzzle[1] = FirstElement\n        else:\n            if:\n                LastElement := FixedPuzzle[FixedPuzzle.Length - 1]\n                SecondLastElement := FixedPuzzle[FixedPuzzle.Length - 2]\n                set LastElement.CurrentIndex = FixedPuzzle.Length - 2\n                set SecondLastElement.CurrentIndex = FixedPuzzle.Length - 1\n                set FixedPuzzle[FixedPuzzle.Length - 1] = SecondLastElement\n                set FixedPuzzle[FixedPuzzle.Length - 2] = LastElement\n        for(Tile : FixedPuzzle):\n            Print(\"{Tile.CurrentIndex}\", ?Duration:=6.0)\n        return FixedPuzzle\n    \n    # Check if puzzle configuration is solvable\n    IsSolvable(Array : []int, Width : int, Size : int): logic=\n        InversionCount := CountInversions(Array, Size)\n        Print(\"Count Of Inversions : {InversionCount}\", ?Duration:=6.0)\n        \n        if (Mod[Width, 2] <> 0):\n            if(Mod[InversionCount, 2] = 0):\n                return true\n            else:\n                return false\n        else:\n            EmptyRow := GetEmptyTileRow(Array, Size)\n            if(Mod[EmptyRow, 2] = 0):\n                if(Mod[InversionCount, 2] <> 0):\n                    return true\n                else:\n                    return false\n            else:\n                if(Mod[InversionCount, 2] = 0):\n                    return true\n                else:\n                    return false\n\n#-----------------------------------------------------------------\n# Online Puzzle Solver ( For Testing Purposes ) : https://alexyuisingwu.github.io/sliding-puzzle-solver/\n#-----------------------------------------------------------------\n",
    "external_calls": [
      "creative_prop",
      "room_event_communicator",
      "button_device",
      "transform",
      "puzzle_tile",
      "cancelable",
      "global_event_channel",
      "IsValid",
      "GetTransform",
      "TeleportTo",
      "Subscribe",
      "BroadcastChannel",
      "event_names",
      "event_player_moved_piece",
      "agent",
      "puzzle_base",
      "puzzle_names",
      "audio_player_device",
      "hud_message_device",
      "OnBegin",
      "Setup",
      "SubscribeChannel",
      "CustomShuffle",
      "Print",
      "PuzzleAnswerValidationCheck",
      "OnPuzzleSolved",
      "Cancel",
      "Disable",
      "Show",
      "spawn",
      "Sleep",
      "GetTranslation",
      "MoveTo",
      "GetRotation",
      "OnRoomEvent",
      "event_data",
      "MoveTile",
      "Play",
      "Shuffle",
      "IsSolvable",
      "FixPuzzle",
      "CountInversions",
      "Floor",
      "GetEmptyTileRow",
      "Mod",
      "logic",
      "int"
    ]
  }
] 