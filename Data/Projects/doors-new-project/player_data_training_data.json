[
  {
    "file_name": "player_data.verse",
    "questions": [
      "How can I create a comprehensive player management system with state tracking and event handling in Verse?",
      "What is the Verse code for managing player interactions, hiding mechanics, and death sequences?",
      "I need a script that handles player states, audio systems, and UI management for a horror game.",
      "How do I create a player data manager that coordinates camera control, damage systems, and elimination sequences?"
    ],
    "explanation": "This script provides a comprehensive player management system for a horror game, handling all aspects of player state, interactions, audio-visual effects, and death sequences. It's the core player controller that manages the player's experience throughout the game.\n\n**Core Components:**\n- MakePlayerData: Constructor function for creating player data instances with initial state\n- player_data: Main class managing all player-related functionality and state\n- Player state management with enumerated states (ALIVE, DEATH_SCHEDULED, DEAD)\n- Event-driven architecture for handling player interactions and game events\n\n**Key Features:**\n1. **Player State Management**: Comprehensive state tracking including alive, death scheduled, and dead states\n2. **Hiding System**: Advanced hiding mechanics with teleportation, button interaction, and state persistence\n3. **Death Sequence System**: Cinematic death sequences with camera movement and audio coordination\n4. **Audio Management**: Multi-layered audio system for headache, death sounds, and environmental audio\n5. **UI Management**: HUD message systems for death messages, jumpscares, and interactive elements\n6. **Camera Integration**: Seamless camera control during death sequences and special events\n7. **Event Communication**: Full integration with global event system for game coordination\n8. **Damage System**: Health management and damage processing for environmental hazards\n\n**Player State System:**\n- **ALIVE**: Normal gameplay state with full player control\n- **DEATH_SCHEDULED**: Transition state during death sequence preparation\n- **DEAD**: Final state after elimination with audio/visual effects\n\n**Hiding Mechanics:**\n- **Toggle System**: Players can enter/exit hiding spots with dynamic button text\n- **Transform Management**: Precise teleportation between hiding and exit positions\n- **State Persistence**: Hiding state maintained across game events\n- **Event Broadcasting**: Communicates hiding state changes to other systems\n\n**Death Sequence Flow:**\n1. **PlayerEliminateByEntity()**: Initiates death sequence from entity interaction\n2. **PlayerEliminateCutscene()**: Handles cinematic death sequence with camera movement\n3. **PlayerEliminated()**: Processes actual elimination with audio and event broadcasting\n4. **Audio Coordination**: Manages death sounds and prevents audio overlap\n\n**Audio System:**\n- **PlayerHeadache**: Atmospheric tension audio\n- **PlayerDeath1/PlayerDeath2**: Death sequence audio effects\n- **SkipDeathAudio**: Flag to prevent audio conflicts during scripted deaths\n- **StopAllAudios()**: Emergency audio cleanup function\n\n**UI Systems:**\n- **HUD Death Messages**: Randomized death messages with dramatic flair\n- **Jumpscare System**: Coordinated visual and tracking effects\n- **Bottom Left UI Stack**: Modular UI system for dynamic interface elements\n- **Interactive Button Text**: Dynamic text updates for context-sensitive interactions\n\n**Event Handling:**\n- **PLAYER_START_RUN**: Resets run-specific data and preparation\n- **PLAYER_SPAWNED**: Handles respawn logic and UI cleanup\n- **PLAYER_HIDE_TOGGLE**: Manages hiding system interactions\n- **PLAYER_SEEING_EYES**: Processes damage from environmental hazards\n- **PLAYER_JUMPSCARE**: Triggers jumpscare effects\n- **PLAYER_ELIMINATED**: Handles elimination processing\n\n**Camera Integration:**\n- **Death Sequence Camera**: Smooth camera movement from player to elimination source\n- **Camera Return**: Automatic return to player after death sequence\n- **Timing Coordination**: Synchronized camera movement with audio and visual effects\n\n**Damage System:**\n- **Environmental Damage**: Handles damage from looking at hazardous entities\n- **Health Management**: Coordinates with Fortnite character health system\n- **Damage Prevention**: State-based damage prevention during death sequences\n\n**How It Works:**\n1. **Initialization**: Sets up player reference, event subscriptions, and system integration\n2. **State Management**: Maintains player state throughout game lifecycle\n3. **Event Processing**: Handles incoming events and coordinates appropriate responses\n4. **Interaction Management**: Processes player interactions with game world\n5. **Death Handling**: Manages complex death sequences with audio-visual coordination\n6. **UI Coordination**: Updates interface elements based on player state and interactions\n7. **System Integration**: Coordinates with camera, audio, and event systems",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /Fortnite.com/Characters }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { Puzzles }\nusing { /UnrealEngine.com/Temporary/UI }\nusing { /Fortnite.com/UI }\nusing { /Verse.org/Assets }\nusing { /Fortnite.com/Game }\nusing { /Verse.org/Random }\n\nMakePlayerData<constructor>(NewPlayer: ?player, RoomIndex: int):= player_data:\n    # Player := NewPlayer\n    CurrentPlayer := NewPlayer\n    ThisRunMaxRoomIndex := RoomIndex\n\nplayer_data := class:\n\n    # var Player: player\n    var CurrentPlayer: ?player = false\n    var CurrentPlayerCharacter: ?fort_character = false\n    var GlobalEventChannel: global_event_channel = global_event_channel{}\n    var CameraManager: camera_manager = camera_manager{}\n    var HUDMessageDeath: hud_message_device = hud_message_device{}\n    var ThisRunMaxRoomIndex: int = -1\n    var IsHiding: logic = false\n    var CurrentState: player_state = player_state.ALIVE\n\n    var PlayerHeadache: audio_player_device = audio_player_device{}\n    var PlayerDeath1: audio_player_device = audio_player_device{}\n    var PlayerDeath2: audio_player_device = audio_player_device{}\n    var SkipDeathAudio: logic = false\n    \n    var HUDMessageJumpscare: hud_message_device = hud_message_device{}\n    var TrackerJumpscare: tracker_device = tracker_device{}\n\n    AllDeathMessages: []string = array {\n        \"I GOT YOU!\",\n        \"BEWARE\",\n        \"DARE TO TRY AGAIN?\",\n        \"READY TO LEAVE?\",\n        \"HA HA HA\",\n        \"SO EASY\",\n        \"FRESH CATCH\",\n        \"THIS IS SO FUN\",\n        \"YOU WILL REGRET THIS!\"\n    }\n\n    var IsPaintingAttached: logic = false\n\n    var BottomLeftUIStack : stack_box = stack_box{\n        Orientation := orientation.Vertical\n    }\n\n    CheckIsHiding<public>(): logic = \n        return IsHiding\n\n    CheckIsPlayerDead<public>()<transacts><decides>: void = \n        logic{CurrentState <> player_state.ALIVE}?\n\n    GetPlayer<public>(): ?player =\n        return CurrentPlayer\n\n    SetupPlayer(\n        NewGlobalEventChannel: global_event_channel,\n        NewCameraManager: camera_manager,\n        NewAudioDevices: game_audio_devices,\n        NewHUDDeath: hud_message_device,\n        NewHUDJumpscare: hud_message_device,\n        NewTrackerJumpscare: tracker_device\n    ): void =\n        # Print(\"Player setup\")\n        set GlobalEventChannel = NewGlobalEventChannel\n        set CameraManager = NewCameraManager\n        set HUDMessageDeath = NewHUDDeath\n        set HUDMessageJumpscare = NewHUDJumpscare\n        set TrackerJumpscare = NewTrackerJumpscare\n\n        GlobalEventChannel.PlayerEventChannel.SubscribeChannel(NewPlayerEvent, \"player_data\")\n        if(ActualPlayer := CurrentPlayer?, ActualPlayerCharacter := ActualPlayer.GetFortCharacter[]):\n            set CurrentPlayerCharacter = option{ActualPlayerCharacter}\n\n            ActualPlayerCharacter.EliminatedEvent().Subscribe(PlayerEliminated)\n            CameraManager.SetupCameraManager(ActualPlayerCharacter)\n\n        set PlayerHeadache = NewAudioDevices.PlayerHeadache\n        set PlayerDeath1 = NewAudioDevices.PlayerDeath1\n        set PlayerDeath2 = NewAudioDevices.PlayerDeath2\n\n    ResetPlayer(): void =\n        set IsHiding = false\n        # HUDMessageDeath.Hide()\n\n    OnPlayerSpawned(): void =\n        HUDMessageDeath.Hide()\n        set CurrentState = player_state.ALIVE\n\n    NewPlayerEvent(EventName: event_names, Data: event_data, Agent: ?agent): void =\n        if(ActualPlayer := CurrentPlayer?, ActualPlayer = player[Agent?]):\n            case (EventName):\n                event_names.PLAYER_START_RUN =>\n                    set ThisRunMaxRoomIndex = -1\n                    \n                event_names.PLAYER_SPAWNED => \n                    OnPlayerSpawned()\n\n                event_names.PLAYER_HIDE_TOGGLE =>\n                    if(EventData:= event_player_hide[Data]): \n                        ToggleHiding(EventData)\n\n                event_names.PLAYER_SEEING_EYES =>\n                    if(EventData:= event_player_sees_eyes[Data]):\n                        SeeingEyes(EventData)\n\n                event_names.PLAYER_STOP_SEEING_EYES =>\n                    StopSeeingEyes()\n\n                event_names.PLAYER_JUMPSCARE =>\n                    spawn{FireJumpscare()}\n\n                event_names.PLAYER_ELIMINATED =>\n                    ResetPlayer()\n                    Print(\"Yes, player has been eliminated\")\n\n                _ => # default\n                    Print(\"PLAYER: Default case body\")\n\n    NewRoomEntered(NewRoomIndex: int): logic =\n        if(NewRoomIndex > ThisRunMaxRoomIndex):\n            set ThisRunMaxRoomIndex = NewRoomIndex\n            Print(\"Current max room index {ThisRunMaxRoomIndex}\")\n            return true\n        return false\n\n    ToggleHiding(EventData: event_player_hide): void =\n        Print(\"incoming hide event\")\n        if(Player := CurrentPlayer?, PlayerFortCharacter := agent[Player].GetFortCharacter[]):\n            var TeleportTransform: transform = transform{}\n            if(IsHiding?):\n                set TeleportTransform = EventData.ExitTransform\n                Print(\"Teleporting outside\")\n            else:\n                set TeleportTransform = EventData.HidingTransform\n                Print(\"Teleporting inside\")\n                \n            if(PlayerFortCharacter.TeleportTo[TeleportTransform.Translation, TeleportTransform.Rotation]):\n                # PlayerFortCharacter.PutInStasis(stasis_args{AllowTurning := true})\n                set IsHiding = logic{not IsHiding?}\n                Print(\"Hiding {IsHiding.ToString()}\")\n                if(PlayerAgent := agent[Player]):\n                    if(IsHiding?):\n                        EventData.HidingButton.SetInteractionText(StringToMessage(\"Exit\"))\n                        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_HIDE_SUCCESS, event_player_hide_success{ExitTransform := EventData.ExitTransform}, option{PlayerAgent})\n                    else:\n                        EventData.HidingButton.SetInteractionText(StringToMessage(\"Hide\"))\n                        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_UNHIDE_SUCCESS, event_data{}, option{PlayerAgent})\n\n                \n\n    SeeingEyes(EventData: event_player_sees_eyes): void =\n        if(Player := CurrentPlayer?, PlayerFortCharacter := agent[Player].GetFortCharacter[]):\n            PlayerFortCharacter.Damage(EventData.DamageAmount)\n            Print(\"damage done {EventData.DamageAmount}\")\n\n    StopSeeingEyes(): void =\n        Print(\"damage stopped\")\n\n    PlayerEliminateByEntity(EliminateSource: transform, EliminationText: ?string): void =\n        if(not CheckIsPlayerDead[]):\n            spawn{PlayerEliminateCutscene(EliminateSource, EliminationText)}\n\n    PlayerEliminateCutscene(EliminateSource: transform, EliminationText: ?string)<suspends>: void =\n        if(not CheckIsPlayerDead[]):\n            set CurrentState = player_state.DEATH_SCHEDULED\n            StopAllAudios()\n            if(EliminationString := EliminationText?):\n                HUDMessageDeath.SetText(StringToMessage(EliminationString))\n            else:\n                HUDMessageDeath.SetText(GetRandomDeathMessage())\n            HUDMessageDeath.Show()\n\n            Print(\"PlayerEliminateCutscene MoveCameraFromPlayerToTarget\")\n            CameraManager.MoveCameraFromPlayerToTarget(EliminateSource, 2.0)\n            Print(\"PlayerEliminateCutscene MoveCameraFromPlayerToTarget DONE\")\n            Sleep(2.0)\n            Print(\"PlayerEliminateCutscene Sleep DONE\")\n            CameraManager.MoveCameraBackToPlayer()\n            Print(\"PlayerEliminateCutscene MoveCameraBackToPlayer DONE\")\n            if(ActualPlayerCharacter := CurrentPlayerCharacter?):\n                set SkipDeathAudio = true\n                ActualPlayerCharacter.Damage(ActualPlayerCharacter.GetHealth())\n                Print(\"PlayerEliminateCutscene: ActualPlayerCharacter.Damage\")\n\n    PlayerEliminated(EliminationResult : elimination_result): void =\n        Print(\"PlayerEliminated\")\n        set CurrentState = player_state.DEAD\n        if(not SkipDeathAudio?):\n            PlayerHeadache.Play()\n            PlayerDeath1.Play()\n        set SkipDeathAudio = false\n        GlobalEventChannel.PlayerEventChannel.BroadcastChannel(event_names.PLAYER_ELIMINATED, event_player_eliminated{}, CurrentPlayer)\n\n    GetRandomDeathMessage(): message = \n        var DeathMessage : message = StringToMessage(\"dummy death message\")\n        MessageIndex := GetRandomInt(0, AllDeathMessages.Length - 1)\n        if(NewDeathMessage := AllDeathMessages[MessageIndex]):\n            set DeathMessage = StringToMessage(NewDeathMessage)\n        return DeathMessage\n\n    StopAllAudios(): void =\n        PlayerHeadache.Stop()\n        PlayerDeath1.Stop()\n        PlayerDeath2.Stop()\n\n    FireJumpscare()<suspends>: void =\n        RNG := GetRandomInt(1,2)\n        HUDMessageJumpscare.SetText(StringToMessage(\"{RNG}\"))\n        TrackerJumpscare.SetValue(RNG)\n        Print(\"FireJumpscare: {RNG}\")\n        HUDMessageJumpscare.Show()\n        Sleep(1.0)\n        HUDMessageJumpscare.Hide()\n        return\n\n    AddItemToBottomLeftUI(StackSlot : stack_box_slot): void=\n        BottomLeftUIStack.AddWidget(StackSlot)\n\n    RemoveItemFromBottomLeftUI(StackSlot : stack_box_slot): void=\n        BottomLeftUIStack.RemoveWidget(StackSlot.Widget)",
    "external_calls": [
      "global_event_channel",
      "camera_manager",
      "game_audio_devices",
      "player_state",
      "event_names",
      "event_data",
      "event_player_hide",
      "event_player_sees_eyes",
      "event_player_hide_success",
      "event_player_eliminated",
      "fort_character",
      "elimination_result",
      "stack_box",
      "stack_box_slot",
      "orientation",
      "StringToMessage",
      "GetRandomInt"
    ]
  }
] 