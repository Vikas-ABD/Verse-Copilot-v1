{
    "file_name": "VotingSystem.verse",
    "questions": [
        "How do I create a map voting system in Verse?",
        "What is the Verse code for a UI that lets players vote on the next map?",
        "How can I randomly select maps for a vote, count player votes, and then teleport teams to the winning map's spawners?"
    ],
    "explanation": "This script defines a 'votingSystemModule' that contains a comprehensive map voting system for the pre-game lobby. It handles everything from shuffling the map options to building the UI, tallying votes, and teleporting players to the selected map.\n\n- **Structure:** The main 'VotingSystem' device manages the state. It uses a 'currentmap' enum to define the available maps and relies on a large number of custom tags (e.g., 'P1_Map1_Spawner', 'P2_Map1_Teleporter') to locate the correct spawners and teleporters for each team on each map.\n- **Core Logic:**\n  - `OnBegin`: The script first finds and stores references to all the tagged player spawners and teleporters for every map and team.\n  - `ShuffleMaps`: Before a vote begins, this function randomizes a selection of maps to present to the players.\n  - `CreateCanvasVote`: This function dynamically builds the voting UI, creating buttons with images and text for each map option.\n  - `OnVoteClicked`: This function handles player input from the UI, updates the vote counts for each map, and refreshes the UI to show the current tally.\n  - `TimerEnded`: Once the voting period is over, this function determines the winning map, sets the global `mapselected` variable, and then calls the `Teleport` function to move each player to their correct team spawn on the chosen map.",
    "code": "using { /Fortnite.com/Devices }\nusing { /Verse.org/Simulation }\nusing { /UnrealEngine.com/Temporary/Diagnostics }\nusing { /UnrealEngine.com/Temporary/UI }\nusing { /Verse.org/Assets }\nusing { /Verse.org/Random }\nusing { /UnrealEngine.com/Temporary/SpatialMath }\nusing { /Fortnite.com/UI }\nusing { /Verse.org/Colors }\nusing { /Fortnite.com/Characters }\n\n\n\nvotingSystemModule<public>:= module:\n \n current_button:=class(CustomUI.button_base){\n      BackgroundSize<override> :vector2=vector2{X:= 245.0, Y:=55.0}\n      MapName:currentmap\n  }\n\n  currentmap<public>:=enum{Shipment,KillHouse,Market,Village,Crash}\n\n  (Currentmap:currentmap).ToString():string={\n    case (Currentmap):\n      currentmap.Shipment => \"Shipment \"\n      currentmap.KillHouse => \"KillHouse \"\n      currentmap.Market => \"Market \"\n      currentmap.Village => \"Village \"\n      currentmap.Crash => \"CrashSite \"\n  }\n  GetAllMaps<public>()<transacts>:[]currentmap={currentmap.Shipment,currentmap.KillHouse,currentmap.Market,currentmap.Village,currentmap.Crash}\n\n  Param_container:=class:\n    \n    IntegerParam<public>: int\n    MainDevice<public> :VotingSystem\n\n    # ButtonClick<public>(WidgetMessage:widget_message):void=\n    #  MainDevice.OnVoteClicked(WidgetMessage,IntegerParam)\n    \n\n\n VotingSystem<public> := class(creative_device):\n      \n      @editable\n      UIControllPanel:CustomUI.ui_controll_panel_device = CustomUI.ui_controll_panel_device{}\n      \n      \n    #-------------not in use----------------------------\n      @editable\n      Teleporters:[]teleporter_device = array{}\n    #----------------Names and texture tuple of maps\n      VotesData:[]tuple(texture,string) =array{\n       (Textures.Shipment,\"Shipment\"),\n       (Textures.Killhouse,\"KillHouse\"),\n       (Textures.CrossFire_1,\"Market\"),\n       (Textures.Village,\"Village\"),\n       (Textures.Crash,\"CrashSite\")\n\n\n      \n      }\n      @editable\n      MiniMapController:[]map_controller_device = array{}\n\n      var PreviousMap:int=-1\n      var PreviousMap1:int=-1\n    #----------Set max vote shuffed map and data\n      var ShuffledIndexes:[]int = array{}\n      var VotesToSelect:int=6\n      var SelectedVotesData <public>:[]tuple(texture,string)= array{}\n       \n      var Current_button:[]current_button=array{}\n      #---------enum of map selected------------\n      var mapselected<public>:currentmap = currentmap.Shipment\n\n      #----------teleporters----------------------\n      \n      var TeleportersTeam1:[]teleporter_device = array{}\n      \n      var TeleportersTeam2:[]teleporter_device = array{}\n      @editable\n      LobbySpawner:[]player_spawner_device = array{}\n     \n      var PLSpawnerTeam1:[]player_spawner_device = array{}\n      \n      var PLSpawnerTeam2:[]player_spawner_device = array{}\n\n      #---------canvas and votes p agernt etc--------------\n      var CastedVotes <public>:[]int = array{}\n      var CastedVoteperPlayer<public>:[player]int=map{}\n      var CurrentVoteTeleporters:[]teleporter_device = array{}\n      \n\n  OnBegin<override>()<suspends>:void={\n     P1_M1_Spawners := FindCreativeObjectsWithTag(P1_Map1_Spawner{})\n        for (OBJ : P1_M1_Spawners, Spawner := player_spawner_device[OBJ]){\n          set PLSpawnerTeam1 += array{Spawner}\n        }\n      P1_M2_Spawners := FindCreativeObjectsWithTag(P1_Map2_Spawner{})\n      for (OBJ : P1_M2_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam1 += array{Spawner}\n      }\n\n      P1_M3_Spawners := FindCreativeObjectsWithTag(P1_Map3_Spawner{})\n      for (OBJ : P1_M3_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam1 += array{Spawner}\n      }\n\n      P1_M4_Spawners := FindCreativeObjectsWithTag(P1_Map4_Spawner{})\n      for (OBJ : P1_M4_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam1 += array{Spawner}\n      }\n\n      P1_M5_Spawners := FindCreativeObjectsWithTag(P1_Map5_Spawner{})\n      for (OBJ : P1_M5_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam1 += array{Spawner}\n      }\n      #teleporterss\n      P1_M1_Teleporter := FindCreativeObjectsWithTag(P1_Map1_Teleporter{})\n      for (OBJ : P1_M1_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam1 += array{Spawner}\n      }\n\n      P1_M2_Teleporter := FindCreativeObjectsWithTag(P1_Map2_Teleporter{})\n      for (OBJ : P1_M2_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam1 += array{Spawner}\n      }\n\n      P1_M3_Teleporter := FindCreativeObjectsWithTag(P1_Map3_Teleporter{})\n      for (OBJ : P1_M3_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam1 += array{Spawner}\n      }\n\n      P1_M4_Teleporter := FindCreativeObjectsWithTag(P1_Map4_Teleporter{})\n      for (OBJ : P1_M4_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam1 += array{Spawner}\n      }\n\n      P1_M5_Teleporter := FindCreativeObjectsWithTag(P1_M5_Teleporter{})\n      for (OBJ : P1_M5_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam1 += array{Spawner}\n      }\n\n\n\n\n      #Team2 spawnersss\n      P2_M1_Spawners := FindCreativeObjectsWithTag(P2_Map1_Spawner{})\n        for (OBJ : P2_M1_Spawners, Spawner := player_spawner_device[OBJ]){\n          set PLSpawnerTeam2 += array{Spawner}\n        }\n      P2_M2_Spawners := FindCreativeObjectsWithTag(P2_Map2_Spawner{})\n      for (OBJ : P2_M2_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam2 += array{Spawner}\n      }\n\n      P2_M3_Spawners := FindCreativeObjectsWithTag(P2_Map3_Spawner{})\n      for (OBJ : P2_M3_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam2 += array{Spawner}\n      }\n\n      P2_M4_Spawners := FindCreativeObjectsWithTag(P2_Map4_Spawner{})\n      for (OBJ : P2_M4_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam2 += array{Spawner}\n      }\n\n      P2_M5_Spawners := FindCreativeObjectsWithTag(P2_Map5_Spawner{})\n      for (OBJ : P2_M5_Spawners, Spawner := player_spawner_device[OBJ]){\n        set PLSpawnerTeam2 += array{Spawner}\n      }\n\n\n    #teleporter p2\n      P2_M1_Teleporter := FindCreativeObjectsWithTag(P2_Map1_Teleporter{})\n      for (OBJ : P2_M1_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam2 += array{Spawner}\n      }\n      P2_M2_Teleporter := FindCreativeObjectsWithTag(P2_Map2_Teleporter{})\n      for (OBJ : P2_M2_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam2 += array{Spawner}\n      }\n      P2_M3_Teleporter := FindCreativeObjectsWithTag(P2_M3_Teleporter{})\n      for (OBJ : P2_M3_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam2 += array{Spawner}\n      }\n      P2_M4_Teleporter := FindCreativeObjectsWithTag(P2_Map4_Teleporter{})\n      for (OBJ : P2_M4_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam2 += array{Spawner}\n      }\n      P2_M5_Teleporter := FindCreativeObjectsWithTag(P2_M5_Teleporter{})\n      for (OBJ : P2_M5_Teleporter, Spawner := teleporter_device[OBJ]){\n        set TeleportersTeam2 += array{Spawner}\n      }\n      \n      \n  }\n  Reset<public>():void={\n    set SelectedVotesData = array{}\n    set CastedVotes = array{}\n    set CastedVoteperPlayer = map{}\n    set ShuffledIndexes = array{}\n    set CurrentMapIndex = -1\n    set VoteCount = 0\n    set Team1 = false\n    set Team1Index=0\n    set Team2Index=0\n    for(Spawner:PLSpawnerTeam1){\n         Spawner.Disable()\n    }\n    for(Spawner:PLSpawnerTeam2){\n         Spawner.Disable()\n    }\n\n    for(Lobby:LobbySpawner){\n      Lobby.Enable()\n    }\n    for(i:=0..Current_button.Length-1){\n     if:\n     \n      CurrentBtnref:=Current_button[i]\n     then:\n      CurrentBtnref.Widget.SetText(TextForUI(\"0\"))\n      Print(\"reseted votingSystem script\")\n      \n    }\n\n    set MapAnalyticSend = false\n    \n    if:\n      GM := GetGameManager[]\n    then:\n      for(PlayerController:GM.PlayerControllers){\n\n        if:\n          LobbyUIRef := PlayerController.MaybeLobbyUI?\n          VotingUIRef := LobbyUIRef.MaybeVotingUI?\n        then:\n          if(OldBtn := VotingUIRef.MaybeOldVotedBTN?): \n            if(Background := OldBtn.Background?):\n                Background.SetTint(OldBtn.DefaultTint)\n                OldBtn.MapHighlightColorBlock.SetColor(OldBtn.DefaultTint)\n                OldBtn.MapHighlightColorBlock.SetOpacity(0.0)\n          set VotingUIRef.MaybeOldVotedBTN = false\n\n      }\n    for(TempMinimap:MiniMapController){\n      TempMinimap.Disable()\n      TempMinimap.Deactivate()\n    }\n\n  }\n  #---------Init buttons-------------\n  Init<public>():void={\n    #C #C Print(\"inside Init function\")\n    Shipment := current_button{\n            Widget:=button_quiet{DefaultText := TextForUI(\"0\")},\n            Background:=option{texture_block{DefaultImage:=Icons.WeaponCategoryBTNBG}},\n            DefaultTint:= UIControllPanel.GetButtonDefaultTint() , \n            SelectedTint:= UIControllPanel.GetButtonSelectedTint() ,\n            MapName:=currentmap.Shipment\n        }\n    set Current_button += array{Shipment}\n    \n    KillHouse := current_button{\n            Widget:=button_quiet{DefaultText := TextForUI(\"0\")},\n            Background:=option{texture_block{DefaultImage:=Icons.WeaponCategoryBTNBG}},\n            DefaultTint:= UIControllPanel.GetButtonDefaultTint(), \n            SelectedTint:= UIControllPanel.GetButtonSelectedTint() ,\n            MapName:=currentmap.KillHouse\n        }\n    set Current_button += array{KillHouse}\n\n    Market := current_button{\n            Widget:=button_quiet{DefaultText := TextForUI(\"0\")},\n            Background:=option{texture_block{DefaultImage:=Icons.WeaponCategoryBTNBG}},\n            DefaultTint:= UIControllPanel.GetButtonDefaultTint(), \n            SelectedTint:= UIControllPanel.GetButtonSelectedTint() ,\n            MapName:=currentmap.Market\n        }\n    set Current_button += array{Market}\n    Village := current_button{\n            Widget:=button_quiet{DefaultText := TextForUI(\"0\")},\n            Background:=option{texture_block{DefaultImage:=Icons.WeaponCategoryBTNBG}},\n            DefaultTint:= UIControllPanel.GetButtonDefaultTint(), \n            SelectedTint:= UIControllPanel.GetButtonSelectedTint() ,\n            MapName:=currentmap.Village\n        }\n    set Current_button += array{Village}\n    Crash := current_button{\n            Widget:=button_quiet{DefaultText := TextForUI(\"0\")},\n            Background:=option{texture_block{DefaultImage:=Icons.WeaponCategoryBTNBG}},\n            DefaultTint:= UIControllPanel.GetButtonDefaultTint(), \n            SelectedTint:= UIControllPanel.GetButtonSelectedTint() ,\n            MapName:=currentmap.Crash\n        }\n    set Current_button += array{Crash}\n  }\n  #--------when to show ui -----\n  ShuffleMaps(Ind:[]int):void={\n    set ShuffledIndexes= Shuffle(Ind)\n    set CurrentVoteTeleporters = array{}\n    set CastedVotes =array{}\n\n    if(ShuffledIndexes[0] = PreviousMap or ShuffledIndexes[1] = PreviousMap or ShuffledIndexes[0] = PreviousMap1 or ShuffledIndexes[1] = PreviousMap1){\n      ShuffleMaps(Ind)\n    }\n  }\n  OnVoteStartTriggered<public>():void={\n    \n    #C #C Print(\"OnvoteTriggered func called\")\n    var Indexes:[]int = array{}\n\n    for(I:=0..VotesData.Length-1){\n      set Indexes+= array{I}\n    }\n    ShuffleMaps(Indexes)\n    \n\n    \n\n    for(I:=1..VotesToSelect,Index:=ShuffledIndexes[I-1],VoteData:= VotesData[Index],Teleporter:=Teleporters[Index]){\n      set SelectedVotesData+=array{(VoteData(0),VoteData(1))}\n      set CurrentVoteTeleporters += array{Teleporter}\n      set CastedVotes += array{0}\n      Print(\"MaxVote index{Index}\")\n      if(I=1 ){\n      set PreviousMap =  Index \n      }else if(I=2){\n        set PreviousMap1 =  Index\n      }\n    }\n    for(TempMinimap:MiniMapController){\n      TempMinimap.Disable()\n      TempMinimap.Deactivate()\n    }\n\n   \n  }\n  \n  #--------close ui when teleporter-------- \n  closeUI<public>(Agent:agent):void={\n    spawn{TimerEnded(Agent,CurrentVoteTeleporters,SelectedVotesData)}\n  }\n  #--------Widget added in lobby ui--------\n  AddWidget<public>():canvas={\n    #C #C Print(\"add Widget func called\")\n    Canvas := CreateCanvasVote(SelectedVotesData)\n    \n    return Canvas\n  }\n\n  RemoveWidget<public>():void={\n    MapSelectionEvent.Signal()\n  }\n  \n var CurrentMapIndex<public>:int=-1\n  var voteonmaps<public>:[]int = array{0,0,0,0,0}\n  var VoteCount<public>:int=0\n  ##-----------------voting buttoncliked\n  OnVoteClicked(WidgetMessage:widget_message,Btn:current_button):void ={\n      if:\n       Index:= Current_button.Find[Btn]\n       VoteCount = voteonmaps[Index]\n      then:\n        \n        \n        if(OldVoteIndex:= CastedVoteperPlayer[WidgetMessage.Player],set CastedVotes[OldVoteIndex]-=1){}\n        \n        if(set CastedVoteperPlayer[WidgetMessage.Player]=Index){}\n          \n        if(set CastedVotes[Index]+=1){}\n        \n        updateBtnText()\n       \n  }\n\n  #------------set vote button text--------------   \n  updateBtnText<public>():void={\n\n    if:\n      GM := GetGameManager[]\n    then:\n      for(PlayerController:GM.PlayerControllers){\n\n        if:\n          LobbyUIRef := PlayerController.MaybeLobbyUI?\n          VotingUIRef := LobbyUIRef.MaybeVotingUI?\n        then:\n          \n          for(i:=0..VotingUIRef.Current_button.Length-1){\n            if:\n              temp:=CastedVotes[i]\n              CurrentBtnref:=VotingUIRef.Current_button[i]\n            then:\n              CurrentBtnref.Widget.SetText(TextForUI(\"{temp}\"))\n          }\n      }\n  }\n \n  var Team1:logic = false\n  var MapAnalyticSend:logic=false\n  ##---------------countdown ---------------\n  TimerEnded(Agent:agent, VoteTeleporters:[]teleporter_device,SelectedVotesDatas:[]tuple(texture,string))<suspends>:void={\n\n\n    for(Lobby:LobbySpawner){\n      Lobby.Disable()\n    }\n\n    TeamCollection := GetPlayspace().GetTeamCollection()\n    Players2:= GetPlayspace().GetPlayers()\n\n    var MaxVote:int = -1\n   for(CastedVote:CastedVotes){\n      if(CastedVote>MaxVote){\n        set MaxVote = CastedVote\n\n       }\n    }\n    \n    var MaxVoteIndexes :[]int = array{}\n    for(I:=0..CastedVotes.Length-1, CastedVote := CastedVotes[I]){\n       if(CastedVote = MaxVote){\n        set MaxVoteIndexes +=array{I}\n       \n       }\n    }\n      # set MaxVoteIndexes = Shuffle(MaxVoteIndexes)\n       if(MaxVoteIndex := MaxVoteIndexes[0],VoteTeleporter:=VoteTeleporters[MaxVoteIndex],VoteData:=SelectedVotesData[MaxVoteIndex]){\n        \n \n        VoteString:string = VoteData(1)\n        \n      #  for(Player:Players2){\n        if:\n          Player := player[Agent]\n          PlayerController := Player.GetPlayerController[Self]\n          FortCharacter := Player.GetFortCharacter[]\n        then:\n\n        #   Select teleports according to VoteData-----------------------\n          if (AgentsTeam := TeamCollection.GetTeam[Agent]){\n              TeamArray := TeamCollection.GetTeams()\n            for (TeamNumber->Team : TeamArray){\n                if (AgentsTeam = Team){\n                  \n                  \n                  case(VoteString):\n                    \"Shipment\"=> \n                        set mapselected = currentmap.Shipment\n                        # Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        # set PreviousMap = 0\n                        #  Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        Teleport(TeamNumber,0,Player)\n                        if:\n                            not MapAnalyticSend?\n                            AM := GetAnalyticManager[]\n                        then:\n                            set MapAnalyticSend = true\n                            AM.SendAnalytic(Agent, AnalyticsModule.analytic_type.MapSelected, ?MapType:=option{currentmap.Shipment})\n                   \n                    \"KillHouse\"=> \n                      set mapselected = currentmap.KillHouse\n                      # Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                      # set PreviousMap = 1\n                      # Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                      Teleport(TeamNumber,1,Player)\n                      if:\n                          not MapAnalyticSend?\n                        AM := GetAnalyticManager[]\n                      then:\n                          set MapAnalyticSend = true\n                          AM.SendAnalytic(Agent, AnalyticsModule.analytic_type.MapSelected, ?MapType:=option{currentmap.KillHouse})\n                    \n                    \"Market\"=> \n                        set mapselected = currentmap.Market\n                        # Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        # set PreviousMap = 2\n                        # Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        Teleport(TeamNumber,2,Player)\n                        if:\n                            not MapAnalyticSend?\n                            AM := GetAnalyticManager[]\n                        then:\n                            set MapAnalyticSend = true\n                            AM.SendAnalytic(Agent, AnalyticsModule.analytic_type.MapSelected, ?MapType:=option{currentmap.Market})\n                    \n                    \"Village\"=> \n                        set mapselected = currentmap.Village\n                        # Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        # set PreviousMap = 3\n                        #  Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        Teleport(TeamNumber,3,Player)\n                        if:\n                            not MapAnalyticSend?\n                            AM := GetAnalyticManager[]\n                        then:\n                            set MapAnalyticSend = true\n                            AM.SendAnalytic(Agent, AnalyticsModule.analytic_type.MapSelected, ?MapType:=option{currentmap.Village})\n                    \n                    \"CrashSite\"=> \n                        set mapselected = currentmap.Crash\n                        # Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        # set PreviousMap = 4\n                        #  Print(\"MaxVote index {MaxVoteIndex}  PreviousVote {PreviousMap}\")\n                        Teleport(TeamNumber,4,Player)\n                        if:\n                            not MapAnalyticSend?\n                            AM := GetAnalyticManager[]\n                        then:\n                            set MapAnalyticSend = true\n                            AM.SendAnalytic(Agent, AnalyticsModule.analytic_type.MapSelected, ?MapType:=option{currentmap.Crash})\n                        \n                    _=>#C #C Print(\"default\")\n        \n                }\n          }\n        }\n\n        \n      }\n      \n    # }\n  }\n  @editable\n  maxPlayers:int = 3\n  var Team1Index:int=0\n  var Team2Index:int=0\n @editable\n  MaxMapToShow<public>:int=4\n\n\n  Teleport<public>(TeamNumber:int,MapIndex:int,Player:player):void={\n   if:\n     PlayerController := Player.GetPlayerController[Self]\n     FortCharacter := Player.GetFortCharacter[]\n   then:\n        if(TeamNumber = 0){\n            \n          if:\n            In:=maxPlayers*MapIndex\n            DummyT := TeleportersTeam1[In+Team1Index]\n            MiniMap:= MiniMapController[MapIndex]\n          #   DummySpawnerT := PLSpawnerTeam2[In+Team1Index]\n          then:\n            MiniMap.Enable()\n            MiniMap.Activate()\n            for(SpawnerIndex:=In..In+maxPlayers-1){\n            if:\n              DummySpawner:=PLSpawnerTeam1[SpawnerIndex]\n            then:\n              DummySpawner.Enable()\n            }\n            Transform :transform= transform {\n              Translation := DummyT.GetTransform().Translation,\n              Rotation:= DummyT.GetTransform().Rotation,\n              Scale := FortCharacter.GetTransform().Scale\n              }\n            if(FortCharacter.TeleportTo[Transform.Translation, Transform.Rotation]){Print(\"Teleported Team{TeamNumber}{MapIndex}{Team1Index}   {Transform.Translation}\")}\n            set Team1 = true\n            #C #C Print(\"Spawner unlocked {mapselected.ToString()}\")\n            set Team1Index+=1\n            \n        }else{\n          if:\n            In:=maxPlayers*MapIndex\n            DummyT := TeleportersTeam2[In+Team2Index]\n           # DummySpawnerT := PLSpawnerTeam2[In+Team2Index]\n            MiniMap:= MiniMapController[MapIndex]\n          then:\n            MiniMap.Enable()\n            MiniMap.Activate()\n            for(SpawnerIndex:=In..In+maxPlayers-1){\n            if:\n              DummySpawner:=PLSpawnerTeam2[SpawnerIndex]\n            then:\n              DummySpawner.Enable()\n              \n            }\n            Transform :transform= transform {\n              Translation := DummyT.GetTransform().Translation,\n              Rotation:= DummyT.GetTransform().Rotation,\n              Scale := FortCharacter.GetTransform().Scale\n              }\n            if(FortCharacter.TeleportTo[Transform.Translation, Transform.Rotation]){Print(\"Teleported Team{TeamNumber}{MapIndex}{Team2Index}  {Transform.Translation}\")}\n            set Team1 = false\n            set Team2Index+=1\n           #C #C Print(\"Spawner unlocked {mapselected.ToString()}\")\n            \n            \n        }\n   }\n  ##-------------canvas creation-----------------------\n  CreateCanvasVote(VotedDataTuples:[]tuple(texture,string)):canvas={\n                      \n      HORI_Maps_Stack_Box:stack_box= stack_box:\n       Orientation:=orientation.Horizontal\n              Slots:=array:\n              \n      for(i:=0..MaxMapToShow-1){\n       if:\n        VotedDataTuple:=VotedDataTuples[i]\n        Curr_button:=Current_button[i] \n       then:\n        set CurrentMapIndex = i\n        spawn{Curr_button.AwaitButtonInteract(CurrentMapIndex)}\n\n        VoteTexture:texture=VotedDataTuple(0)\n        VoteString:string = VotedDataTuple(1)\n        #C #C Print(\"currentindex  {CurrentMapIndex}  {VoteString}\")\n\n        HORI_Maps_Stack_Box.AddWidget(\n         stack_box_slot:\n            HorizontalAlignment:=horizontal_alignment.Fill\n            VerticalAlignment:=vertical_alignment.Fill\n            Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n            Widget:=stack_box:\n             Orientation:=orientation.Vertical\n                Slots:=array:\n                  stack_box_slot:\n                    Distribution := option{0.7}\n                    HorizontalAlignment:=horizontal_alignment.Fill\n                    VerticalAlignment:=vertical_alignment.Fill\n                    Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n                    Widget:=overlay:\n                      Slots:=array:\n                        overlay_slot:\n                          HorizontalAlignment:=horizontal_alignment.Fill\n                          VerticalAlignment:=vertical_alignment.Fill\n                          Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n                          Widget:=overlay:\n                            Slots:=array:\n                              overlay_slot:\n                                HorizontalAlignment := horizontal_alignment.Center\n                                VerticalAlignment := vertical_alignment.Center\n                                Padding := margin{Top := 5.0, Left := 5.0, Right := 5.0, Bottom := 5.0}\n                                \n                                Widget:= texture_block{DefaultImage:= VoteTexture, DefaultDesiredSize := vector2{X:= 256.0,Y:= 256.0} }\n                              overlay_slot:\n                                HorizontalAlignment := horizontal_alignment.Center\n                                VerticalAlignment := vertical_alignment.Bottom\n                                Padding := margin{Top := 0.0, Left := 0.0, Right := 0.0, Bottom := 5.0}\n                                \n                                Widget:= text_block{\n                                  DefaultTextColor:= UIControllPanel.GetDefaultTextColor() , \n                                  DefaultText:= TextForUI(\"{VoteString}\")\n                                  }\n                  stack_box_slot:\n    \n                    HorizontalAlignment:=horizontal_alignment.Fill\n                    VerticalAlignment:=vertical_alignment.Fill\n                    Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n                    Widget:=overlay:\n                      Slots:=array:\n                        overlay_slot:\n                          HorizontalAlignment:=horizontal_alignment.Fill\n                          VerticalAlignment:=vertical_alignment.Fill\n                          Padding:=margin{Top:=10.0,Left:=10.0,Right:=10.0,Bottom:=10.0}\n                          Widget:=overlay:\n                            Slots:=array:\n                              overlay_slot:\n                                HorizontalAlignment := horizontal_alignment.Center\n                                VerticalAlignment := vertical_alignment.Fill\n                                Padding := margin{Top := 0.0, Left := 0.0, Right := 0.0, Bottom := 0.0}\n                                Widget:=texture_block{DefaultImage:= UIAssets.Lobby_Button, DefaultDesiredSize := vector2{X:= 245.0,Y:= 55.0} }\n                                \n                              #   Widget:= color_block{DefaultOpacity:=1.0, DefaultDesiredSize:= vector2{X:= 245.0, Y:= 55.0}}\n                              overlay_slot:\n                                HorizontalAlignment:=horizontal_alignment.Fill\n                                VerticalAlignment:=vertical_alignment.Fill\n\n                                Widget:= Curr_button.Widget\n\n                                \n                      \n                        \n                      \n                        \n        )\n      }\n      MapVoteOverlay:overlay = overlay:\n       Slots:=array:\n          overlay_slot:\n            HorizontalAlignment:=horizontal_alignment.Fill\n            VerticalAlignment:=vertical_alignment.Fill\n            Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n\n            Widget:=color_block{DefaultOpacity:=0.2, DefaultDesiredSize:= vector2{X:= 530.0, Y:= 405.0}}#\n          overlay_slot:\n            HorizontalAlignment:=horizontal_alignment.Fill\n            VerticalAlignment:=vertical_alignment.Fill\n            Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n\n            Widget:=stack_box:\n              Orientation:=orientation.Vertical\n              Slots:=array:\n                stack_box_slot:\n                  HorizontalAlignment:=horizontal_alignment.Fill\n                  VerticalAlignment:=vertical_alignment.Fill\n                  Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n                  Widget:=overlay:\n                    Slots:=array:\n                      overlay_slot:\n                        HorizontalAlignment:=horizontal_alignment.Fill\n                        VerticalAlignment:=vertical_alignment.Fill\n                        Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n                        Widget:=color_block{\n                          DefaultColor:= UIControllPanel.GetHeaderTint(), \n                          DefaultDesiredSize:= vector2{X:= 530.0, Y:= 65.0}\n                          }\n                      overlay_slot:\n                        HorizontalAlignment:=horizontal_alignment.Center\n                        VerticalAlignment:=vertical_alignment.Center\n                        Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n                        Widget:= text_block{\n                          DefaultTextColor:= UIControllPanel.GetDefaultTextColor() , \n                          DefaultText:= TextForUI(\"VOTE\")\n                          }\n                \n                stack_box_slot:\n                  HorizontalAlignment:=horizontal_alignment.Fill\n                  VerticalAlignment:=vertical_alignment.Fill\n                  Padding:=margin{Top:=0.0,Left:=0.0,Right:=0.0,Bottom:=0.0}\n    \n                  Widget:=HORI_Maps_Stack_Box\n                  #Orientation:=orientation.Horizontal\n                 \n                \n\n\n            \n                \n                  \n    \n   \n      # Distribution := option{0.7}\n\n      Canvas:canvas = canvas:\n       Slots:= array:\n        canvas_slot:\n          Anchors:=anchors{Minimum:=vector2{X:=0.0,Y:=1.0},Maximum:=vector2{X:=0.0,Y:=1.0}}\n          Offsets:= margin{Top:=-70.0,Left:=70.0,Right:=0.0,Bottom:=-70.0}\n          Alignment:=vector2{X:=0.0,Y:=1.0}\n          ZOrder:= 2\n          SizeToContent := true\n          Widget:=MapVoteOverlay\n\n      return Canvas\n  }\n\n  #-----------map select button-------------\n  MapSelectionEvent:event():=event(){}\n\n  (BTN:current_button).AwaitButtonInteract(IntegerParam :int)<suspends>:void={\n      race:\n          block:\n            MapSelectionEvent.Await()\n\n          loop:\n              Result := BTN.Widget.OnClick().Await()\n              \n              OnVoteClicked(Result,BTN)\n  }\n\n  \n      ",
    "external_calls": [
        "ui_base.verse",
        "ui_assets.verse",
        "tags.verse",
        "game_manager.verse",
        "player_controller.verse",
        "lobby_ui.verse",
        "AnalyticDevice.verse"
    ]
}

